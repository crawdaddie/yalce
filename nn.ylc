import lib/Math;
import lib/Arrays;
let open_file = extern fn String -> String -> Option of Ptr;
let fclose = extern fn Ptr -> ();
let read_bytes = extern fn Ptr -> Array of Char;
let read_lines = extern fn Ptr -> (List of String, Int);
let _scanf = extern fn Ptr -> Ptr -> Int -> Ptr -> ();


let (content, len) = match (open_file "examples/micrograd/moons.csv" "rb") with
  | Some fd -> (
    let c, l = read_lines fd;
    fclose fd;
    (c, l)
  )
  | None -> ([""], 0)
;

type MoonsRow = (x1: Double, x2: Double, label: Int);
type MoonsDataset = (x1: Array of Double, x2: Array of Double, label: Array of Int);

let init_moons_df = fn size -> 
  MoonsDataset (array_fill_const size 0.) (array_fill_const size 0.) (array_fill_const size 0)
;;



let format_dataset = fn l size -> 

  let df = init_moons_df size;

  let aux = fn idx lines x: (MoonsDataset) ->
    match lines with
    | [] -> ()
    | row_str::rest -> (
      _scanf (cstr "%lf,%lf,%d") (cstr row_str) 3 (df_raw_fields x);
      aux (idx + 1) rest (df_offset x 1)
    )
  ;;

  aux 0 l df;
  df 
;;
let df = format_dataset content len;

let (@) = array_at;

print `3: {df.x1 @ 0}, {df.x2 @ 0}, {df.label @ 0}\n`
;

type Matrix = (
  rows: Int,
  cols: Int,
  data: Array of Double
);

type Layer = (
  weights: Matrix,
  biases: Array of Double,
  activation: ((Array of Double) -> (Array of Double))
);

let matrix_zeroes = fn c r ->
  Matrix r c (array_fill_const (r * c) 0.)
;;

# let matrix_fill = fn r c f ->
#   Matrix r c (array_fill (r * c) f)
# ;;
#
let matrix_to_str = fn m: (Matrix) ->
  ""
;;


type Network = (
  layers: Array of Layer,
  loss: ((Array of Double) -> (Array of Double) -> Double)
);

let loss = fn a: (Array of Double) b: (Array of Double) -> 0.;;

# let z = matrix_zeroes 256 256;

let max_in = array_fill_const 16 0.; # allocate an input array which is as large as the maximum layer width
# array operations will be done in place 

let MLP = Network [|
  Layer (matrix_zeroes 2 16) (array_fill_const 16 0.) (fn i: (Array of Double) -> i),
  Layer (matrix_zeroes 16 16) (array_fill_const 16 0.) (fn i: (Array of Double) -> i),
  Layer (matrix_zeroes 16 1) (array_fill_const 1 0.) (fn i: (Array of Double) -> i),
  |] loss
;

# let matrix_vec_mul = fn m: (Matrix) v: (Array of Double) ->
#   [|1., 2.|]
# ;;

let vec_add = fn u: (Array of Double) v: (Array of Double) ->
  [|1., 2.|]
;;

let _matrix_vec_mul = extern fn Int -> Int -> Ptr of Double -> Ptr of Double -> ();
let matrix_vec_mul = fn m: (Matrix) v: (Array of Double) ->
  _matrix_vec_mul m.rows m.cols (cstr m.data) (cstr v);
  v
;;

let vec_add = fn a: (Array of Double) b: (Array of Double) -> [|1., 2.|];

# Forward pass
let forward = fn input: (Array of Double) network: (Network) ->
  let layers = network.layers;

  Arrays.fold (fn current: (Array of Double) layer: (Layer) ->
    current
    |> matrix_vec_mul layer.weights
    |> vec_add layer.biases
    |> layer.activation

  ) input layers
;;

forward max_in MLP;

