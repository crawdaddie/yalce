open examples/micrograd/micro;
import examples/micrograd/neuron;
import lib/Math;
#
#
#
let open_file = extern fn String -> String -> Option of Ptr;
let fclose = extern fn Ptr -> ();
let read_bytes = extern fn Ptr -> Array of Char;
let read_lines = extern fn Ptr -> (List of String, Int);
let _scanf = extern fn Ptr -> Ptr -> Int -> Ptr -> ();


let (content, len) = match (open_file "examples/micrograd/moons.csv" "rb") with
  | Some fd -> (
    let c, l = read_lines fd;
    fclose fd;
    (c, l)
  )
  | None -> ([""], 0)
;

type MoonsRow = (x1: Double, x2: Double, label: Int);
type MoonsDataset = (x1: Array of Double, x2: Array of Double, label: Array of Int);

let init_moons_df = fn size -> 
  MoonsDataset (array_fill_const size 0.) (array_fill_const size 0.) (array_fill_const size 0)
;;



let format_dataset = fn l size -> 

  let df = init_moons_df size;

  let aux = fn idx lines x: (MoonsDataset) ->
    match lines with
    | [] -> ()
    | row_str::rest -> (
      _scanf (cstr "%lf,%lf,%d") (cstr row_str) 3 (df_raw_fields x);
      aux (idx + 1) rest (df_offset x 1)
    )
  ;;

  aux 0 l df;
  df 
;;
let df = format_dataset content len;

let (@) = array_at;

print `3: {df.x1 @ 0},{df.x2 @ 0},{df.label}\n`
;




let a = const -4.0;
let b = const 2.0;
let c = add a (mul b (sub a (pow b (const 3.))));
let bc = backward (Value c.data c.children c.op 1.);

let _ = print `
{bc.data}
{to_str bc}
`;


let n = neuron.relu
  (array_fill 10 (fn i: (Int) -> Math.rand_double_range -1. 1.))
  (const 0.);

let n0 = neuron.zero_grad n;

# type Layer = Array of neuron.TNeuron;
# let l = array_fill 10 (fn i -> );

# MLP of [
#   Layer of [
#     ReLUNeuron(2),
#     ReLUNeuron(2),
#     ReLUNeuron(2),
#     ReLUNeuron(2),
#     ReLUNeuron(2),
#     ReLUNeuron(2),
#     ReLUNeuron(2),
#     ReLUNeuron(2),
#     ReLUNeuron(2),
#     ReLUNeuron(2),
#     ReLUNeuron(2),
#     ReLUNeuron(2),
#     ReLUNeuron(2),
#     ReLUNeuron(2),
#     ReLUNeuron(2),
#     ReLUNeuron(2)], # 16 
#
#   Layer of [
#     ReLUNeuron(16),
#     ReLUNeuron(16),
#     ReLUNeuron(16),
#     ReLUNeuron(16),
#     ReLUNeuron(16),
#     ReLUNeuron(16),
#     ReLUNeuron(16),
#     ReLUNeuron(16),
#     ReLUNeuron(16),
#     ReLUNeuron(16),
#     ReLUNeuron(16),
#     ReLUNeuron(16),
#     ReLUNeuron(16),
#     ReLUNeuron(16),
#     ReLUNeuron(16),
#     ReLUNeuron(16)
#   ], 
#
#   Layer of [
#     LinearNeuron(16)
#   ]
# ]
let layer_relu = fn nweights: (Int) size: (Int) ->
  array_fill size (fn i: (Int) -> neuron.relu (array_fill nweights (fn i: (Int) -> Math.rand_double_range -1. 1.)) (const 0.))
;;

let layer_lin = fn nweights: (Int) size: (Int) ->
  array_fill size (fn i: (Int) -> neuron.lin (array_fill nweights (fn i: (Int) -> Math.rand_double_range -1. 1.)) (const 0.))
;;



let MLP = [|
  layer_relu 2 16,
  layer_relu 16 16,
  layer_lin 16 1
|];
