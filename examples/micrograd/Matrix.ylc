import ../../lib/Math;
import ../../lib/Arrays;


type Matrix = (
  rows: Int,
  cols: Int,
  data: Array of T
);

let mfill_const = fn r c v ->
  let arr = array_fill_const (r * c) v;
  Matrix r c arr
;;

let mfill = fn r c f ->
  let arr = array_fill_const (r * c) (f 0 0);
  for i = 1 to (r * c) in (
    arr[i] := f (i / c) (i % c)
  );
  Matrix r c arr
;;

let mget = fn m: (Matrix of T) (i, j): (Int, Int) ->
  m.data[i * m.cols + j]
;;

let mset = fn m: (Matrix of T) (i, j): (Int, Int) v: (T) ->
  m.data[i * m.cols + j] := v
;;


let (@) = mget;

let mmul = fn a: (Matrix of T) b: (Matrix of T) ->
  
  # let c = matrix_zeroes_tmp a.rows b.cols;
  let c = Matrix a.rows b.cols (array_fill_const (a.rows * b.cols) (a @ (0, 0)));
  # matrix_zeroes_tmp a.rows b.cols;
  # print `matrix mul out {c.rows} {c.cols}\n`;

  for i = 0 to a.rows in (
    for j = 0 to b.cols in (
      for k = 0 to b.rows in (
        let v = c @ (i, j);
        c.data[i * c.cols + j] := v + (a @ (i,k)) * b @ (k, j) 
        # a.data[i * a.cols + j] := v + (a @ (i,k)) * b @ (k, j) 
      )
    ) 
  ); 
  c
;;

let mmul_tmp = fn storage: (Array of Double) a: (Matrix of T) b: (Matrix of T) ->
  
  # let c = matrix_zeroes_tmp a.rows b.cols;
  let c = Matrix a.rows b.cols storage;
  # (array_fill_const (a.rows * b.cols) (a @ (0, 0)));
  # matrix_zeroes_tmp a.rows b.cols;
  # print `matrix mul out {c.rows} {c.cols}\n`;

  for i = 0 to a.rows in (
    for j = 0 to b.cols in (
      for k = 0 to b.rows in (
        let v = c @ (i, j);
        c.data[i * c.cols + j] := v + (a @ (i,k)) * b @ (k, j) 
        # a.data[i * a.cols + j] := v + (a @ (i,k)) * b @ (k, j) 
      )
    ) 
  ); 
  c
;;


let msize = fn m: (Matrix of T) -> 
  m.rows * m.cols
;;

let mprint = fn m: (Matrix of T) ->
  print "[|\n";
  for i = 0 to m.rows in (
    print "  [|";
    for j = 0 to m.cols in (
      print `{m.data[(i * m.cols + j)]}, `
    );
    print "|],\n"
  );
  print "|]\n"
;;

let mrow = fn m: (Matrix of T) i ->
  Matrix 1 m.cols (array_range (i * m.cols) m.cols m.data)
;;

let melwise_map_ip = fn f m: (Matrix of T) ->
  for i = 0 to (msize m) in (
    m.data[i] := f (m.data[i])
  );
  m
;;

let mexp = fn m: (Matrix of Double) ->
  melwise_map_ip (fn v -> Math.exp v) m
;;

let msum_rows = fn m: (Matrix of T) ->
  let arr = array_fill_const m.rows (m @ (0,0));
  for i = 0 to m.rows in (
    let row = mrow m i;
    arr[i] := (Arrays.fold (fn s v -> s + v) 0. (row.data))
  );
  Matrix m.rows 1 arr
;;

let msum_rows_tmp = fn arr m: (Matrix of T) ->
  # let arr = array_fill_const m.rows (m @ (0,0));
  for i = 0 to m.rows in (
    let row = mrow m i;
    arr[i] := (Arrays.fold (fn s v -> s + v) 0. (row.data))
  );
  Matrix m.rows 1 arr
;;

let mrow_l2_norm = fn tmp m: (Matrix of T) ->
  let row_norms = msum_rows_tmp tmp m;
  # TODO: cb to mfill is a closure - not working quite
  # mfill m.rows m.cols (fn i j -> (m @ (i, j)) / (row_norms @ (i, 0)) )
  for i = 0 to m.rows in (
    for j = 0 to m.cols in (
      let v = m.data[i * m.cols + j] / (row_norms @ (i, 0));
      m.data[i * m.cols + j] := v
    )
  );
  m
;;


