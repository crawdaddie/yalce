import ../../lib/Arrays;
import ../../lib/Math;
import ../../lib/Ref;


type Matrix = (
  rows: Int,
  cols: Int,
  data: Array of Double
);

let MemPool = module  
  type TMemPool = (head: Array of Double, tail: Array of Double);
  type TMemPoolRef = Array of TMemPool ;

  let create = fn size ->
    let arr = array_fill_const size 0.;
    [|TMemPool arr arr|]
  ;;

  let get_mem = fn pool_: (Array of TMemPool) size: (Int) ->
    # let pool = pool_[0];
    # let arr = array_range 0 size pool.tail;
    # let tail = array_offset size pool.tail;
    # pool_[0] := TMemPool pool.head tail;
    # arr
    #
    let arr = array_fill_const size 0.
  ;;

  let reset = fn pool_: (Array of TMemPool) ->
    let pool = pool_[0];
    pool_[0] := TMemPool pool.head pool.head
  ;;
;

let matrix_zeroes = fn r c ->
  Matrix r c (array_fill_const (r * c) 0.)
;;

let matrix_zeroes_p = fn pool: (Array of MemPool.TMemPool) r c ->
  let size = r * c;
  # let arr = MemPool.get_mem pool size;

  # for i = 0 to size in (
  #   arr[i] := 0.
  # );
  let arr = array_fill_const size 0.;

  Matrix r c arr
;;

let print_matrix = fn m: (Matrix) ->
  print "[|\n";
  for i = 0 to m.rows in (
    print "  [|";
    for j = 0 to m.cols in (
      print `{m.data[(i * m.cols + j)]}, `
    );
    print "|],\n"
  );
  print "|]\n"
;;

let matrix_at = fn m: (Matrix) (r, c): (Int, Int) ->
  m.data[(r * m.cols + c)]
;;

let matrix_access = fn m: (Matrix) i: (List of Int) ->
  match i with
  | [r, c]  -> array_range (r * m.cols + c) 1 m.data
  | [r]     -> array_range (r * m.cols) m.cols m.data
;;

let matrix_size = fn m: (Matrix) -> 
  m.rows * m.cols
;;

let matrix_copy = fn p: (Array of MemPool.TMemPool) m: (Matrix) ->
  let copy = matrix_zeroes_p p m.rows m.cols; 
  for i = 0 to (array_size m.data) in (
    copy.data[i] := m.data[i]
  );
  copy
;;

let print_arr = fn arr: (Array of Double) -> 
  print "[| ";
  for i = 0 to (array_size arr) in (
    print `{arr[i]}, `
  );
  print "|]\n"
  
;;

let matrix_random = fn c r ->
  Matrix r c (array_fill (r * c) (fn i: (Int) -> Math.rand_double_range -1. 1.))
;;

let matrix_1d = fn a: (Array of Double) ->
  Matrix 1 (array_size a) a
;;

let matrix_transpose = fn p: (Array of MemPool.TMemPool) m: (Matrix) ->
  let t = matrix_zeroes_p p m.cols m.rows ;
  for i = 0 to m.rows in (
    for j = 0 to m.cols in (
      let v = m.data[(i * m.cols + j)];
      t.data[j * t.cols + i] := v
    )
  );
  t
;;

let matrix_get = fn m: (Matrix) (i, j): (Int, Int) ->
  m.data[i * m.cols + j]
;;
let (@) = matrix_get;

let matrix_mul = fn p: (Array of MemPool.TMemPool) b: (Matrix) a: (Matrix) ->
  
  let c = matrix_zeroes_p p a.rows b.cols;
  # print `matrix mul out {c.rows} {c.cols}\n`;

  for i = 0 to a.rows in (
    for j = 0 to b.cols in (
      for k = 0 to b.rows in (
        let v = c @ (i, j);
        c.data[i * c.cols + j] := v + (a @ (i,k)) * b @ (k, j) 
        # a.data[i * a.cols + j] := v + (a @ (i,k)) * b @ (k, j) 
      )
    ) 
  ); 
  c
;;

let matrix_add = fn a: (Matrix) b: (Matrix) ->
  "element-wise matrix add - mutates b";
  for i = 0 to (matrix_size a) in (
    let av = a.data[i];
    let bv = b.data[i];
    b.data[i] := (av + bv)
  );
  b
;;




let matrix_sum_rows = fn p: (Array of MemPool.TMemPool) m: (Matrix) ->
  let s = matrix_zeroes_p p m.cols 1; 
  for c = 0 to m.cols - 1 in (
    let sum = [|0.0|];
    for r = 0 to m.rows - 1 in (
      sum[0] := sum[0] + m.data[r * m.cols + c]
    );

    s.data[c] := sum[0]
  );
  
  s
;;

let matrix_sub = fn p: (Array of MemPool.TMemPool) a: (Matrix) b: (Matrix) ->
  let c = matrix_zeroes_p p a.rows b.cols;
  for i = 0 to (array_size a.data) in (
    let av = a.data[i];
    let bv = b.data[i];
    c.data[i] := (av - bv)
  );
  c
;;

let matrix_copy_to = fn target: (Matrix) source: (Matrix) ->
  for i = 0 to (array_size source.data) in (
    target.data[i] := source.data[i]
  );
  target
;;


let matrix_scale = fn p: (Array of MemPool.TMemPool) s: (Double) a: (Matrix) ->
  let c = matrix_zeroes_p p a.rows a.cols;
  for i = 0 to (array_size a.data) in (
    let av = a.data[i];
    c.data[i] := av * s
  );
  c
  
;;

let matrix_mul_elwise = fn p: (Array of MemPool.TMemPool) a: (Matrix) b: (Matrix) ->

  let c = matrix_zeroes_p p a.rows a.cols;
  for i = 0 to (array_size a.data) in (
    let av = a.data[i];
    let bv = b.data[i];
    c.data[i] := av * bv
  );
  c
;;


let Vec = module
  let _matrix_vec_mul = extern fn Int -> Int -> Ptr of Double -> Ptr of Double -> ();
  let matrix_vec_mul = fn m: (Matrix) v: (Matrix) ->
    _matrix_vec_mul m.rows m.cols (cstr m.data) (cstr v.data);
    Matrix m.rows v.cols v.data
  ;;

  let _vec_add = extern fn Int -> Ptr of Double -> Ptr of Double -> ();
  let add = fn a: (Matrix) b: (Matrix) -> 
    _vec_add (matrix_size a) (cstr a.data) (cstr b.data);
    b
  ;;

  let sub = fn a: (Matrix) b: (Matrix) ->

    for i = 0 to (array_size a.data) in (
      let av = a.data[i];
      let bv = b.data[i];
      b.data[i] := (av - bv)
    );
    b
  ;;

  let copy = fn a: (Array of Double) ->

    let b = array_fill_const (array_size a) 0.;

    for i = 0 to (array_size b) in (
      let av = a[i];
      b[i] := av
    );
    b
  ;;

  let write_to = fn to_: (Array of Double) from: (Array of Double) ->
    Arrays.fold (fn t v ->
      t[0] := v;
      array_succ t
    ) to_ from;
    from
  ;;
;
