#! /usr/bin/env ylc --gui -i
open ../../gui/bindings/Gui;
import ../../lib/Math;

let open_file = extern fn String -> String -> Option of Ptr;
let fclose = extern fn Ptr -> ();
let read_bytes = extern fn Ptr -> String;

type StarData = (x: Double, y: Double, z: Double, mag: Double);

let parse_double_simple = extern fn Ptr -> Ptr -> Ptr -> (Double, Int);

let parse_double = fn bytes ->
  let x = [|0.|];
  let n = [|0|];
  
  parse_double_simple (cstr bytes) (cstr x) (cstr n);
  (x[0], n[0])
;;

let set_x = fn v: (Double)(x,y,z,m): (StarData) ->
  StarData v y z m
;;

let set_y = fn v: (Double) (x,y,z,m): (StarData) ->
  StarData x v z m 
;;

let set_z = fn v: (Double) (x,y,z,m): (StarData) ->
  StarData x y v m
;;

let set_mag = fn v: (Double) (x,y,z,m): (StarData) ->
  StarData x y z v
;;



let parse_star_list = fn bytes: (String) list: (List of StarData) cur_star: (StarData) (lines, cols): (Int, Int) ->
  match (array_size bytes, bytes[0], cols) with
  | (0, _, cols) -> (list, (lines, cols))  
  | (_, ',',  cols) -> parse_star_list (array_offset 1 bytes) list cur_star (lines, cols + 1)
  | (_, '\n', cols) -> parse_star_list (array_offset 1 bytes) (cur_star::list) cur_star (lines + 1, 0)

  | (_, char, 14) -> (
    let val, n = parse_double bytes;
    parse_star_list (array_offset n bytes) list (cur_star |> set_mag val) (lines, cols)
  )

  | (_, char, 17) -> (
    let val, n = parse_double bytes;
    parse_star_list (array_offset n bytes) list (cur_star |> set_x val) (lines, cols)
  )

  | (_, char, 18) -> (
    let val, n = parse_double bytes;
    parse_star_list (array_offset n bytes) list (cur_star |> set_y val) (lines, cols)
  )

  | (_, char, 19) -> (
    let val, n = parse_double bytes;
    parse_star_list (array_offset n bytes) list (cur_star |> set_z val) (lines, cols)
  )

  | _ -> parse_star_list (array_offset 1 bytes) list cur_star (lines, cols)
;;

let magnitude_to_brightness = fn mag ->
  let clamped_mag = Math.max (-2.0) (Math.min 12.0 mag);
  
  let brightness = Math.pow 10.0 ((-0.4) * clamped_mag);
  
  let max_brightness = Math.pow 10.0 ((-0.4) * (-2.0));  # mag -2
  let min_brightness = Math.pow 10.0 ((-0.4) * 12.0);    # mag 12
  
  let normalized = (brightness - min_brightness) / (max_brightness - min_brightness);
  Math.max 0.1 (Math.min 1.0 normalized)
;;

let get_stars_array = fn list: (List of StarData) idx arr ->
  match list with
  | [] -> arr
  | (x,y,z,mag)::rest -> (

    let brightness = magnitude_to_brightness mag;
    arr[idx * 6] := x;
    arr[idx * 6 + 1] := y;
    arr[idx * 6 + 2] := z;
    arr[idx * 6 + 3] := brightness;
    arr[idx * 6 + 4] := brightness;
    arr[idx * 6 + 5] := brightness;
    get_stars_array rest (idx+1) arr
  )
;;

let skip_csv_header = fn arr -> 
  let aux = fn arr: (String) idx ->
    match arr[idx] with
    | '\n' -> idx
    | _ -> aux arr (idx + 1)
  ;;
  let off = aux arr 0;
  array_offset off arr
;;

let load_str = fn path ->
  let content = match (open_file path "rb") with
    | Some fd -> read_bytes fd
    | None -> ""
;;

let load = fn path ->
  let content = match (open_file path "rb") with
    | Some fd -> (
      let bytes = (read_bytes fd) |> skip_csv_header;
      let rev_stars, (n, cols) = parse_star_list bytes [] (0., 0., 0., 0., 0., 0.) (0, 0);
      let arr = array_fill_const (n * 6) 0.;
      get_stars_array rev_stars 0 arr 
    )
    | None -> [|0.|]
;;


let arr = load "/Users/adam/Desktop/hygdata_v41.csv";

let VShader = extern fn String -> Ptr;
let FShader = extern fn String -> Ptr;
let TriangleData = extern fn Array of Double -> Ptr;
let MVPView = extern fn Double -> Double -> Double -> Double -> Double -> Double -> Ptr;
let Points = extern fn Array of Double -> Double -> Ptr;
let w = create_decl_window (fn () ->

  let v = MVPView
    2. 3. 8. # pos
    0. 0. 0. # target
  ;

  # let vs = VShader @@ load_str "./vs.glsl";
let vs = VShader `#version 330 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aColor;
uniform mat4 uModel;
uniform mat4 uView;
uniform mat4 uProjection;
out vec3 vertexColor;
out vec3 worldPos;
void main() \{
  vec4 worldPosition = uModel * vec4(aPos, 1.0);
  worldPos = worldPosition.xyz;
  
  // Transform to view space to get distance from camera
  vec4 viewPosition = uView * worldPosition;
  float viewDistance = length(viewPosition.xyz);
  
  // Size based on view distance
  float baseSize = 3.0;
  float scaleFactor = 25.0 / (1.0 + viewDistance * 0.4);
  float finalSize = clamp(baseSize * scaleFactor, 1.0, 25.0);
  
  gl_PointSize = finalSize;
  gl_Position = uProjection * viewPosition;
  vertexColor = aColor;
}`;
  let fs = FShader `#version 330 core
in vec3 vertexColor;
in vec3 worldPos;
uniform vec3 uCameraPos;
uniform float uTime;
out vec4 FragColor;

float random(vec2 st) \{
    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
\}

float noise(vec2 st) \{
    vec2 i = floor(st);
    vec2 f = fract(st);
    float a = random(i);
    float b = random(i + vec2(1.0, 0.0));
    float c = random(i + vec2(0.0, 1.0));
    float d = random(i + vec2(1.0, 1.0));
    vec2 u = f * f * (3.0 - 2.0 * f);
    return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
\}

void main() \{
    vec2 coord = gl_PointCoord - vec2(0.5);
    float dist = length(coord);
    
    // Core gaussian blur
    float core = exp(-dist*dist * 12.0);
    
    // Outer glow
    float glow = exp(-dist*dist * 3.0) * 0.4;
    
    // Diffraction spikes for bright stars
    float brightness_threshold = length(vertexColor);
    if (brightness_threshold > 0.7) \{
        float spike_width = 0.015;
        float spike_length = 0.35;
        
        float h_spike = step(abs(coord.y), spike_width) * step(abs(coord.x), spike_length);
        h_spike *= (1.0 - smoothstep(0.0, spike_length, abs(coord.x))) * 0.5;
        
        float v_spike = step(abs(coord.x), spike_width) * step(abs(coord.y), spike_length);
        v_spike *= (1.0 - smoothstep(0.0, spike_length, abs(coord.y))) * 0.5;
        
        core += h_spike + v_spike;
    \}
    
    // Scintillation
    vec2 noise_coord = worldPos.xy * 30.0 + uTime * 1.5;
    float twinkle = noise(noise_coord) * 0.2 + 0.8;
    
    // Distance-based effects
    float distanceFromCamera = length(worldPos - uCameraPos);
    float distance_brightness = 25.0 / (1.0 + distanceFromCamera * 0.1);
    distance_brightness = clamp(distance_brightness, 0.5, 1.0);
    
    // Combine all effects
    float star_intensity = (core + glow) * twinkle * distance_brightness;
    
    if (star_intensity < 0.01) \{
      discard;
    \}
    
    FragColor = vec4(vertexColor * star_intensity, star_intensity);
\}`;

  let origin = Points [|
    0.0, 0.0, 0., 1.0, 0., 1.,
  |] 10.;

  let points = Points arr 3.

)
