%include ansi_fmt
let iter_all_void = fn () ->
  let co_void = fn () ->
    yield 1.;
    yield 2.;
    yield 3.
  ;;

  let inst = co_void () in

  print `
{ANSI_MAGENTA}{ANSI_BOLD}## simple coroutine 1. -> 2. -> 3. -> done{ANSI_RESET}
{inst ()}
{inst ()}
{inst ()}
{inst ()}
{inst ()}
{inst ()}
`

;;
iter_all_void ();
let rec = fn () ->
  let co_void_rec = fn () ->
    yield 1.;
    yield 2.;
    yield co_void_rec ()
  ;;

  let inst = co_void_rec () in
  print `

{ANSI_MAGENTA}{ANSI_BOLD}## recursive coroutine 1. -> 2. -> 1. -> 2. ...{ANSI_RESET}
{inst ()}
{inst ()}
{inst ()}
{inst ()}
{inst ()}
{inst ()}
`
;;

rec ();

let seq = fn () ->

  let ne = fn () ->
    yield 300.;
    yield 400.
  ;;

  let co_void = fn () ->
    yield 1.;
    yield 2.;
    yield ne ();
    yield 3.
  ;;

  let inst = co_void () in
  print `

{ANSI_MAGENTA}{ANSI_BOLD}## embed coroutine in another 1. -> 2. -> 300. -> 400. -> 3. -> done{ANSI_RESET}
{inst ()}
{inst ()}
{inst ()}
{inst ()}
{inst ()} {inst ()}
`
;;
seq ();


let iter_all_arg = fn () ->
  let co_void = fn a b ->
    yield 1.;
    yield a;
    yield b;
    yield 3.
  ;;

  let inst = co_void 2. 1.;
  print `
{inst ()}
{inst ()}
{inst ()}
{inst ()}
{inst ()}
{inst ()}
`
;; 
iter_all_arg ();

let wrapped_cor = fn () ->
  let wrapper = fn x -> print `specially wrapped: {x}\n`
  ;;

  let co_void = fn () ->
    yield 1;
    yield 2;
    yield 3;
    yield 200
  ;;

  let inst = (co_void () |> cor_wrap_effect wrapper);

  print `
#{ANSI_MAGENTA}{ANSI_BOLD}# coroutine with effectful wrapper wrapped 1 -> 2 -> 3 -> done
## (effects printed above ^^){ANSI_RESET}
{inst ()}
{inst ()}
{inst ()}
{inst ()}
{inst ()}
{inst ()}
`
;;
wrapped_cor ();

let map_cor = fn () ->
  "map each value of a coroutine Int -> String";
  let str_map = fn x -> `{ANSI_BOLD}[str {x}]{ANSI_RESET}`
  ;;
  let co_void = fn () ->
    yield 1;
    yield 2;
    yield 3;
    yield 4;
    yield 5;
    yield 6;
    yield 7 
  ;;

  let co = co_void () |> cor_map str_map;

  print `
{ANSI_MAGENTA}{ANSI_BOLD}## coroutine mapped 1 -> 2 -> 3 -> done{ANSI_RESET}
{co ()}
{co ()}
{co ()}
{co ()}
{co ()}
{co ()}
`
;;
map_cor ();

let fib_cor = fn () ->
  let fib = fn a: (Int) b: (Int) ->
    yield a;
    yield fib b (a + b)
  ;;

  let coi = fib 0 1 in
  print `
{ANSI_MAGENTA}{ANSI_BOLD}# fibonnaci coroutine{ANSI_RESET}
{coi ()}
{coi ()}
{coi ()}
{coi ()}
{coi ()}
{coi ()}
{coi ()}
{coi ()}
{coi ()}
{coi ()}
{coi ()}
{coi ()}
{coi ()}
{coi ()}
{coi ()}
{coi ()}
{coi ()}
{coi ()}
{coi ()}
`
;;
fib_cor();
