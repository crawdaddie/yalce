let iter_all_void = fn () ->
  let co_void = fn () ->
    yield 1.;
    yield 2.;
    yield 3.
  ;;

  let inst = co_void () in

  print `
## simple coroutine 1. -> 2. -> 3. -> done
{inst ()}
{inst ()}
{inst ()}
{inst ()}
{inst ()}
{inst ()}
`

;;

iter_all_void ();

let rec = fn () ->
  let co_void_rec = fn () ->
    yield 1.;
    yield 2.;
    yield co_void_rec ()
  ;;

  let inst = co_void_rec () in
  print `

## recursive coroutine 1. -> 2. -> 1. -> 2. ...
{inst ()}
{inst ()}
{inst ()}
{inst ()}
{inst ()}
{inst ()}
`
;;

rec ();

let seq = fn () ->

  let ne = fn () ->
    yield 300.;
    yield 400.
  ;;

  let co_void = fn () ->
    yield 1.;
    yield 2.;
    yield ne ();
    yield 3.
  ;;

  let inst = co_void () in
  print `

## embed coroutine in another 1. -> 2. -> 300. -> 400. -> 3. -> done
{inst ()}
{inst ()}
{inst ()}
{inst ()}
{inst ()} {inst ()}
`
;;
seq ();

let iter_all_arg = fn () ->
  let co_void = fn a b ->
    yield 1.;
    yield a;
    yield b;
    yield 3.
  ;;

  let inst = co_void 2. 1.;
  print `
## coroutine with args (2., 1.): 1. -> 2. -> 1. -> 3. ...
{inst ()}
{inst ()}
{inst ()}
{inst ()}
{inst ()}
{inst ()}

`
;; 
iter_all_arg ();

let wrapped_cor = fn () ->
  let wrapper = fn x -> print `specially wrapped: {x}\n`
  ;;

  let co_void = fn () ->
    yield 1;
    yield 2;
    yield 3;
    yield 200
  ;;

  let inst = (co_void () |> cor_wrap_effect wrapper);

  print `
## coroutine with effectful wrapper wrapped 1 -> 2 -> 3 -> done
## (effects printed above ^^)
{inst ()}
{inst ()}
{inst ()}
{inst ()}
{inst ()}
{inst ()}
`
;;


wrapped_cor ();

let str_map = fn x -> `[str {x}]`
;;

let map_cor = fn () ->
  let co_void = fn () ->
    yield 1;
    yield 2;
    yield 3;
    yield 4;
    yield 5;
    yield 6;
    yield 7 
  ;;

  let inst = co_void () |> cor_map str_map;

  print `
## coroutine mapped 1 -> 2 -> 3 -> done
{inst ()}
{inst ()}
{inst ()}
{inst ()}
{inst ()}
{inst ()}
`
;;
map_cor ();

let fib_cor = fn () ->

  let fib = fn a: (Int) b: (Int) ->
    yield a;
    yield fib b (a + b)
  ;;

  let coi = fib 0 1 in
  print `
# fibonnaci coroutine
{coi ()}
{coi ()}
{coi ()}
{coi ()}
{coi ()}
{coi ()}
{coi ()}
{coi ()}
{coi ()}
{coi ()}
{coi ()}
{coi ()}
{coi ()}
{coi ()}
{coi ()}
{coi ()}
{coi ()}
{coi ()}
{coi ()}
`
;;
fib_cor ();
