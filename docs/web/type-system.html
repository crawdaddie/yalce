<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>YLC Documentation</title>
    <style>
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        line-height: 1.6;
        max-width: 900px;
        margin: 0 auto;
        padding: 20px;
        color: #333;
      }

      code {
        padding: 2px 6px;
        border-radius: 3px;
        font-family: "Monaco", "Courier New", monospace;
      }

      /* Pygments syntax highlighting styles */
      pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.codehilite .hll { background-color: #ffffcc }
.codehilite { background: #f8f8f8; }
.codehilite .c { color: #3D7B7B; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #F00 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666 } /* Operator */
.codehilite .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #9C6500 } /* Comment.Preproc */
.codehilite .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.codehilite .gr { color: #E40000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #008400 } /* Generic.Inserted */
.codehilite .go { color: #717171 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #04D } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #687822 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #00F; font-weight: bold } /* Name.Class */
.codehilite .no { color: #800 } /* Name.Constant */
.codehilite .nd { color: #A2F } /* Name.Decorator */
.codehilite .ni { color: #717171; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #00F } /* Name.Function */
.codehilite .nl { color: #767600 } /* Name.Label */
.codehilite .nn { color: #00F; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #A2F; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #BBB } /* Text.Whitespace */
.codehilite .mb { color: #666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666 } /* Literal.Number.Float */
.codehilite .mh { color: #666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666 } /* Literal.Number.Oct */
.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #A45A77 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .fm { color: #00F } /* Name.Function.Magic */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .vm { color: #19177C } /* Name.Variable.Magic */
.codehilite .il { color: #666 } /* Literal.Number.Integer.Long */

      .codehilite {
        padding: 15px;
        border-radius: 5px;
        overflow-x: auto;
        margin: 20px 0;
      }

      .codehilite pre {
        padding: 0;
        margin: 0;
      }

      .codehilite code {
        padding: 0;
      }

      h1 {
        border-bottom: 2px solid #eee;
        padding-bottom: 10px;
      }

      h2 {
        border-bottom: 1px solid #eee;
        padding-bottom: 5px;
        margin-top: 30px;
      }

      table {
        border-collapse: collapse;
        width: 100%;
        margin: 20px 0;
      }

      th, td {
        border: 1px solid #ddd;
        padding: 8px 12px;
        text-align: left;
      }

      th {
        background-color: #f4f4f4;
      }

      a {
        color: #0366d6;
        text-decoration: none;
      }

      a:hover {
        text-decoration: underline;
      }
    </style>
  </head>
  <body>
    <h1>Type System</h1>
<p>YALCE uses Hindley-Milner type inference, which means you rarely need to write type annotationsâ€”the compiler infers types automatically.</p>
<h2>Type Inference</h2>
<p>The compiler automatically determines types:</p>
<div class="codehilite"><pre><span></span><code>let x = 42;;
# x : int

let double = fn x -&gt; x * 2;;
# double : int -&gt; int

let id = fn x -&gt; x;;
# id : &#39;a -&gt; &#39;a (polymorphic)
</code></pre></div>

<h2>Polymorphism</h2>
<p>Functions can work with any type:</p>
<div class="codehilite"><pre><span></span><code># Generic identity function
let id = fn x -&gt; x;;
# id : &#39;a -&gt; &#39;a

id 5;;        # 5 : int
id &quot;hello&quot;;;  # &quot;hello&quot; : string
id [1, 2];;   # [1, 2] : [int]
</code></pre></div>

<h3>Type Variables</h3>
<p>Type variables are written with a leading apostrophe:</p>
<ul>
<li><code>'a</code>, <code>'b</code>, <code>'c</code> - Generic type variables</li>
<li><code>['a]</code> - List of any type</li>
<li><code>'a -&gt; 'b</code> - Function from any type to any type</li>
</ul>
<h2>Algebraic Data Types (ADTs)</h2>
<h3>Simple Enums</h3>
<div class="codehilite"><pre><span></span><code>type Color = Red | Green | Blue;

let is_primary = fn color -&gt;
  match color with
  | Red -&gt; true
  | Green -&gt; true
  | Blue -&gt; true
;;
</code></pre></div>

<h3>Parameterized Types</h3>
<div class="codehilite"><pre><span></span><code>type Option a = Some a | None;

let safe_head = fn list -&gt;
  match list with
  | [] -&gt; None
  | h :: _ -&gt; Some h
;;
# safe_head : [&#39;a] -&gt; Option &#39;a
</code></pre></div>

<h3>Recursive Types</h3>
<div class="codehilite"><pre><span></span><code>type Tree a =
  | Leaf
  | Node a (Tree a) (Tree a);

let singleton = fn value -&gt; Node value Leaf Leaf;;
# singleton : &#39;a -&gt; Tree &#39;a
</code></pre></div>

<h3>Multiple Type Parameters</h3>
<div class="codehilite"><pre><span></span><code>type Result err ok =
  | Ok ok
  | Error err;

let divide = fn a b -&gt;
  if b == 0 then
    Error &quot;Division by zero&quot;
  else
    Ok (a / b)
;;
# divide : int -&gt; int -&gt; Result string int
</code></pre></div>

<h2>Function Types</h2>
<h3>Simple Functions</h3>
<div class="codehilite"><pre><span></span><code>let add = fn x y -&gt; x + y;;
# add : int -&gt; int -&gt; int
</code></pre></div>

<h3>Higher-Order Functions</h3>
<div class="codehilite"><pre><span></span><code>let apply = fn f x -&gt; f x;;
# apply : (&#39;a -&gt; &#39;b) -&gt; &#39;a -&gt; &#39;b

let compose = fn f g x -&gt; f (g x);;
# compose : (&#39;b -&gt; &#39;c) -&gt; (&#39;a -&gt; &#39;b) -&gt; &#39;a -&gt; &#39;c
</code></pre></div>

<h3>Currying</h3>
<p>All multi-argument functions are curried:</p>
<div class="codehilite"><pre><span></span><code>let add = fn x y -&gt; x + y;;
# add : int -&gt; int -&gt; int
# Equivalent to: int -&gt; (int -&gt; int)

let add5 = add 5;;
# add5 : int -&gt; int
</code></pre></div>

<h2>List Types</h2>
<div class="codehilite"><pre><span></span><code>[1, 2, 3];;
# [int]

[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];;
# [string]

[[1, 2], [3, 4]];;
# [[int]]

[];;
# [&#39;a] (polymorphic empty list)
</code></pre></div>

<h2>Tuple Types</h2>
<div class="codehilite"><pre><span></span><code>(1, &quot;hello&quot;);;
# (int, string)

(1, 2, 3);;
# (int, int, int)

(true, [1, 2], &quot;test&quot;);;
# (bool, [int], string)
</code></pre></div>

<h2>Type Aliases</h2>
<p>Create names for complex types:</p>
<div class="codehilite"><pre><span></span><code>type Point = (float, float);
type UserId = int;
type Callback = int -&gt; unit;

let distance = fn (x1, y1) (x2, y2) -&gt;
  sqrt ((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1))
;;
# distance : Point -&gt; Point -&gt; float
</code></pre></div>

<h2>Type Constraints</h2>
<h3>Numeric Types</h3>
<p>YALCE distinguishes between <code>int</code> and <code>float</code>:</p>
<div class="codehilite"><pre><span></span><code>1 + 2;;        # 3 : int
1.0 + 2.0;;    # 3.0 : float

# Error: Type mismatch
1 + 2.0;;      # Cannot mix int and float
</code></pre></div>

<p>Convert between types:</p>
<div class="codehilite"><pre><span></span><code>float_of_int 42;;    # 42.0 : float
int_of_float 3.14;;  # 3 : int
</code></pre></div>

<h3>List Homogeneity</h3>
<p>Lists must contain elements of the same type:</p>
<div class="codehilite"><pre><span></span><code>[1, 2, 3];;        # OK: [int]
[&quot;a&quot;, &quot;b&quot;];;       # OK: [string]

# Error: Type mismatch
[1, &quot;hello&quot;];;     # Cannot mix types
</code></pre></div>

<h2>Pattern Matching and Types</h2>
<p>Pattern matching must be exhaustive:</p>
<div class="codehilite"><pre><span></span><code>type Option a = Some a | None;

# Warning: Non-exhaustive pattern
let unwrap = fn opt -&gt;
  match opt with
  | Some x -&gt; x
  # Missing: | None -&gt; ...
;;
</code></pre></div>

<p>The compiler ensures all cases are covered:</p>
<div class="codehilite"><pre><span></span><code># Complete pattern matching
let unwrap_or = fn default opt -&gt;
  match opt with
  | Some x -&gt; x
  | None -&gt; default
;;
</code></pre></div>

<h2>Type Inference Examples</h2>
<h3>Example 1: Map Function</h3>
<div class="codehilite"><pre><span></span><code>let map = fn f list -&gt;
  match list with
  | [] -&gt; []
  | h :: t -&gt; (f h) :: (map f t)
;;
</code></pre></div>

<p>Inferred type:</p>
<div class="codehilite"><pre><span></span><code>map : (&#39;a -&gt; &#39;b) -&gt; [&#39;a] -&gt; [&#39;b]
</code></pre></div>

<p>Breakdown:
- <code>f</code> is a function from type <code>'a</code> to type <code>'b</code>
- <code>list</code> is a list of <code>'a</code>
- Result is a list of <code>'b</code></p>
<h3>Example 2: Filter Function</h3>
<div class="codehilite"><pre><span></span><code>let filter = fn pred list -&gt;
  match list with
  | [] -&gt; []
  | h :: t -&gt;
      if pred h then
        h :: (filter pred t)
      else
        filter pred t
;;
</code></pre></div>

<p>Inferred type:</p>
<div class="codehilite"><pre><span></span><code>filter : (&#39;a -&gt; bool) -&gt; [&#39;a] -&gt; [&#39;a]
</code></pre></div>

<h3>Example 3: Fold Function</h3>
<div class="codehilite"><pre><span></span><code>let fold_left = fn f acc list -&gt;
  match list with
  | [] -&gt; acc
  | h :: t -&gt; fold_left f (f acc h) t
;;
</code></pre></div>

<p>Inferred type:</p>
<div class="codehilite"><pre><span></span><code>fold_left : (&#39;a -&gt; &#39;b -&gt; &#39;a) -&gt; &#39;a -&gt; [&#39;b] -&gt; &#39;a
</code></pre></div>

<h2>Type Errors</h2>
<h3>Common Type Errors</h3>
<p><strong>Type Mismatch</strong></p>
<div class="codehilite"><pre><span></span><code>let add = fn x y -&gt; x + y;;
add 1 &quot;hello&quot;;;
# Error: Expected int but got string
</code></pre></div>

<p><strong>Infinite Type</strong></p>
<div class="codehilite"><pre><span></span><code>let infinite = fn x -&gt; x x;;
# Error: Cannot construct infinite type: &#39;a = &#39;a -&gt; &#39;b
</code></pre></div>

<p><strong>Missing Pattern</strong></p>
<div class="codehilite"><pre><span></span><code>let head = fn list -&gt;
  match list with
  | h :: t -&gt; h
;;
# Warning: Pattern match is not exhaustive
# Missing case: []
</code></pre></div>

<h2>Advanced Type Features</h2>
<h3>Existential Types (Planned)</h3>
<div class="codehilite"><pre><span></span><code># Abstract types
type Stack a;

val empty : Stack &#39;a
val push : &#39;a -&gt; Stack &#39;a -&gt; Stack &#39;a
val pop : Stack &#39;a -&gt; Option (&#39;a, Stack &#39;a)
</code></pre></div>

<h3>Type Classes (Planned)</h3>
<div class="codehilite"><pre><span></span><code># Planned feature for ad-hoc polymorphism
class Eq a where
  eq : a -&gt; a -&gt; bool
end

instance Eq int where
  eq = fn x y -&gt; x == y
end
</code></pre></div>

<h3>GADTs (Planned)</h3>
<div class="codehilite"><pre><span></span><code># Generalized Algebraic Data Types
type Expr a where
  | IntLit : int -&gt; Expr int
  | BoolLit : bool -&gt; Expr bool
  | Add : Expr int -&gt; Expr int -&gt; Expr int
  | If : Expr bool -&gt; Expr a -&gt; Expr a -&gt; Expr a
end
</code></pre></div>

<h2>Type Annotations (Optional)</h2>
<p>You can add type annotations for documentation:</p>
<div class="codehilite"><pre><span></span><code># Function with type annotation
let add : int -&gt; int -&gt; int = fn x y -&gt; x + y;;

# Type annotation in let binding
let (x : int) = 42;;

# Explicit type parameters
let id : &#39;a -&gt; &#39;a = fn x -&gt; x;;
</code></pre></div>

<h2>Best Practices</h2>
<ol>
<li><strong>Let the Compiler Infer</strong> - Avoid unnecessary type annotations</li>
<li><strong>Use Type Aliases</strong> - Make complex types more readable</li>
<li><strong>Match Exhaustively</strong> - Handle all pattern cases</li>
<li><strong>Leverage Polymorphism</strong> - Write generic, reusable functions</li>
<li><strong>Use ADTs</strong> - Model your domain with algebraic data types</li>
</ol>
<h2>See Also</h2>
<ul>
<li><a href="ylc-ref.html">Language Reference</a> - Complete language syntax</li>
<li><a href="examples.html">Examples</a> - Type system in practice</li>
</ul>
  </body>
</html>
