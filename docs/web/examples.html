<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>YLC Documentation</title>
    <style>
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        line-height: 1.6;
        max-width: 900px;
        margin: 0 auto;
        padding: 20px;
        color: #333;
      }

      code {
        padding: 2px 6px;
        border-radius: 3px;
        font-family: "Monaco", "Courier New", monospace;
      }

      /* Pygments syntax highlighting styles */
      pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.codehilite .hll { background-color: #ffffcc }
.codehilite { background: #f8f8f8; }
.codehilite .c { color: #3D7B7B; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #F00 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666 } /* Operator */
.codehilite .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #9C6500 } /* Comment.Preproc */
.codehilite .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.codehilite .gr { color: #E40000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #008400 } /* Generic.Inserted */
.codehilite .go { color: #717171 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #04D } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #687822 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #00F; font-weight: bold } /* Name.Class */
.codehilite .no { color: #800 } /* Name.Constant */
.codehilite .nd { color: #A2F } /* Name.Decorator */
.codehilite .ni { color: #717171; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #00F } /* Name.Function */
.codehilite .nl { color: #767600 } /* Name.Label */
.codehilite .nn { color: #00F; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #A2F; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #BBB } /* Text.Whitespace */
.codehilite .mb { color: #666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666 } /* Literal.Number.Float */
.codehilite .mh { color: #666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666 } /* Literal.Number.Oct */
.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #A45A77 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .fm { color: #00F } /* Name.Function.Magic */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .vm { color: #19177C } /* Name.Variable.Magic */
.codehilite .il { color: #666 } /* Literal.Number.Integer.Long */

      .codehilite {
        padding: 15px;
        border-radius: 5px;
        overflow-x: auto;
        margin: 20px 0;
      }

      .codehilite pre {
        padding: 0;
        margin: 0;
      }

      .codehilite code {
        padding: 0;
      }

      h1 {
        border-bottom: 2px solid #eee;
        padding-bottom: 10px;
      }

      h2 {
        border-bottom: 1px solid #eee;
        padding-bottom: 5px;
        margin-top: 30px;
      }

      table {
        border-collapse: collapse;
        width: 100%;
        margin: 20px 0;
      }

      th, td {
        border: 1px solid #ddd;
        padding: 8px 12px;
        text-align: left;
      }

      th {
        background-color: #f4f4f4;
      }

      a {
        color: #0366d6;
        text-decoration: none;
      }

      a:hover {
        text-decoration: underline;
      }
    </style>
  </head>
  <body>
    <h1 id="yalce-examples">YALCE Examples</h1>
<p>Practical code examples demonstrating YALCE features.</p>
<h2 id="table-of-contents">Table of Contents</h2>
<ul>
<li><a href="#basic-examples">Basic Examples</a></li>
<li><a href="#data-structures">Data Structures</a></li>
<li><a href="#functional-programming">Functional Programming</a></li>
<li><a href="#pattern-matching">Pattern Matching</a></li>
<li><a href="#recursion">Recursion</a></li>
<li><a href="#audio-examples">Audio Examples</a></li>
</ul>
<h2 id="basic-examples">Basic Examples</h2>
<h3 id="hello-world">Hello World</h3>
<div class="codehilite"><pre><span></span><code>let message = &quot;Hello, YALCE!&quot;;;
print message;;
</code></pre></div>

<h3 id="simple-calculator">Simple Calculator</h3>
<div class="codehilite"><pre><span></span><code>let add = fn x y -&gt; x + y;;
let sub = fn x y -&gt; x - y;;
let mul = fn x y -&gt; x * y;;
let div = fn x y -&gt;
  if y == 0 then
    None
  else
    Some (x / y)
;;

print (add 5 3);;     # 8
print (mul 4 7);;     # 28
print (div 10 2);;    # Some 5
print (div 10 0);;    # None
</code></pre></div>

<h3 id="fizzbuzz">FizzBuzz</h3>
<div class="codehilite"><pre><span></span><code>let fizzbuzz = fn n -&gt;
  if n % 15 == 0 then
    &quot;FizzBuzz&quot;
  else if n % 3 == 0 then
    &quot;Fizz&quot;
  else if n % 5 == 0 then
    &quot;Buzz&quot;
  else
    string_of_int n
;;

let rec run_fizzbuzz = fn i max -&gt;
  if i &gt; max then
    ()
  else (
    print (fizzbuzz i);
    run_fizzbuzz (i + 1) max
  )
;;

run_fizzbuzz 1 100;;
</code></pre></div>

<h2 id="data-structures">Data Structures</h2>
<h3 id="working-with-lists">Working with Lists</h3>
<div class="codehilite"><pre><span></span><code># List construction
let numbers = [1, 2, 3, 4, 5];;
let more_numbers = 0 :: numbers;;

# List length
let rec length = fn list -&gt;
  match list with
  | [] -&gt; 0
  | _ :: t -&gt; 1 + length t
;;

# List sum
let rec sum = fn list -&gt;
  match list with
  | [] -&gt; 0
  | h :: t -&gt; h + sum t
;;

# List reverse
let reverse = fn list -&gt;
  let rec aux = fn acc list -&gt;
    match list with
    | [] -&gt; acc
    | h :: t -&gt; aux (h :: acc) t
  in
  aux [] list
;;

print (length numbers);;    # 5
print (sum numbers);;       # 15
print (reverse numbers);;   # [5, 4, 3, 2, 1]
</code></pre></div>

<h3 id="binary-tree">Binary Tree</h3>
<div class="codehilite"><pre><span></span><code>type Tree a =
  | Leaf
  | Node a (Tree a) (Tree a);

# Insert into BST
let rec insert = fn value tree -&gt;
  match tree with
  | Leaf -&gt; Node value Leaf Leaf
  | Node v left right -&gt;
      if value &lt; v then
        Node v (insert value left) right
      else if value &gt; v then
        Node v left (insert value right)
      else
        tree
;;

# Search in BST
let rec contains = fn value tree -&gt;
  match tree with
  | Leaf -&gt; false
  | Node v left right -&gt;
      if value == v then
        true
      else if value &lt; v then
        contains value left
      else
        contains value right
;;

# In-order traversal
let rec inorder = fn tree -&gt;
  match tree with
  | Leaf -&gt; []
  | Node v left right -&gt;
      (inorder left) ++ [v] ++ (inorder right)
;;

# Example usage
let tree = Leaf;;
let tree = insert 5 tree;;
let tree = insert 3 tree;;
let tree = insert 7 tree;;
let tree = insert 1 tree;;

print (contains 3 tree);;   # true
print (contains 4 tree);;   # false
print (inorder tree);;      # [1, 3, 5, 7]
</code></pre></div>

<h2 id="functional-programming">Functional Programming</h2>
<h3 id="map-filter-reduce">Map, Filter, Reduce</h3>
<div class="codehilite"><pre><span></span><code># Map: Transform each element
let rec map = fn f list -&gt;
  match list with
  | [] -&gt; []
  | h :: t -&gt; (f h) :: (map f t)
;;

# Filter: Keep elements matching predicate
let rec filter = fn pred list -&gt;
  match list with
  | [] -&gt; []
  | h :: t -&gt;
      if pred h then
        h :: (filter pred t)
      else
        filter pred t
;;

# Fold: Reduce list to single value
let rec fold_left = fn f acc list -&gt;
  match list with
  | [] -&gt; acc
  | h :: t -&gt; fold_left f (f acc h) t
;;

# Examples
let numbers = [1, 2, 3, 4, 5];;

let doubled = map (fn x -&gt; x * 2) numbers;;
# [2, 4, 6, 8, 10]

let evens = filter (fn x -&gt; x % 2 == 0) numbers;;
# [2, 4]

let sum = fold_left (+) 0 numbers;;
# 15

let product = fold_left ( * ) 1 numbers;;
# 120
</code></pre></div>

<h3 id="function-composition">Function Composition</h3>
<div class="codehilite"><pre><span></span><code># Compose two functions
let compose = fn f g x -&gt; f (g x);;

# Pipeline (left-to-right composition)
let pipeline = fn f g x -&gt; g (f x);;

# Example: double then add 1
let double = fn x -&gt; x * 2;;
let add1 = fn x -&gt; x + 1;;

let double_then_add1 = pipeline double add1;;
print (double_then_add1 5);;  # 11

let add1_then_double = pipeline add1 double;;
print (add1_then_double 5);;  # 12
</code></pre></div>

<h3 id="currying-and-partial-application">Currying and Partial Application</h3>
<div class="codehilite"><pre><span></span><code>let add = fn x y -&gt; x + y;;

# Partial application
let add5 = add 5;;
let add10 = add 10;;

print (add5 3);;    # 8
print (add10 7);;   # 17

# Curried multiply
let multiply = fn x -&gt; fn y -&gt; x * y;;
let double = multiply 2;;
let triple = multiply 3;;

print (double 7);;  # 14
print (triple 7);;  # 21
</code></pre></div>

<h2 id="pattern-matching">Pattern Matching</h2>
<h3 id="option-type">Option Type</h3>
<div class="codehilite"><pre><span></span><code>type Option a = Some a | None;

let safe_div = fn a b -&gt;
  if b == 0 then None
  else Some (a / b)
;;

let unwrap_or = fn default opt -&gt;
  match opt with
  | Some x -&gt; x
  | None -&gt; default
;;

let map_option = fn f opt -&gt;
  match opt with
  | Some x -&gt; Some (f x)
  | None -&gt; None
;;

let result = safe_div 10 2;;
let value = unwrap_or 0 result;;
print value;;  # 5

let doubled = map_option (fn x -&gt; x * 2) result;;
# Some 10
</code></pre></div>

<h3 id="result-type">Result Type</h3>
<div class="codehilite"><pre><span></span><code>type Result err ok =
  | Ok ok
  | Error err;

let parse_int = fn str -&gt;
  # Simplified - actual implementation would parse
  if str == &quot;123&quot; then
    Ok 123
  else
    Error &quot;Invalid number&quot;
;;

let map_result = fn f result -&gt;
  match result with
  | Ok value -&gt; Ok (f value)
  | Error err -&gt; Error err
;;

let result = parse_int &quot;123&quot;;;
let doubled = map_result (fn x -&gt; x * 2) result;;
# Ok 246
</code></pre></div>

<h3 id="list-patterns">List Patterns</h3>
<div class="codehilite"><pre><span></span><code># Get first and second elements
let first_two = fn list -&gt;
  match list with
  | [] -&gt; None
  | [_] -&gt; None
  | x :: y :: _ -&gt; Some (x, y)
;;

# Split at first element
let split_head = fn list -&gt;
  match list with
  | [] -&gt; None
  | h :: t -&gt; Some (h, t)
;;

# Pattern matching multiple elements
let describe = fn list -&gt;
  match list with
  | [] -&gt; &quot;empty&quot;
  | [_] -&gt; &quot;one element&quot;
  | [_, _] -&gt; &quot;two elements&quot;
  | _ :: _ :: _ :: _ -&gt; &quot;many elements&quot;
;;
</code></pre></div>

<h2 id="recursion">Recursion</h2>
<h3 id="factorial">Factorial</h3>
<div class="codehilite"><pre><span></span><code>let rec factorial = fn n -&gt;
  match n with
  | 0 -&gt; 1
  | 1 -&gt; 1
  | _ -&gt; n * (factorial (n - 1))
;;

print (factorial 5);;  # 120
</code></pre></div>

<h3 id="fibonacci">Fibonacci</h3>
<div class="codehilite"><pre><span></span><code># Naive recursive
let rec fib = fn n -&gt;
  match n with
  | 0 -&gt; 0
  | 1 -&gt; 1
  | _ -&gt; (fib (n - 1)) + (fib (n - 2))
;;

# Tail-recursive (more efficient)
let fib_fast = fn n -&gt;
  let rec aux = fn i a b -&gt;
    if i == n then a
    else aux (i + 1) b (a + b)
  in
  aux 0 0 1
;;

print (fib 10);;       # 55
print (fib_fast 10);;  # 55
</code></pre></div>

<h3 id="greatest-common-divisor">Greatest Common Divisor</h3>
<div class="codehilite"><pre><span></span><code>let rec gcd = fn a b -&gt;
  if b == 0 then
    a
  else
    gcd b (a % b)
;;

print (gcd 48 18);;  # 6
</code></pre></div>

<h3 id="quicksort">Quicksort</h3>
<div class="codehilite"><pre><span></span><code>let rec quicksort = fn list -&gt;
  match list with
  | [] -&gt; []
  | pivot :: rest -&gt;
      let smaller = filter (fn x -&gt; x &lt; pivot) rest in
      let greater = filter (fn x -&gt; x &gt;= pivot) rest in
      (quicksort smaller) ++ [pivot] ++ (quicksort greater)
;;

let unsorted = [3, 1, 4, 1, 5, 9, 2, 6];;
print (quicksort unsorted);;
# [1, 1, 2, 3, 4, 5, 6, 9]
</code></pre></div>

<h2 id="audio-examples">Audio Examples</h2>
<h3 id="simple-oscillator">Simple Oscillator</h3>
<div class="codehilite"><pre><span></span><code># Sine wave oscillator
let sin_osc = fn freq phase -&gt;
  sin (phase * 2.0 * 3.14159 * freq)
;;

# Generate 440Hz tone (A4)
let frequency = 440.0;;
let sample_rate = 44100.0;;

let generate_tone = fn duration -&gt;
  let num_samples = int_of_float (duration * sample_rate) in
  let rec generate = fn i acc -&gt;
    if i &gt;= num_samples then
      reverse acc
    else
      let t = (float_of_int i) / sample_rate in
      let sample = sin_osc frequency t in
      generate (i + 1) (sample :: acc)
  in
  generate 0 []
;;

let tone = generate_tone 1.0;;  # 1 second of 440Hz
</code></pre></div>

<h3 id="audio-processing-chain">Audio Processing Chain</h3>
<div class="codehilite"><pre><span></span><code># Simple effects chain
let amplify = fn gain signal -&gt;
  map (fn x -&gt; x * gain) signal
;;

let clip = fn threshold signal -&gt;
  map (fn x -&gt;
    if x &gt; threshold then threshold
    else if x &lt; -threshold then -threshold
    else x
  ) signal
;;

# Process audio
let dry_signal = generate_tone 0.5;;
let amplified = amplify 2.0 dry_signal;;
let clipped = clip 0.9 amplified;;
</code></pre></div>

<h3 id="adsr-envelope">ADSR Envelope</h3>
<div class="codehilite"><pre><span></span><code>type ADSRPhase =
  | Attack
  | Decay
  | Sustain
  | Release;

let adsr_envelope = fn attack decay sustain release -&gt;
  fn time duration -&gt;
    let a_time = attack in
    let d_time = a_time + decay in
    let s_time = duration - release in
    let r_time = duration in

    if time &lt; a_time then
      # Attack phase
      time / a_time
    else if time &lt; d_time then
      # Decay phase
      1.0 - ((time - a_time) / decay) * (1.0 - sustain)
    else if time &lt; s_time then
      # Sustain phase
      sustain
    else if time &lt; r_time then
      # Release phase
      sustain * (1.0 - (time - s_time) / release)
    else
      0.0
;;

let envelope = adsr_envelope 0.1 0.2 0.7 0.3;;
</code></pre></div>

<h2 id="see-also">See Also</h2>
<ul>
<li><a href="ylc-ref.html">Language Reference</a> - Complete syntax guide</li>
<li><a href="type-system.html">Type System</a> - Understanding types</li>
<li><a href="audio-engine.html">Audio Engine</a> - Real-time audio processing</li>
<li><a href="api-reference.html">API Reference</a> - Standard library functions</li>
</ul>
  </body>
</html>
