<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>YLC Documentation</title>
    <style>
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        line-height: 1.6;
        max-width: 900px;
        margin: 0 auto;
        padding: 20px;
        color: #333;
      }

      code {
        padding: 2px 6px;
        border-radius: 3px;
        font-family: "Monaco", "Courier New", monospace;
      }

      /* Pygments syntax highlighting styles */
      pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.codehilite .hll { background-color: #ffffcc }
.codehilite { background: #f8f8f8; }
.codehilite .c { color: #3D7B7B; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #F00 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666 } /* Operator */
.codehilite .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #9C6500 } /* Comment.Preproc */
.codehilite .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.codehilite .gr { color: #E40000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #008400 } /* Generic.Inserted */
.codehilite .go { color: #717171 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #04D } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #687822 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #00F; font-weight: bold } /* Name.Class */
.codehilite .no { color: #800 } /* Name.Constant */
.codehilite .nd { color: #A2F } /* Name.Decorator */
.codehilite .ni { color: #717171; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #00F } /* Name.Function */
.codehilite .nl { color: #767600 } /* Name.Label */
.codehilite .nn { color: #00F; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #A2F; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #BBB } /* Text.Whitespace */
.codehilite .mb { color: #666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666 } /* Literal.Number.Float */
.codehilite .mh { color: #666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666 } /* Literal.Number.Oct */
.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #A45A77 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .fm { color: #00F } /* Name.Function.Magic */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .vm { color: #19177C } /* Name.Variable.Magic */
.codehilite .il { color: #666 } /* Literal.Number.Integer.Long */

      .codehilite {
        padding: 15px;
        border-radius: 5px;
        overflow-x: auto;
        margin: 20px 0;
      }

      .codehilite pre {
        padding: 0;
        margin: 0;
      }

      .codehilite code {
        padding: 0;
      }

      h1 {
        border-bottom: 2px solid #eee;
        padding-bottom: 10px;
      }

      h2 {
        border-bottom: 1px solid #eee;
        padding-bottom: 5px;
        margin-top: 30px;
      }

      table {
        border-collapse: collapse;
        width: 100%;
        margin: 20px 0;
      }

      th, td {
        border: 1px solid #ddd;
        padding: 8px 12px;
        text-align: left;
      }

      th {
        background-color: #f4f4f4;
      }

      a {
        color: #0366d6;
        text-decoration: none;
      }

      a:hover {
        text-decoration: underline;
      }
    </style>
  </head>
  <body>
    <h1>YALCE Language Reference</h1>
<p>Complete reference for the YALCE programming language syntax and features.</p>
<h2>Table of Contents</h2>
<ul>
<li><a href="#basic-syntax">Basic Syntax</a></li>
<li><a href="#types">Types</a></li>
<li><a href="#functions">Functions</a></li>
<li><a href="#pattern-matching">Pattern Matching</a></li>
<li><a href="#data-structures">Data Structures</a></li>
<li><a href="#modules">Modules</a></li>
<li><a href="#coroutines">Coroutines</a></li>
<li><a href="#operators">Operators</a></li>
</ul>
<h2>Basic Syntax</h2>
<h3>Comments</h3>
<div class="codehilite"><pre><span></span><code># Single-line comment

(* Multi-line
   comment *)
</code></pre></div>

<h3>Let Bindings</h3>
<div class="codehilite"><pre><span></span><code>let x = 42;;
let name = &quot;YALCE&quot;;;
let pi = 3.14159;;
</code></pre></div>

<h3>Statements</h3>
<p>Statements are terminated with <code>;;</code>:</p>
<div class="codehilite"><pre><span></span><code>let x = 1;;
let y = 2;;
print (x + y);;
</code></pre></div>

<h2>Types</h2>
<p>YALCE uses Hindley-Milner type inference, so type annotations are optional.</p>
<h3>Primitive Types</h3>
<div class="codehilite"><pre><span></span><code># Integer
let count = 42;;
# count : int

# Float
let temperature = 98.6;;
# temperature : float

# String
let message = &quot;Hello&quot;;;
# message : string

# Boolean
let flag = true;;
# flag : bool

# Unit (like void)
let nothing = ();;
# nothing : unit
</code></pre></div>

<h3>Type Aliases</h3>
<div class="codehilite"><pre><span></span><code>type UserId = int;
type Point = (float, float);
</code></pre></div>

<h3>Algebraic Data Types</h3>
<div class="codehilite"><pre><span></span><code># Simple enum
type Color = Red | Green | Blue;

# Enum with data
type Option a = Some a | None;

# Complex ADT
type Tree a =
  | Leaf
  | Node a (Tree a) (Tree a);
</code></pre></div>

<h3>Polymorphic Types</h3>
<div class="codehilite"><pre><span></span><code># Generic identity function
let id = fn x -&gt; x;;
# id : &#39;a -&gt; &#39;a

# Generic list functions
let map = fn f list -&gt;
  match list with
  | [] -&gt; []
  | h :: t -&gt; (f h) :: (map f t)
;;
# map : (&#39;a -&gt; &#39;b) -&gt; [&#39;a] -&gt; [&#39;b]
</code></pre></div>

<h2>Functions</h2>
<h3>Function Definition</h3>
<div class="codehilite"><pre><span></span><code># Single parameter
let square = fn x -&gt; x * x;;

# Multiple parameters
let add = fn x y -&gt; x + y;;

# Multi-line function
let factorial = fn n -&gt;
  match n with
  | 0 -&gt; 1
  | 1 -&gt; 1
  | _ -&gt; n * (factorial (n - 1))
;;
</code></pre></div>

<h3>Anonymous Functions (Lambdas)</h3>
<div class="codehilite"><pre><span></span><code>let double = fn x -&gt; x * 2;;

# Immediately invoked
(fn x -&gt; x + 1) 5;;  # Returns 6
</code></pre></div>

<h3>Currying</h3>
<p>Functions are automatically curried:</p>
<div class="codehilite"><pre><span></span><code>let add = fn x y -&gt; x + y;;

# Partial application
let add5 = add 5;;
add5 10;;  # Returns 15

# Can also write as:
let add = fn x -&gt; fn y -&gt; x + y;;
</code></pre></div>

<h3>Recursive Functions</h3>
<p>Functions can call themselves:</p>
<div class="codehilite"><pre><span></span><code>let fib = fn n -&gt;
  match n with
  | 0 -&gt; 0
  | 1 -&gt; 1
  | _ -&gt; (fib (n - 1)) + (fib (n - 2))
;;
</code></pre></div>

<h3>Higher-Order Functions</h3>
<div class="codehilite"><pre><span></span><code># Function that takes a function
let twice = fn f x -&gt; f (f x);;

let add1 = fn x -&gt; x + 1;;
twice add1 5;;  # Returns 7

# Function that returns a function
let make_adder = fn n -&gt;
  fn x -&gt; x + n
;;

let add10 = make_adder 10;;
add10 5;;  # Returns 15
</code></pre></div>

<h2>Pattern Matching</h2>
<h3>Basic Match Expression</h3>
<div class="codehilite"><pre><span></span><code>let classify = fn n -&gt;
  match n with
  | 0 -&gt; &quot;zero&quot;
  | 1 -&gt; &quot;one&quot;
  | _ -&gt; &quot;many&quot;
;;
</code></pre></div>

<h3>Matching on ADTs</h3>
<div class="codehilite"><pre><span></span><code>type Option a = Some a | None;

let unwrap_or = fn default opt -&gt;
  match opt with
  | Some value -&gt; value
  | None -&gt; default
;;
</code></pre></div>

<h3>List Patterns</h3>
<div class="codehilite"><pre><span></span><code>let head_opt = fn list -&gt;
  match list with
  | [] -&gt; None
  | h :: t -&gt; Some h
;;

# Multiple elements
let first_two = fn list -&gt;
  match list with
  | [] -&gt; None
  | [x] -&gt; None
  | x :: y :: rest -&gt; Some (x, y)
;;
</code></pre></div>

<h3>Tuple Patterns</h3>
<div class="codehilite"><pre><span></span><code>let swap = fn tuple -&gt;
  match tuple with
  | (a, b) -&gt; (b, a)
;;
</code></pre></div>

<h3>Nested Patterns</h3>
<div class="codehilite"><pre><span></span><code>type Tree a = Leaf | Node a (Tree a) (Tree a);

let depth = fn tree -&gt;
  match tree with
  | Leaf -&gt; 0
  | Node _ Leaf Leaf -&gt; 1
  | Node _ left right -&gt;
      1 + max (depth left) (depth right)
;;
</code></pre></div>

<h2>Data Structures</h2>
<h3>Lists</h3>
<div class="codehilite"><pre><span></span><code># List literal
let numbers = [1, 2, 3, 4, 5];;

# Empty list
let empty = [];;

# Cons operator
let list = 1 :: 2 :: 3 :: [];;

# List concatenation
let combined = [1, 2] ++ [3, 4];;
</code></pre></div>

<h3>Tuples</h3>
<div class="codehilite"><pre><span></span><code># Pair
let point = (3.0, 4.0);;

# Triple
let rgb = (255, 128, 0);;

# Accessing with pattern matching
let (x, y) = point;;
</code></pre></div>

<h3>Records (Planned)</h3>
<div class="codehilite"><pre><span></span><code># Record syntax (if implemented)
type Person = { name: string, age: int };

let person = { name: &quot;Alice&quot;, age: 30 };
</code></pre></div>

<h3>Arrays</h3>
<div class="codehilite"><pre><span></span><code># Fixed-size arrays for audio processing
let buffer = Array.make 1024 0.0;;
Array.set buffer 0 1.0;;
let value = Array.get buffer 0;;
</code></pre></div>

<h2>Modules</h2>
<h3>Module Definition</h3>
<div class="codehilite"><pre><span></span><code># math_utils.ylc
let square = fn x -&gt; x * x;;
let cube = fn x -&gt; x * x * x;;

export square, cube;
</code></pre></div>

<h3>Importing Modules</h3>
<div class="codehilite"><pre><span></span><code>import MathUtils;

let result = MathUtils.square 5;;
</code></pre></div>

<h3>Test Modules</h3>
<div class="codehilite"><pre><span></span><code>let test = module () -&gt;
  let test_addition = 2 + 2 == 4;
  let test_square = square 5 == 25;
;
</code></pre></div>

<p>Run with:</p>
<div class="codehilite"><pre><span></span><code>ylc<span class="w"> </span>--test<span class="w"> </span>myfile.ylc
</code></pre></div>

<h2>Coroutines</h2>
<p>YALCE supports coroutines for generators and iteration:</p>
<h3>Generator Functions</h3>
<div class="codehilite"><pre><span></span><code>let range = gen fn start end -&gt;
  let current = ref start;
  while !current &lt; end do
    yield !current;
    current := !current + 1;
  done
;;

# Using a generator
let nums = range 0 10;
for x in nums do
  print x;
done
</code></pre></div>

<h3>Async/Await Pattern</h3>
<div class="codehilite"><pre><span></span><code>let process_items = gen fn items -&gt;
  for item in items do
    let result = process item;
    yield result;
  done
;;
</code></pre></div>

<h2>Operators</h2>
<h3>Arithmetic Operators</h3>
<div class="codehilite"><pre><span></span><code>+ # Addition
- # Subtraction
* # Multiplication
/ # Division
% # Modulo
</code></pre></div>

<h3>Comparison Operators</h3>
<div class="codehilite"><pre><span></span><code>== # Equal
!= # Not equal
&lt;  # Less than
&lt;= # Less than or equal
&gt;  # Greater than
&gt;= # Greater than or equal
</code></pre></div>

<h3>Logical Operators</h3>
<div class="codehilite"><pre><span></span><code>&amp;&amp; # Logical AND
|| # Logical OR
!  # Logical NOT
</code></pre></div>

<h3>List Operators</h3>
<div class="codehilite"><pre><span></span><code>::  # Cons (prepend to list)
++  # List concatenation
</code></pre></div>

<h3>String Operators</h3>
<div class="codehilite"><pre><span></span><code>++  # String concatenation
&quot;Hello&quot; ++ &quot; &quot; ++ &quot;World&quot;  # &quot;Hello World&quot;
</code></pre></div>

<h3>Pipeline Operator</h3>
<div class="codehilite"><pre><span></span><code>|&gt; # Forward pipe (planned)

# Instead of: f (g (h x))
# Write: x |&gt; h |&gt; g |&gt; f
</code></pre></div>

<h2>Control Flow</h2>
<h3>If Expressions</h3>
<div class="codehilite"><pre><span></span><code>let abs = fn x -&gt;
  if x &lt; 0 then
    -x
  else
    x
;;
</code></pre></div>

<h3>While Loops</h3>
<div class="codehilite"><pre><span></span><code>let count_down = fn n -&gt;
  let i = ref n;
  while !i &gt; 0 do
    print !i;
    i := !i - 1;
  done
;;
</code></pre></div>

<h3>For Loops</h3>
<div class="codehilite"><pre><span></span><code>for i in [1, 2, 3, 4, 5] do
  print i;
done
</code></pre></div>

<h2>References (Mutable State)</h2>
<div class="codehilite"><pre><span></span><code># Create a reference
let counter = ref 0;;

# Read a reference
let value = !counter;;

# Update a reference
counter := !counter + 1;;
</code></pre></div>

<h2>Built-in Functions</h2>
<h3>I/O Functions</h3>
<div class="codehilite"><pre><span></span><code>print value          # Print to stdout
print_string str     # Print string
print_int n          # Print integer
print_float f        # Print float
</code></pre></div>

<h3>List Functions</h3>
<div class="codehilite"><pre><span></span><code>List.length [1, 2, 3]        # 3
List.map (fn x -&gt; x * 2) [1, 2, 3]  # [2, 4, 6]
List.filter (fn x -&gt; x &gt; 0) [-1, 0, 1]  # [1]
List.fold_left (+) 0 [1, 2, 3]  # 6
</code></pre></div>

<h3>Math Functions</h3>
<div class="codehilite"><pre><span></span><code>sin 1.0
cos 1.0
sqrt 2.0
abs (-5)
max 3 7
min 3 7
</code></pre></div>

<h3>String Functions</h3>
<div class="codehilite"><pre><span></span><code>String.length &quot;hello&quot;          # 5
String.concat &quot; &quot; [&quot;hello&quot;, &quot;world&quot;]  # &quot;hello world&quot;
String.sub &quot;hello&quot; 0 3        # &quot;hel&quot;
</code></pre></div>

<h2>FFI (Foreign Function Interface)</h2>
<p>Call C functions from YALCE:</p>
<div class="codehilite"><pre><span></span><code>external malloc : int -&gt; ptr = &quot;malloc&quot;;
external free : ptr -&gt; unit = &quot;free&quot;;

# Audio processing
external sin_osc : float -&gt; float = &quot;sin_osc&quot;;
</code></pre></div>

<h2>Syntax Cheat Sheet</h2>
<div class="codehilite"><pre><span></span><code># Variables
let x = 42;;

# Functions
let f = fn x -&gt; x + 1;;

# Pattern matching
match x with
| 0 -&gt; &quot;zero&quot;
| _ -&gt; &quot;other&quot;
;;

# Lists
let list = [1, 2, 3];;
let cons = 0 :: list;;

# Tuples
let pair = (1, 2);;

# Types
type Option a = Some a | None;

# Modules
import MyModule;
export f, g;

# Coroutines
let gen = gen fn () -&gt;
  yield 1;
  yield 2;
;;
</code></pre></div>

<h2>See Also</h2>
<ul>
<li><a href="type-system.html">Type System</a> - Deep dive into Hindley-Milner inference</li>
<li><a href="examples.html">Examples</a> - More code examples</li>
<li><a href="api-reference.html">API Reference</a> - Standard library documentation</li>
</ul>
  </body>
</html>
