open engine/bindings/Synth;
open engine/bindings/Sched;
open lib/Math;

let (@) = array_at;

let array_choose = fn arr ->
  let idx = rand_int (array_size arr);
  arr @ idx 
;;

let ampenv = 
[|
  0.000000, 0.000000, 2.400000,
  1.000000, 0.257705, 2.700000,
  0.535556, 0.242295, -1.000000,
  0.000000
|]
|> array_to_buf;

let driveenv = 
[|
  0.000000, 0.000000, 2.400000,
  0.733333, 0.106893, -1.100000,
  0.413333, 0.193107, -1.000000,
  0.000000
|]
|> array_to_buf;

let fx_chain = (fn () ->
  let input = multi_chan_inlet 2 0.;
  input
  |> vital_rev_node
    0.99
    1.
    0.5
    0.62184876
    0.0
    1.0
    0.8333333
    0.6
    0.789916
    0.0
    0.0
    1.
) |> play_tpl;

let dist_sin = fn f: (Synth) hp: (Synth) dur: (Synth) trig: (Synth) ->
  let i = ((white_noise_node ()) * (0.5 * sin_node .01));
  i + (dyn_comb_node (1. / (f)) 0.2 0.99 i)
  |> (*) (sin_node (f * 0.25))
  |> (+) (sin_node f)
  |> dyn_temper_node
    1.
    -0.2
    1000.
    2.0
    3.0
    .0
    (10. * (buf_env_node dur (buf_ref driveenv) trig)) 

;;
let synth = (fn () -> 
  let f = inlet 40. |> lag_node 0.01;
  let trig = inlet 0.;
  let ff = lfnoise_node 1. 101. 1000.;
  let dur = 0.3 * inlet 1.;
  let dist = 
  (dist_sin f ff dur trig)
  + (dist_sin (f * 1.02) ff dur trig)
  |> biquad_hp_node ff 4.
  ;
  (sin_node f |> tanh_node 2.) + dist
  # |> (*) (buf_env_node (0.3 * inlet 1.) (buf_ref ampenv) trig)
) |> play_tpl
;

let rout = fn () ->
  let fo = get_tl_tick () in (
    set_input_trig_offset synth 1 fo;
    set_input_trig_offset synth 2 0.25
    # set_input_scalar_offset synth 0 fo (midi_to_freq @@ 40 + (array_choose [|0,12,24,7,8,-5|]))
    )
  ;
  yield 0.25;
  yield rout () 
;;


# synth |> pipe_into fx_chain 0;

defer_quant 1. (fn t -> rout () |> play_routine t schedule_event);
#

(
  import gui/bindings/Gui;

  let sig = node_out (driveenv);
  Gui.create_envelope_edit_view
    (sig_size sig)
    (sig_raw sig)

);
