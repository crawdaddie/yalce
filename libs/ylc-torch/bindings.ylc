# libtch/torch_api.h
type tensor = Ptr;
type optimizer = Ptr;
type scalar = Ptr;
type module = Ptr;
type ivalue = Ptr;

let get_and_reset_last_err = extern fn () -> Ptr;
let at_manual_seed = extern fn int64_t -> ();
let at_new_tensor = extern fn () -> Tensor;
let at_tensor_of_blob = extern fn Ptr -> int64_t * -> size_t -> int64_t * -> size_t -> Int -> Int -> Tensor;
let at_tensor_of_data = extern fn Ptr -> int64_t * -> size_t -> size_t -> Int -> Tensor;
let at_copy_data = extern fn Tensor -> Ptr -> size_t -> size_t -> ();
let at_shallow_clone = extern fn Tensor -> Tensor;
let at_data_ptr = extern fn Tensor -> Ptr;
let at_defined = extern fn Tensor -> Int;
let at_is_mkldnn = extern fn Tensor -> Int;
let at_is_sparse = extern fn Tensor -> Int;
let at_is_contiguous = extern fn Tensor -> Int;
let at_device = extern fn Tensor -> Int;
let at_dim = extern fn Tensor -> size_t;
let at_shape = extern fn Tensor -> int64_t * -> ();
let at_stride = extern fn Tensor -> int64_t * -> ();
let at_scalar_type = extern fn Tensor -> Int;
let at__amp_non_finite_check_and_unscale = extern fn Tensor -> Tensor -> Tensor -> ();
let at_autocast_clear_cache = extern fn () -> ();
let at_autocast_decrement_nesting = extern fn () -> Int;
let at_autocast_increment_nesting = extern fn () -> Int;
let at_autocast_is_enabled = extern fn () -> Int;
let at_autocast_set_enabled = extern fn Int -> Int;
let at_backward = extern fn Tensor -> Int -> Int -> ();
let at_requires_grad = extern fn Tensor -> Int;
let at_grad_set_enabled = extern fn Int -> Int;
let at_get = extern fn Tensor -> Int -> Tensor;
let at_fill_double = extern fn Tensor -> Double -> ();
let at_fill_int64 = extern fn Tensor -> int64_t -> ();
let at_double_value_at_indexes = extern fn Tensor -> int64_t * -> Int -> Double;
let at_int64_value_at_indexes = extern fn Tensor -> int64_t * -> Int -> int64_t;
let at_set_double_value_at_indexes = extern fn Tensor -> int * -> Int -> Double -> ();
let at_set_int64_value_at_indexes = extern fn Tensor -> int * -> Int -> int64_t -> ();
let at_copy_ = extern fn Tensor -> Tensor -> ();
let at_print = extern fn Tensor -> ();
let at_to_string = extern fn Tensor -> Int -> Ptr;
let at_save = extern fn Tensor -> Ptr -> ();
let at_save_to_stream = extern fn Tensor -> Ptr -> ();
let at_load = extern fn Ptr -> Tensor;
let at_load_from_stream = extern fn Ptr -> Tensor;
let at_load_image = extern fn Ptr -> Tensor;
let at_load_image_from_memory = extern fn unsigned char * -> size_t -> Tensor;
let at_save_image = extern fn Tensor -> Ptr -> Int;
let at_resize_image = extern fn Tensor -> Int -> Int -> Tensor;
let at_save_multi = extern fn tensor * -> char ** -> Int -> Ptr -> ();
let at_save_multi_to_stream = extern fn tensor * -> char ** -> Int -> Ptr -> ();
let at_load_multi = extern fn tensor * -> char ** -> Int -> Ptr -> ();
let at_load_multi_ = extern fn tensor * -> char ** -> Int -> Ptr -> ();
let at_loadz_callback = extern fn Ptr -> Ptr -> void (*)(void *, char *, tensor) -> ();
let at_loadz_callback_with_device = extern fn Ptr -> Ptr -> void (*)(void *, char *, tensor) -> Int -> ();
let at_load_callback = extern fn Ptr -> Ptr -> void (*)(void *, char *, tensor) -> ();
let at_load_callback_with_device = extern fn Ptr -> Ptr -> void (*)(void *, char *, tensor) -> Int -> ();
let at_load_from_stream_callback = extern fn Ptr -> Ptr -> void (*)(void *, char *, tensor) -> Int -> Int -> ();
let at_get_num_interop_threads = extern fn () -> Int;
let at_get_num_threads = extern fn () -> Int;
let at_set_num_interop_threads = extern fn Int -> ();
let at_set_num_threads = extern fn Int -> ();
let at_set_qengine = extern fn Int -> ();
let at_free = extern fn Tensor -> ();
let at_run_backward = extern fn tensor * -> Int -> tensor * -> Int -> tensor * -> Int -> Int -> ();
let ato_adam = extern fn Double -> Double -> Double -> Double -> Double -> Int -> optimizer;
let ato_adamw = extern fn Double -> Double -> Double -> Double -> Double -> Int -> optimizer;
let ato_rms_prop = extern fn Double -> Double -> Double -> Double -> Double -> Int -> optimizer;
let ato_sgd = extern fn Double -> Double -> Double -> Double -> Int -> optimizer;
let ato_add_parameters = extern fn optimizer -> Tensor -> size_t -> ();
let ato_set_learning_rate = extern fn optimizer -> Double -> ();
let ato_set_momentum = extern fn optimizer -> Double -> ();
let ato_set_learning_rate_group = extern fn optimizer -> size_t -> Double -> ();
let ato_set_momentum_group = extern fn optimizer -> size_t -> Double -> ();
let ato_set_weight_decay = extern fn optimizer -> Double -> ();
let ato_set_weight_decay_group = extern fn optimizer -> size_t -> Double -> ();
let ato_zero_grad = extern fn optimizer -> ();
let ato_step = extern fn optimizer -> ();
let ato_free = extern fn optimizer -> ();
let ats_int = extern fn int64_t -> scalar;
let ats_float = extern fn Double -> scalar;
let ats_to_int = extern fn scalar -> int64_t;
let ats_to_float = extern fn scalar -> Double;
let ats_to_string = extern fn scalar -> Ptr;
let ats_free = extern fn scalar -> ();
let at_context_has_openmp = extern fn () -> Int;
let at_context_has_mkl = extern fn () -> Int;
let at_context_has_lapack = extern fn () -> Int;
let at_context_has_mkldnn = extern fn () -> Int;
let at_context_has_magma = extern fn () -> Int;
let at_context_has_cuda = extern fn () -> Int;
let at_context_has_cudart = extern fn () -> Int;
let at_context_has_cudnn = extern fn () -> Int;
let at_context_version_cudnn = extern fn () -> int64_t;
let at_context_version_cudart = extern fn () -> int64_t;
let at_context_has_cusolver = extern fn () -> Int;
let at_context_has_hip = extern fn () -> Int;
let at_context_has_ipu = extern fn () -> Int;
let at_context_has_xla = extern fn () -> Int;
let at_context_has_lazy = extern fn () -> Int;
let at_context_has_mps = extern fn () -> Int;
# Returns the number of CUDA devices available.
let atc_cuda_device_count = extern fn () -> Int;
# Returns true if at least one CUDA device is available.
let atc_cuda_is_available = extern fn () -> Int;
# Returns true if CUDA is available, and CuDNN is available.
let atc_cudnn_is_available = extern fn () -> Int;
# Sets the seed for the current GPU.
let atc_manual_seed = extern fn Uint64 -> ();
# Sets the seed for all available GPUs.
let atc_manual_seed_all = extern fn Uint64 -> ();
# Waits for all kernels in all streams on a CUDA device to complete.
let atc_synchronize = extern fn int64_t -> ();
let atc_user_enabled_cudnn = extern fn () -> Int;
let atc_set_user_enabled_cudnn = extern fn Int -> ();
let atc_set_benchmark_cudnn = extern fn Int -> ();
let atm_load = extern fn Ptr -> module;
let atm_load_on_device = extern fn Ptr -> Int -> module;
let atm_load_str = extern fn Ptr -> size_t -> module;
let atm_load_str_on_device = extern fn Ptr -> size_t -> Int -> module;
let atm_forward = extern fn module -> tensor * -> Int -> Tensor;
let atm_forward_ = extern fn module -> ivalue * -> Int -> ivalue;
let atm_method = extern fn module -> Ptr -> tensor * -> Int -> Tensor;
let atm_method_ = extern fn module -> Ptr -> ivalue * -> Int -> ivalue;
let atm_create_class_ = extern fn module -> Ptr -> ivalue * -> Int -> ivalue;
let atm_eval = extern fn module -> ();
let atm_train = extern fn module -> ();
let atm_free = extern fn module -> ();
let atm_to = extern fn module -> Int -> Int -> Int -> ();
let atm_save = extern fn module -> Ptr -> ();
let atm_get_profiling_mode = extern fn () -> Int;
let atm_set_profiling_mode = extern fn Int -> ();
let atm_fuser_cuda_set_enabled = extern fn () -> ();
let atm_fuser_cuda_is_enabled = extern fn () -> Int;
let atm_named_parameters = extern fn module -> Ptr -> void (*)(void *, char *, tensor) -> ();
let atm_create_for_tracing = extern fn Ptr -> tensor * -> Int -> module;
let atm_end_tracing = extern fn module -> Ptr -> tensor * -> Int -> ();
let ati_none = extern fn () -> ivalue;
let ati_tensor = extern fn Tensor -> ivalue;
let ati_int = extern fn int64_t -> ivalue;
let ati_double = extern fn Double -> ivalue;
let ati_bool = extern fn Int -> ivalue;
let ati_string = extern fn Ptr -> ivalue;
let ati_tuple = extern fn ivalue * -> Int -> ivalue;
let ati_generic_list = extern fn ivalue * -> Int -> ivalue;
let ati_generic_dict = extern fn ivalue * -> Int -> ivalue;
let ati_int_list = extern fn int64_t * -> Int -> ivalue;
let ati_double_list = extern fn Ptr -> Int -> ivalue;
let ati_bool_list = extern fn Ptr -> Int -> ivalue;
let ati_string_list = extern fn char ** -> Int -> ivalue;
let ati_tensor_list = extern fn tensor * -> Int -> ivalue;
let ati_device = extern fn Int -> ivalue;
let ati_to_tensor = extern fn ivalue -> Tensor;
let ati_to_int = extern fn ivalue -> int64_t;
let ati_to_double = extern fn ivalue -> Double;
let ati_to_string = extern fn ivalue -> Ptr;
let ati_to_bool = extern fn ivalue -> Int;
let ati_length = extern fn ivalue -> Int;
let ati_tuple_length = extern fn ivalue -> Int;
let ati_to_tuple = extern fn ivalue -> ivalue * -> Int -> ();
let ati_to_generic_list = extern fn ivalue -> ivalue * -> Int -> ();
let ati_to_generic_dict = extern fn ivalue -> ivalue * -> Int -> ();
let ati_to_int_list = extern fn ivalue -> int64_t * -> Int -> ();
let ati_to_double_list = extern fn ivalue -> Ptr -> Int -> ();
let ati_to_bool_list = extern fn ivalue -> Ptr -> Int -> ();
let ati_to_tensor_list = extern fn ivalue -> tensor * -> Int -> ();
let atm_set_tensor_expr_fuser_enabled = extern fn Int -> ();
let atm_get_tensor_expr_fuser_enabled = extern fn () -> Int;
let ati_tag = extern fn ivalue -> Int;
let ati_object_method_ = extern fn ivalue -> Ptr -> ivalue * -> Int -> ivalue;
let ati_object_getattr_ = extern fn ivalue -> Ptr -> ivalue;
let ati_clone = extern fn ivalue -> ivalue;
let ati_free = extern fn ivalue -> ();
# Enables or disables the graph executor optimizer for the current thread.
let at_set_graph_executor_optimize = extern fn () -> ();
let tch_write_stream_destructor = extern fn Ptr -> Int;
let tch_write_stream_write = extern fn Ptr -> const uint8_t * -> size_t -> size_t * -> Int;
let tch_read_stream_destructor = extern fn Ptr -> Int;
let tch_read_stream_stream_position = extern fn Ptr -> uint64_t * -> Int;
let tch_read_stream_seek_start = extern fn Ptr -> Uint64 -> uint64_t * -> Int;
let tch_read_stream_seek_end = extern fn Ptr -> int64_t -> uint64_t * -> Int;
let tch_read_stream_read = extern fn Ptr -> uint8_t * -> size_t -> size_t * -> Int;

