# libtch/torch_api.h
type Tensor = Ptr;
type Optimizer = Ptr;
type Scalar = Ptr;
type TorchModule = Ptr;
type IValue = Ptr;
let get_and_reset_last_err = extern fn () -> Ptr;
let at_manual_seed = extern fn Int -> ();
let at_new_tensor = extern fn () -> Tensor;
let at_tensor_of_blob = extern fn Ptr -> Ptr -> Int -> Ptr -> Int -> Int -> Int -> Tensor;
let at_tensor_of_data = extern fn Ptr -> Ptr -> Int -> Int -> Int -> Tensor;
let at_copy_data = extern fn Tensor -> Ptr -> Int -> Int -> ();
let at_shallow_clone = extern fn Tensor -> Tensor;
let at_data_ptr = extern fn Tensor -> Ptr;
let at_defined = extern fn Tensor -> Int;
let at_is_mkldnn = extern fn Tensor -> Int;
let at_is_sparse = extern fn Tensor -> Int;
let at_is_contiguous = extern fn Tensor -> Int;
let at_device = extern fn Tensor -> Int;
let at_dim = extern fn Tensor -> Int;
let at_shape = extern fn Tensor -> Ptr -> ();
let at_stride = extern fn Tensor -> Ptr -> ();
let at_scalar_type = extern fn Tensor -> Int;
let at__amp_non_finite_check_and_unscale = extern fn Tensor -> Tensor -> Tensor -> ();
let at_autocast_clear_cache = extern fn () -> ();
let at_autocast_decrement_nesting = extern fn () -> Int;
let at_autocast_increment_nesting = extern fn () -> Int;
let at_autocast_is_enabled = extern fn () -> Int;
let at_autocast_set_enabled = extern fn Int -> Int;
let at_backward = extern fn Tensor -> Int -> Int -> ();
let at_requires_grad = extern fn Tensor -> Int;
let at_grad_set_enabled = extern fn Int -> Int;
let at_get = extern fn Tensor -> Int -> Tensor;
let at_fill_double = extern fn Tensor -> Double -> ();
let at_fill_int64 = extern fn Tensor -> Int -> ();
let at_double_value_at_indexes = extern fn Tensor -> Ptr -> Int -> Double;
let at_int64_value_at_indexes = extern fn Tensor -> Ptr -> Int -> Int;
let at_set_double_value_at_indexes = extern fn Tensor -> Ptr -> Int -> Double -> ();
let at_set_int64_value_at_indexes = extern fn Tensor -> Ptr -> Int -> Int -> ();
let at_copy_ = extern fn Tensor -> Tensor -> ();
let at_print = extern fn Tensor -> ();
let at_to_string = extern fn Tensor -> Int -> Ptr;
let at_save = extern fn Tensor -> Ptr -> ();
let at_save_to_stream = extern fn Tensor -> Ptr -> ();
let at_load = extern fn Ptr -> Tensor;
let at_load_from_stream = extern fn Ptr -> Tensor;
let at_load_image = extern fn Ptr -> Tensor;
let at_load_image_from_memory = extern fn Ptr -> Int -> Tensor;
let at_save_image = extern fn Tensor -> Ptr -> Int;
let at_resize_image = extern fn Tensor -> Int -> Int -> Tensor;
let at_save_multi = extern fn Ptr -> Ptr -> Int -> Ptr -> ();
let at_save_multi_to_stream = extern fn Ptr -> Ptr -> Int -> Ptr -> ();
let at_load_multi = extern fn Ptr -> Ptr -> Int -> Ptr -> ();
let at_load_multi_ = extern fn Ptr -> Ptr -> Int -> Ptr -> ();
type TorchLoadCb = Ptr -> Ptr -> Tensor -> ();
let at_loadz_callback = extern fn Ptr -> Ptr -> TorchLoadCb -> ();
let at_loadz_callback_with_device = extern fn Ptr -> Ptr -> TorchLoadCb -> Int -> ();
let at_load_callback = extern fn Ptr -> Ptr -> TorchLoadCb -> ();
let at_load_callback_with_device = extern fn Ptr -> Ptr -> TorchLoadCb -> Int -> ();
let at_load_from_stream_callback = extern fn Ptr -> Ptr -> TorchLoadCb -> Int -> Int -> ();
let at_get_num_interop_threads = extern fn () -> Int;
let at_get_num_threads = extern fn () -> Int;
let at_set_num_interop_threads = extern fn Int -> ();
let at_set_num_threads = extern fn Int -> ();
let at_set_qengine = extern fn Int -> ();
let at_free = extern fn Tensor -> ();
let at_run_backward = extern fn Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> ();
let ato_adam = extern fn Double -> Double -> Double -> Double -> Double -> Int -> Optimizer;
let ato_adamw = extern fn Double -> Double -> Double -> Double -> Double -> Int -> Optimizer;
let ato_rms_prop = extern fn Double -> Double -> Double -> Double -> Double -> Int -> Optimizer;
let ato_sgd = extern fn Double -> Double -> Double -> Double -> Int -> Optimizer;
let ato_add_parameters = extern fn Optimizer -> Tensor -> Int -> ();
let ato_set_learning_rate = extern fn Optimizer -> Double -> ();
let ato_set_momentum = extern fn Optimizer -> Double -> ();
let ato_set_learning_rate_group = extern fn Optimizer -> Int -> Double -> ();
let ato_set_momentum_group = extern fn Optimizer -> Int -> Double -> ();
let ato_set_weight_decay = extern fn Optimizer -> Double -> ();
let ato_set_weight_decay_group = extern fn Optimizer -> Int -> Double -> ();
let ato_zero_grad = extern fn Optimizer -> ();
let ato_step = extern fn Optimizer -> ();
let ato_free = extern fn Optimizer -> ();
let ats_int = extern fn Int -> Scalar;
let ats_float = extern fn Double -> Scalar;
let ats_to_int = extern fn Scalar -> Int;
let ats_to_float = extern fn Scalar -> Double;
let ats_to_string = extern fn Scalar -> Ptr;
let ats_free = extern fn Scalar -> ();
let at_context_has_openmp = extern fn () -> Int;
let at_context_has_mkl = extern fn () -> Int;
let at_context_has_lapack = extern fn () -> Int;
let at_context_has_mkldnn = extern fn () -> Int;
let at_context_has_magma = extern fn () -> Int;
let at_context_has_cuda = extern fn () -> Int;
let at_context_has_cudart = extern fn () -> Int;
let at_context_has_cudnn = extern fn () -> Int;
let at_context_version_cudnn = extern fn () -> Int;
let at_context_version_cudart = extern fn () -> Int;
let at_context_has_cusolver = extern fn () -> Int;
let at_context_has_hip = extern fn () -> Int;
let at_context_has_ipu = extern fn () -> Int;
let at_context_has_xla = extern fn () -> Int;
let at_context_has_lazy = extern fn () -> Int;
let at_context_has_mps = extern fn () -> Int;
# Returns the number of CUDA devices available.
let atc_cuda_device_count = extern fn () -> Int;
# Returns true if at least one CUDA device is available.
let atc_cuda_is_available = extern fn () -> Int;
# Returns true if CUDA is available, and CuDNN is available.
let atc_cudnn_is_available = extern fn () -> Int;
# Sets the seed for the current GPU.
let atc_manual_seed = extern fn Uint64 -> ();
# Sets the seed for all available GPUs.
let atc_manual_seed_all = extern fn Uint64 -> ();
# Waits for all kernels in all streams on a CUDA device to complete.
let atc_synchronize = extern fn Int -> ();
let atc_user_enabled_cudnn = extern fn () -> Int;
let atc_set_user_enabled_cudnn = extern fn Int -> ();
let atc_set_benchmark_cudnn = extern fn Int -> ();
let atm_load = extern fn Ptr -> TorchModule;
let atm_load_on_device = extern fn Ptr -> Int -> TorchModule;
let atm_load_str = extern fn Ptr -> Int -> TorchModule;
let atm_load_str_on_device = extern fn Ptr -> Int -> Int -> TorchModule;
let atm_forward = extern fn TorchModule -> Ptr -> Int -> Tensor;
let atm_forward_ = extern fn TorchModule -> Ptr -> Int -> IValue;
let atm_method = extern fn TorchModule -> Ptr -> Ptr -> Int -> Tensor;
let atm_method_ = extern fn TorchModule -> Ptr -> Ptr -> Int -> IValue;
let atm_create_class_ = extern fn TorchModule -> Ptr -> Ptr -> Int -> IValue;
let atm_eval = extern fn TorchModule -> ();
let atm_train = extern fn TorchModule -> ();
let atm_free = extern fn TorchModule -> ();
let atm_to = extern fn TorchModule -> Int -> Int -> Int -> ();
let atm_save = extern fn TorchModule -> Ptr -> ();
let atm_get_profiling_mode = extern fn () -> Int;
let atm_set_profiling_mode = extern fn Int -> ();
let atm_fuser_cuda_set_enabled = extern fn () -> ();
let atm_fuser_cuda_is_enabled = extern fn () -> Int;
type TorchNamedParametersCb = Ptr -> Ptr -> Tensor -> ();
let atm_named_parameters = extern fn TorchModule -> Ptr -> TorchNamedParametersCb -> ();
let atm_create_for_tracing = extern fn Ptr -> Ptr -> Int -> TorchModule;
let atm_end_tracing = extern fn TorchModule -> Ptr -> Ptr -> Int -> ();
let ati_none = extern fn () -> IValue;
let ati_tensor = extern fn Tensor -> IValue;
let ati_int = extern fn Int -> IValue;
let ati_double = extern fn Double -> IValue;
let ati_bool = extern fn Int -> IValue;
let ati_string = extern fn Ptr -> IValue;
let ati_tuple = extern fn Ptr -> Int -> IValue;
let ati_generic_list = extern fn Ptr -> Int -> IValue;
let ati_generic_dict = extern fn Ptr -> Int -> IValue;
let ati_int_list = extern fn Ptr -> Int -> IValue;
let ati_double_list = extern fn Ptr -> Int -> IValue;
let ati_bool_list = extern fn Ptr -> Int -> IValue;
let ati_string_list = extern fn Ptr -> Int -> IValue;
let ati_tensor_list = extern fn Ptr -> Int -> IValue;
let ati_device = extern fn Int -> IValue;
let ati_to_tensor = extern fn IValue -> Tensor;
let ati_to_int = extern fn IValue -> Int;
let ati_to_double = extern fn IValue -> Double;
let ati_to_string = extern fn IValue -> Ptr;
let ati_to_bool = extern fn IValue -> Int;
let ati_length = extern fn IValue -> Int;
let ati_tuple_length = extern fn IValue -> Int;
let ati_to_tuple = extern fn IValue -> Ptr -> Int -> ();
let ati_to_generic_list = extern fn IValue -> Ptr -> Int -> ();
let ati_to_generic_dict = extern fn IValue -> Ptr -> Int -> ();
let ati_to_int_list = extern fn IValue -> Ptr -> Int -> ();
let ati_to_double_list = extern fn IValue -> Ptr -> Int -> ();
let ati_to_bool_list = extern fn IValue -> Ptr -> Int -> ();
let ati_to_tensor_list = extern fn IValue -> Ptr -> Int -> ();
let atm_set_tensor_expr_fuser_enabled = extern fn Int -> ();
let atm_get_tensor_expr_fuser_enabled = extern fn () -> Int;
let ati_tag = extern fn IValue -> Int;
let ati_object_method_ = extern fn IValue -> Ptr -> Ptr -> Int -> IValue;
let ati_object_getattr_ = extern fn IValue -> Ptr -> IValue;
let ati_clone = extern fn IValue -> IValue;
let ati_free = extern fn IValue -> ();
# Enables or disables the graph executor optimizer for the current thread.
let at_set_graph_executor_optimize = extern fn () -> ();
let tch_write_stream_destructor = extern fn Ptr -> Int;
let tch_write_stream_write = extern fn Ptr -> Ptr -> Int -> Ptr -> Int;
let tch_read_stream_destructor = extern fn Ptr -> Int;
let tch_read_stream_stream_position = extern fn Ptr -> Ptr -> Int;
let tch_read_stream_seek_start = extern fn Ptr -> Uint64 -> Ptr -> Int;
let tch_read_stream_seek_end = extern fn Ptr -> Int -> Ptr -> Int;
let tch_read_stream_read = extern fn Ptr -> Ptr -> Int -> Ptr -> Int;

# libtch/torch_api_generated.hpp
let atg___and__ = extern fn Ptr -> Tensor -> Scalar -> ();
let atg___and__tensor_ = extern fn Ptr -> Tensor -> Tensor -> ();
let atg___iand__ = extern fn Ptr -> Tensor -> Scalar -> ();
let atg___iand__tensor_ = extern fn Ptr -> Tensor -> Tensor -> ();
let atg___ilshift__ = extern fn Ptr -> Tensor -> Scalar -> ();
let atg___ilshift__tensor_ = extern fn Ptr -> Tensor -> Tensor -> ();
let atg___ior__ = extern fn Ptr -> Tensor -> Scalar -> ();
let atg___ior__tensor_ = extern fn Ptr -> Tensor -> Tensor -> ();
let atg___irshift__ = extern fn Ptr -> Tensor -> Scalar -> ();
let atg___irshift__tensor_ = extern fn Ptr -> Tensor -> Tensor -> ();
let atg___ixor__ = extern fn Ptr -> Tensor -> Scalar -> ();
let atg___ixor__tensor_ = extern fn Ptr -> Tensor -> Tensor -> ();
let atg___lshift__ = extern fn Ptr -> Tensor -> Scalar -> ();
let atg___lshift__scalar_out_ = extern fn Ptr -> Tensor -> Tensor -> Scalar -> ();
let atg___lshift__tensor_ = extern fn Ptr -> Tensor -> Tensor -> ();
let atg___lshift__tensor_out_ = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg___or__ = extern fn Ptr -> Tensor -> Scalar -> ();
let atg___or__tensor_ = extern fn Ptr -> Tensor -> Tensor -> ();
let atg___rshift__ = extern fn Ptr -> Tensor -> Scalar -> ();
let atg___rshift__scalar_out_ = extern fn Ptr -> Tensor -> Tensor -> Scalar -> ();
let atg___rshift__tensor_ = extern fn Ptr -> Tensor -> Tensor -> ();
let atg___rshift__tensor_out_ = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg___xor__ = extern fn Ptr -> Tensor -> Scalar -> ();
let atg___xor__tensor_ = extern fn Ptr -> Tensor -> Tensor -> ();
let atg__adaptive_avg_pool2d = extern fn Ptr -> Tensor -> Ptr -> Int -> ();
let atg__adaptive_avg_pool2d_backward = extern fn Ptr -> Tensor -> Tensor -> ();
let atg__adaptive_avg_pool2d_backward_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg__adaptive_avg_pool2d_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg__adaptive_avg_pool3d = extern fn Ptr -> Tensor -> Ptr -> Int -> ();
let atg__adaptive_avg_pool3d_backward = extern fn Ptr -> Tensor -> Tensor -> ();
let atg__adaptive_avg_pool3d_backward_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg__adaptive_avg_pool3d_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg__add_batch_dim = extern fn Ptr -> Tensor -> Int -> Int -> ();
let atg__add_relu = extern fn Ptr -> Tensor -> Tensor -> ();
let atg__add_relu_ = extern fn Ptr -> Tensor -> Tensor -> ();
let atg__add_relu_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg__add_relu_scalar = extern fn Ptr -> Tensor -> Scalar -> ();
let atg__add_relu_scalar_ = extern fn Ptr -> Tensor -> Scalar -> ();
let atg__add_relu_scalar_out = extern fn Ptr -> Tensor -> Tensor -> Scalar -> ();
let atg__addmm_activation = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg__addmm_activation_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg__aminmax = extern fn Ptr -> Tensor -> ();
let atg__aminmax_dim = extern fn Ptr -> Tensor -> Int -> Int -> ();
let atg__aminmax_dim_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> Int -> ();
let atg__aminmax_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg__amp_update_scale = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Double -> Double -> Int -> ();
let atg__amp_update_scale_ = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Double -> Double -> Int -> ();
let atg__amp_update_scale_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Double -> Double -> Int -> ();
let atg__assert_scalar = extern fn Scalar -> Ptr -> Int -> ();
let atg__assert_tensor_metadata = extern fn Tensor -> Ptr -> Int -> Ptr -> Int -> Int -> Int -> int8_t -> ();
let atg__autocast_to_full_precision = extern fn Ptr -> Tensor -> Int -> Int -> ();
let atg__autocast_to_reduced_precision = extern fn Ptr -> Tensor -> Int -> Int -> Int -> Int -> ();
let atg__batch_norm_no_update = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Double -> Double -> ();
let atg__batch_norm_no_update_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Double -> Double -> ();
let atg__batch_norm_with_update = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Double -> Double -> ();
let atg__batch_norm_with_update_functional = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Double -> Double -> ();
let atg__batch_norm_with_update_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Double -> Double -> ();
let atg__cast_byte = extern fn Ptr -> Tensor -> Int -> ();
let atg__cast_char = extern fn Ptr -> Tensor -> Int -> ();
let atg__cast_double = extern fn Ptr -> Tensor -> Int -> ();
let atg__cast_float = extern fn Ptr -> Tensor -> Int -> ();
let atg__cast_half = extern fn Ptr -> Tensor -> Int -> ();
let atg__cast_int = extern fn Ptr -> Tensor -> Int -> ();
let atg__cast_long = extern fn Ptr -> Tensor -> Int -> ();
let atg__cast_short = extern fn Ptr -> Tensor -> Int -> ();
let atg__cdist_backward = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Double -> Tensor -> ();
let atg__cdist_backward_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Double -> Tensor -> ();
let atg__cholesky_solve_helper = extern fn Ptr -> Tensor -> Tensor -> Int -> ();
let atg__cholesky_solve_helper_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg__chunk_cat = extern fn Ptr -> Ptr -> Int -> Int -> Int -> ();
let atg__chunk_cat_out = extern fn Ptr -> Tensor -> Ptr -> Int -> Int -> Int -> ();
let atg__coalesce = extern fn Ptr -> Tensor -> ();
let atg__coalesce_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg__coalesced = extern fn Ptr -> Tensor -> Int -> ();
let atg__coalesced_ = extern fn Ptr -> Tensor -> Int -> ();
let atg__coalesced_out = extern fn Ptr -> Tensor -> Tensor -> Int -> ();
let atg__compute_linear_combination = extern fn Ptr -> Tensor -> Tensor -> ();
let atg__compute_linear_combination_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg__conj = extern fn Ptr -> Tensor -> ();
let atg__conj_copy = extern fn Ptr -> Tensor -> ();
let atg__conj_copy_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg__conj_physical = extern fn Ptr -> Tensor -> ();
let atg__conj_physical_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg__conv_depthwise2d = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> ();
let atg__conv_depthwise2d_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> ();
let atg__convert_indices_from_coo_to_csr = extern fn Ptr -> Tensor -> Int -> Int -> ();
let atg__convert_indices_from_coo_to_csr_out = extern fn Ptr -> Tensor -> Tensor -> Int -> Int -> ();
let atg__convert_indices_from_csr_to_coo = extern fn Ptr -> Tensor -> Tensor -> Int -> Int -> ();
let atg__convert_indices_from_csr_to_coo_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> Int -> ();
let atg__convert_weight_to_int4pack = extern fn Ptr -> Tensor -> Int -> ();
let atg__convert_weight_to_int4pack_for_cpu = extern fn Ptr -> Tensor -> Int -> ();
let atg__convolution = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> Ptr -> Int -> Int -> Int -> Int -> Int -> Int -> ();
let atg__convolution_deprecated = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> Ptr -> Int -> Int -> Int -> Int -> Int -> ();
let atg__convolution_mode = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> ();
let atg__convolution_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> Ptr -> Int -> Int -> Int -> Int -> Int -> Int -> ();
let atg__copy_from = extern fn Ptr -> Tensor -> Tensor -> Int -> ();
let atg__copy_from_and_resize = extern fn Ptr -> Tensor -> Tensor -> ();
let atg__copy_from_and_resize_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg__copy_from_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg__cslt_compress = extern fn Ptr -> Tensor -> ();
let atg__cslt_sparse_mm = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Int -> Int -> Int -> Int -> ();
let atg__cslt_sparse_mm_search = extern fn Tensor -> Tensor -> Tensor -> Tensor -> Int -> Int -> Int;
let atg__ctc_loss = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Int -> Int -> ();
let atg__ctc_loss_backward = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Tensor -> Tensor -> Int -> Int -> ();
let atg__ctc_loss_backward_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Tensor -> Tensor -> Int -> Int -> ();
let atg__ctc_loss_backward_tensor = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Int -> ();
let atg__ctc_loss_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Int -> Int -> ();
let atg__ctc_loss_tensor = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Int -> ();
let atg__ctc_loss_tensor_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Int -> ();
let atg__cudnn_ctc_loss = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Int -> Int -> Int -> ();
let atg__cudnn_ctc_loss_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Int -> Int -> Int -> ();
let atg__cudnn_ctc_loss_tensor = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Int -> Int -> ();
let atg__cudnn_init_dropout_state = extern fn Ptr -> Double -> Int -> Int -> Int -> Int -> ();
let atg__cudnn_init_dropout_state_out = extern fn Ptr -> Tensor -> Double -> Int -> Int -> ();
let atg__cudnn_rnn = extern fn Ptr -> Tensor -> Ptr -> Int -> Int -> Tensor -> Tensor -> Tensor -> Int -> Int -> Int -> Int -> Int -> Double -> Int -> Int -> Ptr -> Int -> Tensor -> ();
let atg__cudnn_rnn_flatten_weight = extern fn Ptr -> Ptr -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> ();
let atg__cudnn_rnn_flatten_weight_out = extern fn Ptr -> Tensor -> Ptr -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> ();
let atg__cudnn_rnn_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Int -> Tensor -> Tensor -> Tensor -> Int -> Int -> Int -> Int -> Int -> Double -> Int -> Int -> Ptr -> Int -> Tensor -> ();
let atg__debug_has_internal_overlap = extern fn Tensor -> Int;
let atg__dim_arange = extern fn Ptr -> Tensor -> Int -> ();
let atg__dimi = extern fn Tensor -> Int;
let atg__dimv = extern fn Tensor -> Int;
let atg__dirichlet_grad = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg__dirichlet_grad_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> ();
let atg__dyn_quant_matmul_4bit = extern fn Ptr -> Tensor -> Tensor -> Int -> Int -> Int -> ();
let atg__dyn_quant_pack_4bit_weight = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> Int -> Int -> ();
let atg__efficient_attention_backward = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Int -> Tensor -> Double -> Tensor -> Tensor -> Int -> Int -> Double -> Char -> Int -> Char -> Int -> Char -> Int -> ();
let atg__efficientzerotensor = extern fn Ptr -> Ptr -> Int -> Int -> Int -> ();
let atg__efficientzerotensor_out = extern fn Ptr -> Tensor -> Ptr -> Int -> ();
let atg__embedding_bag = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> Int -> Int -> Tensor -> Int -> Int -> ();
let atg__embedding_bag_backward = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Int -> Int -> Int -> Tensor -> Int -> ();
let atg__embedding_bag_dense_backward = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Int -> Int -> Tensor -> Int -> ();
let atg__embedding_bag_dense_backward_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Int -> Int -> Tensor -> Int -> ();
let atg__embedding_bag_forward_only = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> Int -> Int -> Tensor -> Int -> Int -> ();
let atg__embedding_bag_forward_only_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Int -> Int -> Tensor -> Int -> Int -> ();
let atg__embedding_bag_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Int -> Int -> Tensor -> Int -> Int -> ();
let atg__embedding_bag_per_sample_weights_backward = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Int -> ();
let atg__embedding_bag_per_sample_weights_backward_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Int -> ();
let atg__embedding_bag_sparse_backward = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Int -> Int -> Tensor -> Int -> ();
let atg__empty_affine_quantized = extern fn Ptr -> Ptr -> Int -> Int -> Int -> Double -> Int -> ();
let atg__empty_affine_quantized_out = extern fn Ptr -> Tensor -> Ptr -> Int -> Double -> Int -> ();
let atg__empty_per_channel_affine_quantized = extern fn Ptr -> Ptr -> Int -> Tensor -> Tensor -> Int -> Int -> Int -> ();
let atg__empty_per_channel_affine_quantized_out = extern fn Ptr -> Tensor -> Ptr -> Int -> Tensor -> Tensor -> Int -> ();
let atg__euclidean_dist = extern fn Ptr -> Tensor -> Tensor -> ();
let atg__euclidean_dist_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg__fake_quantize_learnable_per_channel_affine = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> Int -> Int -> Double -> ();
let atg__fake_quantize_learnable_per_channel_affine_backward = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Int -> Int -> Double -> ();
let atg__fake_quantize_learnable_per_channel_affine_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Int -> Int -> Double -> ();
let atg__fake_quantize_learnable_per_tensor_affine = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> Int -> Double -> ();
let atg__fake_quantize_learnable_per_tensor_affine_backward = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Int -> Double -> ();
let atg__fake_quantize_learnable_per_tensor_affine_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Int -> Double -> ();
let atg__fake_quantize_per_tensor_affine_cachemask_tensor_qparams = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Int -> ();
let atg__fake_quantize_per_tensor_affine_cachemask_tensor_qparams_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Int -> ();
let atg__fft_c2c = extern fn Ptr -> Tensor -> Ptr -> Int -> Int -> Int -> ();
let atg__fft_c2c_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Int -> Int -> ();
let atg__fft_c2r = extern fn Ptr -> Tensor -> Ptr -> Int -> Int -> Int -> ();
let atg__fft_c2r_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Int -> Int -> ();
let atg__fft_r2c = extern fn Ptr -> Tensor -> Ptr -> Int -> Int -> Int -> ();
let atg__fft_r2c_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Int -> Int -> ();
let atg__fill_mem_eff_dropout_mask_ = extern fn Ptr -> Tensor -> Double -> Int -> Int -> ();
let atg__flash_attention_backward = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Int -> Double -> Int -> Tensor -> Tensor -> Double -> Char -> Int -> Char -> Int -> Char -> ();
let atg__foobar = extern fn Ptr -> Tensor -> Int -> Int -> Int -> ();
let atg__foobar_out = extern fn Ptr -> Tensor -> Tensor -> Int -> Int -> Int -> ();
let atg__functional_assert_async = extern fn Ptr -> Tensor -> Ptr -> Int -> Tensor -> ();
let atg__functional_assert_scalar = extern fn Ptr -> Scalar -> Ptr -> Int -> Tensor -> ();
let atg__functional_sym_constrain_range = extern fn Ptr -> Scalar -> Int -> Char -> Int -> Char -> Tensor -> ();
let atg__functional_sym_constrain_range_for_size = extern fn Ptr -> Scalar -> Int -> Char -> Int -> Char -> Tensor -> ();
let atg__fused_dropout = extern fn Ptr -> Tensor -> Double -> ();
let atg__fused_dropout_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Double -> ();
let atg__fused_moving_avg_obs_fq_helper = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Double -> Int -> Int -> Int -> Int -> Int -> ();
let atg__fused_moving_avg_obs_fq_helper_functional = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Double -> Int -> Int -> Int -> Int -> Int -> ();
let atg__fused_moving_avg_obs_fq_helper_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Double -> Int -> Int -> Int -> Int -> Int -> ();
let atg__fused_sdp_choice = extern fn Tensor -> Tensor -> Tensor -> Tensor -> Double -> Int -> Double -> Char -> Int -> Int;
let atg__fw_primal = extern fn Ptr -> Tensor -> Int -> ();
let atg__fw_primal_copy = extern fn Ptr -> Tensor -> Int -> ();
let atg__fw_primal_copy_out = extern fn Ptr -> Tensor -> Tensor -> Int -> ();
let atg__gather_sparse_backward = extern fn Ptr -> Tensor -> Int -> Tensor -> Tensor -> ();
let atg__grid_sampler_2d_cpu_fallback = extern fn Ptr -> Tensor -> Tensor -> Int -> Int -> Int -> ();
let atg__grid_sampler_2d_cpu_fallback_backward = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> Int -> Int -> ();
let atg__grid_sampler_2d_cpu_fallback_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> Int -> Int -> ();
let atg__has_compatible_shallow_copy_type = extern fn Tensor -> Tensor -> Int;
let atg__has_same_storage_numel = extern fn Tensor -> Tensor -> Int;
let atg__histogramdd_bin_edges = extern fn Tensor -> Ptr -> Int -> Ptr -> Int -> Tensor -> Int -> Ptr;
let atg__histogramdd_bin_edges_out = extern fn Ptr -> Int -> Tensor -> Ptr -> Int -> Ptr -> Int -> Tensor -> Int -> ();
let atg__histogramdd_from_bin_cts = extern fn Ptr -> Tensor -> Ptr -> Int -> Ptr -> Int -> Tensor -> Int -> ();
let atg__histogramdd_from_bin_cts_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Tensor -> Int -> ();
let atg__histogramdd_from_bin_tensors = extern fn Ptr -> Tensor -> Ptr -> Int -> Tensor -> Int -> ();
let atg__histogramdd_from_bin_tensors_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Tensor -> Int -> ();
let atg__index_put_impl = extern fn Ptr -> Tensor -> Ptr -> Int -> Tensor -> Int -> Int -> ();
let atg__index_put_impl_ = extern fn Ptr -> Tensor -> Ptr -> Int -> Tensor -> Int -> Int -> ();
let atg__index_put_impl_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Tensor -> Int -> Int -> ();
let atg__indices = extern fn Ptr -> Tensor -> ();
let atg__indices_copy = extern fn Ptr -> Tensor -> ();
let atg__indices_copy_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg__int_mm = extern fn Ptr -> Tensor -> Tensor -> ();
let atg__int_mm_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg__is_all_true = extern fn Ptr -> Tensor -> ();
let atg__is_any_true = extern fn Ptr -> Tensor -> ();
let atg__is_zerotensor = extern fn Tensor -> Int;
let atg__lazy_clone = extern fn Ptr -> Tensor -> ();
let atg__linalg_check_errors = extern fn Tensor -> Ptr -> Int -> Int -> ();
let atg__linalg_det = extern fn Ptr -> Tensor -> ();
let atg__linalg_det_result = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> ();
let atg__linalg_eigh = extern fn Ptr -> Tensor -> Ptr -> Int -> Int -> ();
let atg__linalg_eigh_eigenvalues = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Int -> ();
let atg__linalg_eigvals = extern fn Ptr -> Tensor -> ();
let atg__linalg_slogdet = extern fn Ptr -> Tensor -> ();
let atg__linalg_slogdet_sign = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> ();
let atg__linalg_solve_ex = extern fn Ptr -> Tensor -> Tensor -> Int -> Int -> ();
let atg__linalg_solve_ex_result = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Int -> ();
let atg__linalg_svd = extern fn Ptr -> Tensor -> Int -> Int -> Ptr -> Int -> ();
let atg__linalg_svd_u = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Int -> Ptr -> Int -> ();
let atg__log_softmax = extern fn Ptr -> Tensor -> Int -> Int -> ();
let atg__log_softmax_backward_data = extern fn Ptr -> Tensor -> Tensor -> Int -> Int -> ();
let atg__log_softmax_backward_data_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> Int -> ();
let atg__log_softmax_out = extern fn Ptr -> Tensor -> Tensor -> Int -> Int -> ();
let atg__logcumsumexp = extern fn Ptr -> Tensor -> Int -> ();
let atg__logcumsumexp_out = extern fn Ptr -> Tensor -> Tensor -> Int -> ();
let atg__lstm_mps = extern fn Ptr -> Tensor -> Ptr -> Int -> Ptr -> Int -> Int -> Int -> Double -> Int -> Int -> Int -> ();
let atg__lstm_mps_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Int -> Int -> Double -> Int -> Int -> Int -> ();
let atg__lu_with_info = extern fn Ptr -> Tensor -> Int -> Int -> ();
let atg__make_dep_token = extern fn Ptr -> Int -> Int -> ();
let atg__make_dual = extern fn Ptr -> Tensor -> Tensor -> Int -> ();
let atg__make_dual_copy = extern fn Ptr -> Tensor -> Tensor -> Int -> ();
let atg__make_dual_copy_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg__make_per_channel_quantized_tensor = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg__make_per_channel_quantized_tensor_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg__make_per_tensor_quantized_tensor = extern fn Ptr -> Tensor -> Double -> Int -> ();
let atg__make_per_tensor_quantized_tensor_out = extern fn Ptr -> Tensor -> Tensor -> Double -> Int -> ();
let atg__masked_scale = extern fn Ptr -> Tensor -> Tensor -> Double -> ();
let atg__masked_scale_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Double -> ();
let atg__masked_softmax = extern fn Ptr -> Tensor -> Tensor -> Int -> Char -> Int -> Char -> ();
let atg__masked_softmax_backward = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> Char -> ();
let atg__masked_softmax_backward_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Char -> ();
let atg__masked_softmax_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> Char -> Int -> Char -> ();
let atg__mixed_dtypes_linear = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg__mkldnn_reshape = extern fn Ptr -> Tensor -> Ptr -> Int -> ();
let atg__mkldnn_reshape_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg__mkldnn_transpose = extern fn Ptr -> Tensor -> Int -> Int -> ();
let atg__mkldnn_transpose_ = extern fn Ptr -> Tensor -> Int -> Int -> ();
let atg__mkldnn_transpose_out = extern fn Ptr -> Tensor -> Tensor -> Int -> Int -> ();
let atg__mps_convolution = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> ();
let atg__mps_convolution_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> ();
let atg__mps_convolution_transpose = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> ();
let atg__mps_convolution_transpose_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> ();
let atg__native_batch_norm_legit = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Double -> Double -> ();
let atg__native_batch_norm_legit_functional = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Double -> Double -> ();
let atg__native_batch_norm_legit_no_stats = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> Double -> Double -> ();
let atg__native_batch_norm_legit_no_stats_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Double -> Double -> ();
let atg__native_batch_norm_legit_no_training = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Double -> Double -> ();
let atg__native_batch_norm_legit_no_training_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Double -> Double -> ();
let atg__native_batch_norm_legit_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Double -> Double -> ();
let atg__native_multi_head_attention = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> Int -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Int -> Int -> Char -> ();
let atg__native_multi_head_attention_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Int -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Int -> Int -> Char -> ();
let atg__neg_view = extern fn Ptr -> Tensor -> ();
let atg__neg_view_copy = extern fn Ptr -> Tensor -> ();
let atg__neg_view_copy_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg__nested_compute_contiguous_strides_offsets = extern fn Ptr -> Tensor -> ();
let atg__nested_from_padded = extern fn Ptr -> Tensor -> Tensor -> Int -> ();
let atg__nested_from_padded_and_nested_example = extern fn Ptr -> Tensor -> Tensor -> ();
let atg__nested_from_padded_and_nested_example_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg__nested_from_padded_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg__nested_from_padded_tensor = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> Tensor -> Tensor -> Int -> Char -> ();
let atg__nested_get_jagged_dummy = extern fn Ptr -> Tensor -> ();
let atg__nested_get_lengths = extern fn Ptr -> Tensor -> ();
let atg__nested_get_max_seqlen = extern fn Ptr -> Tensor -> ();
let atg__nested_get_min_seqlen = extern fn Ptr -> Tensor -> ();
let atg__nested_get_offsets = extern fn Ptr -> Tensor -> ();
let atg__nested_get_ragged_idx = extern fn Tensor -> Int;
let atg__nested_get_values = extern fn Ptr -> Tensor -> ();
let atg__nested_get_values_copy = extern fn Ptr -> Tensor -> ();
let atg__nested_get_values_copy_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg__nested_select_backward = extern fn Ptr -> Tensor -> Tensor -> Int -> Int -> ();
let atg__nested_sum_backward = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Int -> ();
let atg__nested_view_from_buffer = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> ();
let atg__nested_view_from_buffer_copy = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> ();
let atg__nested_view_from_buffer_copy_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> ();
let atg__nested_view_from_jagged = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Tensor -> Tensor -> ();
let atg__nested_view_from_jagged_copy = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Tensor -> Tensor -> ();
let atg__nested_view_from_jagged_copy_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Tensor -> Tensor -> ();
let atg__new_zeros_with_same_feature_meta = extern fn Ptr -> Tensor -> Tensor -> Int -> ();
let atg__new_zeros_with_same_feature_meta_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg__nnpack_available = extern fn () -> Int;
let atg__nnpack_spatial_convolution = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> ();
let atg__nnpack_spatial_convolution_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> ();
let atg__nnz = extern fn Tensor -> Int;
let atg__pack_padded_sequence = extern fn Ptr -> Tensor -> Tensor -> Int -> ();
let atg__pack_padded_sequence_backward = extern fn Ptr -> Tensor -> Ptr -> Int -> Tensor -> Int -> ();
let atg__pack_padded_sequence_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg__pad_circular = extern fn Ptr -> Tensor -> Ptr -> Int -> ();
let atg__pad_enum = extern fn Ptr -> Tensor -> Ptr -> Int -> Int -> Double -> Char -> ();
let atg__pad_packed_sequence = extern fn Ptr -> Tensor -> Tensor -> Int -> Scalar -> Int -> ();
let atg__pdist_backward = extern fn Ptr -> Tensor -> Tensor -> Double -> Tensor -> ();
let atg__pdist_backward_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Double -> Tensor -> ();
let atg__pin_memory = extern fn Ptr -> Tensor -> Int -> ();
let atg__pin_memory_out = extern fn Ptr -> Tensor -> Tensor -> Int -> ();
let atg__prelu_kernel = extern fn Ptr -> Tensor -> Tensor -> ();
let atg__prelu_kernel_backward = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg__print = extern fn Ptr -> Int -> ();
let atg__propagate_xla_data = extern fn Tensor -> Tensor -> ();
let atg__remove_batch_dim = extern fn Ptr -> Tensor -> Int -> Int -> Int -> ();
let atg__reshape_alias = extern fn Ptr -> Tensor -> Ptr -> Int -> Ptr -> Int -> ();
let atg__reshape_alias_copy = extern fn Ptr -> Tensor -> Ptr -> Int -> Ptr -> Int -> ();
let atg__reshape_alias_copy_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> ();
let atg__reshape_copy = extern fn Ptr -> Tensor -> Ptr -> Int -> ();
let atg__reshape_from_tensor = extern fn Ptr -> Tensor -> Tensor -> ();
let atg__resize_output = extern fn Ptr -> Tensor -> Ptr -> Int -> Int -> ();
let atg__resize_output_ = extern fn Ptr -> Tensor -> Ptr -> Int -> Int -> ();
let atg__resize_output_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Int -> ();
let atg__rowwise_prune = extern fn Ptr -> Tensor -> Tensor -> Int -> ();
let atg__safe_softmax = extern fn Ptr -> Tensor -> Int -> Int -> ();
let atg__sample_dirichlet = extern fn Ptr -> Tensor -> ();
let atg__sample_dirichlet_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg__saturate_weight_to_fp16 = extern fn Ptr -> Tensor -> ();
let atg__scaled_dot_product_attention_math = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Double -> Int -> Tensor -> Double -> Char -> Int -> ();
let atg__scaled_dot_product_attention_math_for_mps = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Double -> Int -> Tensor -> Double -> Char -> ();
let atg__scaled_dot_product_cudnn_attention_backward = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Int -> Double -> Int -> Double -> Char -> ();
let atg__scaled_dot_product_efficient_attention = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Double -> Int -> Double -> Char -> ();
let atg__scaled_dot_product_flash_attention_backward = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Int -> Double -> Int -> Tensor -> Tensor -> Double -> Char -> ();
let atg__scaled_dot_product_flash_attention_for_cpu = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Double -> Int -> Tensor -> Double -> Char -> ();
let atg__scaled_dot_product_flash_attention_for_cpu_backward = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Double -> Int -> Tensor -> Double -> Char -> ();
let atg__scaled_grouped_mm = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Int -> ();
let atg__scaled_mm = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Int -> ();
let atg__scaled_mm_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Int -> ();
let atg__scatter_reduce = extern fn Ptr -> Tensor -> Int -> Tensor -> Tensor -> Ptr -> Int -> Int -> ();
let atg__scatter_reduce_ = extern fn Ptr -> Tensor -> Int -> Tensor -> Tensor -> Ptr -> Int -> Int -> ();
let atg__scatter_reduce_two_out = extern fn Ptr -> Tensor -> Tensor -> Int -> Tensor -> Tensor -> Ptr -> Int -> Int -> ();
let atg__segment_reduce_backward = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Tensor -> Tensor -> Int -> Scalar -> ();
let atg__segment_reduce_backward_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Tensor -> Tensor -> Int -> Scalar -> ();
let atg__shape_as_tensor = extern fn Ptr -> Tensor -> ();
let atg__slow_conv2d_backward = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> ();
let atg__sobol_engine_draw = extern fn Ptr -> Tensor -> Int -> Tensor -> Int -> Int -> Int -> ();
let atg__sobol_engine_ff_ = extern fn Ptr -> Tensor -> Int -> Tensor -> Int -> Int -> ();
let atg__sobol_engine_initialize_state_ = extern fn Ptr -> Tensor -> Int -> ();
let atg__sobol_engine_scramble_ = extern fn Ptr -> Tensor -> Tensor -> Int -> ();
let atg__softmax = extern fn Ptr -> Tensor -> Int -> Int -> ();
let atg__softmax_backward_data = extern fn Ptr -> Tensor -> Tensor -> Int -> Int -> ();
let atg__softmax_backward_data_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> Int -> ();
let atg__softmax_out = extern fn Ptr -> Tensor -> Tensor -> Int -> Int -> ();
let atg__sparse_addmm = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg__sparse_addmm_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> ();
let atg__sparse_broadcast_to = extern fn Ptr -> Tensor -> Ptr -> Int -> ();
let atg__sparse_broadcast_to_copy = extern fn Ptr -> Tensor -> Ptr -> Int -> ();
let atg__sparse_broadcast_to_copy_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg__sparse_bsc_tensor_unsafe = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Int -> Int -> ();
let atg__sparse_bsr_tensor_unsafe = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Int -> Int -> ();
let atg__sparse_compressed_tensor_unsafe = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Int -> Int -> ();
let atg__sparse_compressed_tensor_with_dims = extern fn Ptr -> Int -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> Int -> Int -> ();
let atg__sparse_coo_tensor_unsafe = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Int -> Int -> Int -> ();
let atg__sparse_coo_tensor_with_dims = extern fn Ptr -> Int -> Int -> Ptr -> Int -> Int -> Int -> ();
let atg__sparse_coo_tensor_with_dims_and_tensors = extern fn Ptr -> Int -> Int -> Ptr -> Int -> Tensor -> Tensor -> Int -> Int -> Int -> ();
let atg__sparse_coo_tensor_with_dims_and_tensors_out = extern fn Ptr -> Tensor -> Int -> Int -> Ptr -> Int -> Tensor -> Tensor -> Int -> ();
let atg__sparse_coo_tensor_with_dims_out = extern fn Ptr -> Tensor -> Int -> Int -> Ptr -> Int -> ();
let atg__sparse_csc_tensor_unsafe = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Int -> Int -> ();
let atg__sparse_csr_prod = extern fn Ptr -> Tensor -> Ptr -> Int -> Int -> Int -> ();
let atg__sparse_csr_prod_dim_dtype_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Int -> Int -> ();
let atg__sparse_csr_sum = extern fn Ptr -> Tensor -> Ptr -> Int -> Int -> Int -> ();
let atg__sparse_csr_sum_dim_dtype_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Int -> Int -> ();
let atg__sparse_csr_tensor_unsafe = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Int -> Int -> ();
let atg__sparse_log_softmax = extern fn Ptr -> Tensor -> Int -> Int -> ();
let atg__sparse_log_softmax_backward_data = extern fn Ptr -> Tensor -> Tensor -> Int -> Tensor -> ();
let atg__sparse_log_softmax_backward_data_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> Tensor -> ();
let atg__sparse_log_softmax_int = extern fn Ptr -> Tensor -> Int -> Int -> ();
let atg__sparse_log_softmax_out = extern fn Ptr -> Tensor -> Tensor -> Int -> Int -> ();
let atg__sparse_mask_projection = extern fn Ptr -> Tensor -> Tensor -> Int -> ();
let atg__sparse_mask_projection_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg__sparse_mm = extern fn Ptr -> Tensor -> Tensor -> ();
let atg__sparse_mm_reduce = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg__sparse_mm_reduce_impl = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg__sparse_semi_structured_apply = extern fn Ptr -> Tensor -> Tensor -> ();
let atg__sparse_semi_structured_apply_dense = extern fn Ptr -> Tensor -> Tensor -> ();
let atg__sparse_semi_structured_linear = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Int -> ();
let atg__sparse_semi_structured_mm = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg__sparse_semi_structured_tile = extern fn Ptr -> Tensor -> Ptr -> Int -> Int -> ();
let atg__sparse_softmax = extern fn Ptr -> Tensor -> Int -> Int -> ();
let atg__sparse_softmax_backward_data = extern fn Ptr -> Tensor -> Tensor -> Int -> Tensor -> ();
let atg__sparse_softmax_backward_data_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> Tensor -> ();
let atg__sparse_softmax_int = extern fn Ptr -> Tensor -> Int -> Int -> ();
let atg__sparse_softmax_out = extern fn Ptr -> Tensor -> Tensor -> Int -> Int -> ();
let atg__sparse_sparse_matmul = extern fn Ptr -> Tensor -> Tensor -> ();
let atg__sparse_sparse_matmul_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg__sparse_sum = extern fn Ptr -> Tensor -> ();
let atg__sparse_sum_backward = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg__sparse_sum_backward_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg__sparse_sum_dim = extern fn Ptr -> Tensor -> Ptr -> Int -> ();
let atg__sparse_sum_dim_dtype = extern fn Ptr -> Tensor -> Ptr -> Int -> Int -> ();
let atg__sparse_sum_dim_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg__sparse_sum_dtype = extern fn Ptr -> Tensor -> Int -> ();
let atg__spdiags = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> int8_t -> ();
let atg__spdiags_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> int8_t -> ();
let atg__spsolve = extern fn Ptr -> Tensor -> Tensor -> Int -> ();
let atg__stack = extern fn Ptr -> Ptr -> Int -> Int -> ();
let atg__stack_out = extern fn Ptr -> Tensor -> Ptr -> Int -> Int -> ();
let atg__standard_gamma = extern fn Ptr -> Tensor -> ();
let atg__standard_gamma_grad = extern fn Ptr -> Tensor -> Tensor -> ();
let atg__standard_gamma_grad_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg__standard_gamma_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg__test_ambiguous_defaults = extern fn Ptr -> Tensor -> Int -> Int -> ();
let atg__test_ambiguous_defaults_b = extern fn Ptr -> Tensor -> Int -> Ptr -> Int -> ();
let atg__test_autograd_multiple_dispatch = extern fn Ptr -> Tensor -> ();
let atg__test_autograd_multiple_dispatch_fullcoverage_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg__test_autograd_multiple_dispatch_ntonly = extern fn Ptr -> Tensor -> Int -> ();
let atg__test_autograd_multiple_dispatch_view = extern fn Ptr -> Tensor -> ();
let atg__test_autograd_multiple_dispatch_view_copy = extern fn Ptr -> Tensor -> ();
let atg__test_autograd_multiple_dispatch_view_copy_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg__test_check_tensor = extern fn Ptr -> Tensor -> ();
let atg__test_functorch_fallback = extern fn Ptr -> Tensor -> Tensor -> ();
let atg__test_functorch_fallback_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg__test_optional_filled_intlist = extern fn Ptr -> Tensor -> Ptr -> Int -> ();
let atg__test_optional_filled_intlist_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg__test_optional_floatlist = extern fn Ptr -> Tensor -> Ptr -> Int -> ();
let atg__test_optional_floatlist_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg__test_optional_intlist = extern fn Ptr -> Tensor -> Ptr -> Int -> ();
let atg__test_optional_intlist_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg__test_parallel_materialize = extern fn Ptr -> Tensor -> Int -> Int -> ();
let atg__test_serialization_subcmul = extern fn Ptr -> Tensor -> Tensor -> ();
let atg__test_string_default = extern fn Ptr -> Tensor -> Ptr -> Int -> Ptr -> Int -> ();
let atg__test_warn_in_autograd = extern fn Ptr -> Tensor -> ();
let atg__test_warn_in_autograd_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg__to_copy = extern fn Ptr -> Tensor -> Int -> Int -> Int -> ();
let atg__to_copy_out = extern fn Ptr -> Tensor -> Tensor -> Int -> ();
let atg__to_cpu = extern fn Ptr -> Int -> Ptr;
let atg__to_dense = extern fn Ptr -> Tensor -> Int -> Int -> ();
let atg__to_dense_out = extern fn Ptr -> Tensor -> Tensor -> Int -> Int -> ();
let atg__to_sparse = extern fn Ptr -> Tensor -> int8_t -> Ptr -> Int -> Int -> Char -> ();
let atg__to_sparse_bsc = extern fn Ptr -> Tensor -> Ptr -> Int -> Int -> Char -> ();
let atg__to_sparse_bsc_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Int -> Char -> ();
let atg__to_sparse_bsr = extern fn Ptr -> Tensor -> Ptr -> Int -> Int -> Char -> ();
let atg__to_sparse_bsr_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Int -> Char -> ();
let atg__to_sparse_csc = extern fn Ptr -> Tensor -> Int -> Char -> ();
let atg__to_sparse_csc_out = extern fn Ptr -> Tensor -> Tensor -> Int -> Char -> ();
let atg__to_sparse_csr = extern fn Ptr -> Tensor -> Int -> Char -> ();
let atg__to_sparse_csr_out = extern fn Ptr -> Tensor -> Tensor -> Int -> Char -> ();
let atg__to_sparse_out = extern fn Ptr -> Tensor -> Tensor -> int8_t -> Ptr -> Int -> Int -> Char -> ();
let atg__to_sparse_semi_structured = extern fn Ptr -> Tensor -> ();
let atg__to_sparse_sparse_dim = extern fn Ptr -> Tensor -> Int -> ();
let atg__to_sparse_sparse_dim_out = extern fn Ptr -> Tensor -> Tensor -> Int -> ();
let atg__transform_bias_rescale_qkv = extern fn Ptr -> Tensor -> Tensor -> Int -> ();
let atg__transform_bias_rescale_qkv_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg__transformer_encoder_layer_fwd = extern fn Ptr -> Tensor -> Int -> Int -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Int -> Double -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Char -> ();
let atg__transformer_encoder_layer_fwd_out = extern fn Ptr -> Tensor -> Tensor -> Int -> Int -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Int -> Double -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Char -> ();
let atg__trilinear = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> ();
let atg__trilinear_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> ();
let atg__triton_multi_head_attention = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> Int -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> ();
let atg__triton_multi_head_attention_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Int -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> ();
let atg__triton_scaled_dot_attention = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Double -> ();
let atg__triton_scaled_dot_attention_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Double -> ();
let atg__unique = extern fn Ptr -> Tensor -> Int -> Int -> ();
let atg__unique2 = extern fn Ptr -> Tensor -> Int -> Int -> Int -> ();
let atg__unique2_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Int -> Int -> ();
let atg__unique_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> Int -> ();
let atg__unpack_dual = extern fn Ptr -> Tensor -> Int -> ();
let atg__unsafe_index = extern fn Ptr -> Tensor -> Ptr -> Int -> ();
let atg__unsafe_index_put = extern fn Ptr -> Tensor -> Ptr -> Int -> Tensor -> Int -> ();
let atg__unsafe_masked_index = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Scalar -> ();
let atg__unsafe_masked_index_put_accumulate = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Tensor -> ();
let atg__unsafe_view = extern fn Ptr -> Tensor -> Ptr -> Int -> ();
let atg__unsafe_view_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg__upsample_bicubic2d_aa = extern fn Ptr -> Tensor -> Ptr -> Int -> Int -> Double -> Char -> Double -> Char -> ();
let atg__upsample_bicubic2d_aa_backward = extern fn Ptr -> Tensor -> Ptr -> Int -> Ptr -> Int -> Int -> Double -> Char -> Double -> Char -> ();
let atg__upsample_bicubic2d_aa_backward_grad_input = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Int -> Double -> Char -> Double -> Char -> ();
let atg__upsample_bicubic2d_aa_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Int -> Double -> Char -> Double -> Char -> ();
let atg__upsample_bicubic2d_aa_vec = extern fn Ptr -> Tensor -> Ptr -> Int -> Int -> Ptr -> Int -> ();
let atg__upsample_bilinear2d_aa = extern fn Ptr -> Tensor -> Ptr -> Int -> Int -> Double -> Char -> Double -> Char -> ();
let atg__upsample_bilinear2d_aa_backward = extern fn Ptr -> Tensor -> Ptr -> Int -> Ptr -> Int -> Int -> Double -> Char -> Double -> Char -> ();
let atg__upsample_bilinear2d_aa_backward_grad_input = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Int -> Double -> Char -> Double -> Char -> ();
let atg__upsample_bilinear2d_aa_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Int -> Double -> Char -> Double -> Char -> ();
let atg__upsample_bilinear2d_aa_vec = extern fn Ptr -> Tensor -> Ptr -> Int -> Int -> Ptr -> Int -> ();
let atg__upsample_nearest_exact1d = extern fn Ptr -> Tensor -> Ptr -> Int -> Double -> Char -> ();
let atg__upsample_nearest_exact1d_backward = extern fn Ptr -> Tensor -> Ptr -> Int -> Ptr -> Int -> Double -> Char -> ();
let atg__upsample_nearest_exact1d_backward_grad_input = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Double -> Char -> ();
let atg__upsample_nearest_exact1d_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Double -> Char -> ();
let atg__upsample_nearest_exact1d_vec = extern fn Ptr -> Tensor -> Ptr -> Int -> Ptr -> Int -> ();
let atg__upsample_nearest_exact2d = extern fn Ptr -> Tensor -> Ptr -> Int -> Double -> Char -> Double -> Char -> ();
let atg__upsample_nearest_exact2d_backward = extern fn Ptr -> Tensor -> Ptr -> Int -> Ptr -> Int -> Double -> Char -> Double -> Char -> ();
let atg__upsample_nearest_exact2d_backward_grad_input = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Double -> Char -> Double -> Char -> ();
let atg__upsample_nearest_exact2d_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Double -> Char -> Double -> Char -> ();
let atg__upsample_nearest_exact2d_vec = extern fn Ptr -> Tensor -> Ptr -> Int -> Ptr -> Int -> ();
let atg__upsample_nearest_exact3d = extern fn Ptr -> Tensor -> Ptr -> Int -> Double -> Char -> Double -> Char -> Double -> Char -> ();
let atg__upsample_nearest_exact3d_backward = extern fn Ptr -> Tensor -> Ptr -> Int -> Ptr -> Int -> Double -> Char -> Double -> Char -> Double -> Char -> ();
let atg__upsample_nearest_exact3d_backward_grad_input = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Double -> Char -> Double -> Char -> Double -> Char -> ();
let atg__upsample_nearest_exact3d_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Double -> Char -> Double -> Char -> Double -> Char -> ();
let atg__upsample_nearest_exact3d_vec = extern fn Ptr -> Tensor -> Ptr -> Int -> Ptr -> Int -> ();
let atg__use_cudnn_ctc_loss = extern fn Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Int -> Int;
let atg__use_cudnn_ctc_loss_tensor = extern fn Tensor -> Tensor -> Tensor -> Tensor -> Int -> Int;
let atg__use_cudnn_rnn_flatten_weight = extern fn () -> Int;
let atg__validate_compressed_sparse_indices = extern fn Int -> Tensor -> Tensor -> Int -> Int -> Int -> ();
let atg__validate_sparse_bsc_tensor_args = extern fn Tensor -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg__validate_sparse_bsr_tensor_args = extern fn Tensor -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg__validate_sparse_compressed_tensor_args = extern fn Tensor -> Tensor -> Tensor -> Ptr -> Int -> int8_t -> ();
let atg__validate_sparse_csc_tensor_args = extern fn Tensor -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg__validate_sparse_csr_tensor_args = extern fn Tensor -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg__values = extern fn Ptr -> Tensor -> ();
let atg__values_copy = extern fn Ptr -> Tensor -> ();
let atg__values_copy_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg__version = extern fn Tensor -> Int;
let atg__weight_int4pack_mm = extern fn Ptr -> Tensor -> Tensor -> Int -> Tensor -> ();
let atg__weight_int4pack_mm_for_cpu = extern fn Ptr -> Tensor -> Tensor -> Int -> Tensor -> ();
let atg__weight_int8pack_mm = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg__weight_norm = extern fn Ptr -> Tensor -> Tensor -> Int -> ();
let atg__weight_norm_differentiable_backward = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg__weight_norm_interface = extern fn Ptr -> Tensor -> Tensor -> Int -> ();
let atg__weight_norm_interface_backward = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg__weight_norm_interface_backward_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg__weight_norm_interface_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg__wrapped_linear_prepack = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> ();
let atg__wrapped_quantized_linear_prepacked = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg_abs = extern fn Ptr -> Tensor -> ();
let atg_abs_ = extern fn Ptr -> Tensor -> ();
let atg_abs_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_absolute = extern fn Ptr -> Tensor -> ();
let atg_absolute_ = extern fn Ptr -> Tensor -> ();
let atg_absolute_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_acos = extern fn Ptr -> Tensor -> ();
let atg_acos_ = extern fn Ptr -> Tensor -> ();
let atg_acos_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_acosh = extern fn Ptr -> Tensor -> ();
let atg_acosh_ = extern fn Ptr -> Tensor -> ();
let atg_acosh_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_adaptive_avg_pool1d = extern fn Ptr -> Tensor -> Ptr -> Int -> ();
let atg_adaptive_avg_pool1d_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg_adaptive_avg_pool2d = extern fn Ptr -> Tensor -> Ptr -> Int -> ();
let atg_adaptive_avg_pool2d_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg_adaptive_avg_pool3d = extern fn Ptr -> Tensor -> Ptr -> Int -> ();
let atg_adaptive_avg_pool3d_backward = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_adaptive_avg_pool3d_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg_adaptive_max_pool1d = extern fn Ptr -> Tensor -> Ptr -> Int -> ();
let atg_adaptive_max_pool2d = extern fn Ptr -> Tensor -> Ptr -> Int -> ();
let atg_adaptive_max_pool2d_backward = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_adaptive_max_pool2d_backward_grad_input = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> ();
let atg_adaptive_max_pool2d_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg_adaptive_max_pool3d = extern fn Ptr -> Tensor -> Ptr -> Int -> ();
let atg_adaptive_max_pool3d_backward = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_adaptive_max_pool3d_backward_grad_input = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> ();
let atg_adaptive_max_pool3d_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg_add = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_add_ = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_add_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_add_scalar = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_add_scalar_ = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_add_scalar_out = extern fn Ptr -> Tensor -> Tensor -> Scalar -> ();
let atg_addbmm = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_addbmm_ = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_addbmm_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> ();
let atg_addcdiv = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_addcdiv_ = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_addcdiv_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> ();
let atg_addcmul = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_addcmul_ = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_addcmul_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> ();
let atg_addmm = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_addmm_ = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_addmm_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> ();
let atg_addmv = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_addmv_ = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_addmv_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> ();
let atg_addr = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_addr_ = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_addr_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> ();
let atg_adjoint = extern fn Ptr -> Tensor -> ();
let atg_affine_grid_generator = extern fn Ptr -> Tensor -> Ptr -> Int -> Int -> ();
let atg_affine_grid_generator_backward = extern fn Ptr -> Tensor -> Ptr -> Int -> Int -> ();
let atg_affine_grid_generator_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Int -> ();
let atg_alias = extern fn Ptr -> Tensor -> ();
let atg_alias_copy = extern fn Ptr -> Tensor -> ();
let atg_alias_copy_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_align_as = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_align_tensors = extern fn Ptr -> Int -> Ptr;
let atg_all = extern fn Ptr -> Tensor -> ();
let atg_all_all_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_all_dim = extern fn Ptr -> Tensor -> Int -> Int -> ();
let atg_all_dims = extern fn Ptr -> Tensor -> Ptr -> Int -> Int -> ();
let atg_all_dims_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Int -> ();
let atg_all_out = extern fn Ptr -> Tensor -> Tensor -> Int -> Int -> ();
let atg_allclose = extern fn Tensor -> Tensor -> Double -> Double -> Int -> Int;
let atg_alpha_dropout = extern fn Ptr -> Tensor -> Double -> Int -> ();
let atg_alpha_dropout_ = extern fn Ptr -> Tensor -> Double -> Int -> ();
let atg_amax = extern fn Ptr -> Tensor -> Ptr -> Int -> Int -> ();
let atg_amax_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Int -> ();
let atg_amin = extern fn Ptr -> Tensor -> Ptr -> Int -> Int -> ();
let atg_amin_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Int -> ();
let atg_aminmax = extern fn Ptr -> Tensor -> Int -> Char -> Int -> ();
let atg_aminmax_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> Char -> Int -> ();
let atg_angle = extern fn Ptr -> Tensor -> ();
let atg_angle_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_any = extern fn Ptr -> Tensor -> ();
let atg_any_all_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_any_dim = extern fn Ptr -> Tensor -> Int -> Int -> ();
let atg_any_dims = extern fn Ptr -> Tensor -> Ptr -> Int -> Int -> ();
let atg_any_dims_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Int -> ();
let atg_any_out = extern fn Ptr -> Tensor -> Tensor -> Int -> Int -> ();
let atg_arange = extern fn Ptr -> Scalar -> Int -> Int -> ();
let atg_arange_start = extern fn Ptr -> Scalar -> Scalar -> Int -> Int -> ();
let atg_arange_start_step = extern fn Ptr -> Scalar -> Scalar -> Scalar -> Int -> Int -> ();
let atg_arccos = extern fn Ptr -> Tensor -> ();
let atg_arccos_ = extern fn Ptr -> Tensor -> ();
let atg_arccos_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_arccosh = extern fn Ptr -> Tensor -> ();
let atg_arccosh_ = extern fn Ptr -> Tensor -> ();
let atg_arccosh_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_arcsin = extern fn Ptr -> Tensor -> ();
let atg_arcsin_ = extern fn Ptr -> Tensor -> ();
let atg_arcsin_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_arcsinh = extern fn Ptr -> Tensor -> ();
let atg_arcsinh_ = extern fn Ptr -> Tensor -> ();
let atg_arcsinh_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_arctan = extern fn Ptr -> Tensor -> ();
let atg_arctan2 = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_arctan2_ = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_arctan2_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_arctan_ = extern fn Ptr -> Tensor -> ();
let atg_arctan_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_arctanh = extern fn Ptr -> Tensor -> ();
let atg_arctanh_ = extern fn Ptr -> Tensor -> ();
let atg_arctanh_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_argmax = extern fn Ptr -> Tensor -> Int -> Char -> Int -> ();
let atg_argmax_out = extern fn Ptr -> Tensor -> Tensor -> Int -> Char -> Int -> ();
let atg_argmin = extern fn Ptr -> Tensor -> Int -> Char -> Int -> ();
let atg_argmin_out = extern fn Ptr -> Tensor -> Tensor -> Int -> Char -> Int -> ();
let atg_argsort = extern fn Ptr -> Tensor -> Int -> Int -> ();
let atg_argsort_stable = extern fn Ptr -> Tensor -> Int -> Int -> Int -> ();
let atg_argsort_stable_out = extern fn Ptr -> Tensor -> Tensor -> Int -> Int -> Int -> ();
let atg_argwhere = extern fn Ptr -> Tensor -> ();
let atg_as_strided = extern fn Ptr -> Tensor -> Ptr -> Int -> Ptr -> Int -> Int -> Char -> ();
let atg_as_strided_ = extern fn Ptr -> Tensor -> Ptr -> Int -> Ptr -> Int -> Int -> Char -> ();
let atg_as_strided_copy = extern fn Ptr -> Tensor -> Ptr -> Int -> Ptr -> Int -> Int -> Char -> ();
let atg_as_strided_copy_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Int -> Char -> ();
let atg_as_strided_scatter = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Int -> Char -> ();
let atg_as_strided_scatter_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Int -> Char -> ();
let atg_asin = extern fn Ptr -> Tensor -> ();
let atg_asin_ = extern fn Ptr -> Tensor -> ();
let atg_asin_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_asinh = extern fn Ptr -> Tensor -> ();
let atg_asinh_ = extern fn Ptr -> Tensor -> ();
let atg_asinh_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_atan = extern fn Ptr -> Tensor -> ();
let atg_atan2 = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_atan2_ = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_atan2_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_atan_ = extern fn Ptr -> Tensor -> ();
let atg_atan_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_atanh = extern fn Ptr -> Tensor -> ();
let atg_atanh_ = extern fn Ptr -> Tensor -> ();
let atg_atanh_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_atleast_1d = extern fn Ptr -> Tensor -> ();
let atg_atleast_1d_sequence = extern fn Ptr -> Int -> Ptr;
let atg_atleast_2d = extern fn Ptr -> Tensor -> ();
let atg_atleast_2d_sequence = extern fn Ptr -> Int -> Ptr;
let atg_atleast_3d = extern fn Ptr -> Tensor -> ();
let atg_atleast_3d_sequence = extern fn Ptr -> Int -> Ptr;
let atg_avg_pool1d = extern fn Ptr -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> Int -> ();
let atg_avg_pool1d_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> Int -> ();
let atg_avg_pool2d = extern fn Ptr -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> Int -> Int -> Char -> ();
let atg_avg_pool2d_backward = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> Int -> Int -> Char -> ();
let atg_avg_pool2d_backward_grad_input = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> Int -> Int -> Char -> ();
let atg_avg_pool2d_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> Int -> Int -> Char -> ();
let atg_avg_pool3d = extern fn Ptr -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> Int -> Int -> Char -> ();
let atg_avg_pool3d_backward = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> Int -> Int -> Char -> ();
let atg_avg_pool3d_backward_grad_input = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> Int -> Int -> Char -> ();
let atg_avg_pool3d_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> Int -> Int -> Char -> ();
let atg_baddbmm = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Scalar -> Scalar -> ();
let atg_baddbmm_ = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_baddbmm_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> ();
let atg_bartlett_window = extern fn Ptr -> Int -> Int -> Int -> ();
let atg_bartlett_window_out = extern fn Ptr -> Tensor -> Int -> ();
let atg_bartlett_window_periodic = extern fn Ptr -> Int -> Int -> Int -> Int -> ();
let atg_bartlett_window_periodic_out = extern fn Ptr -> Tensor -> Int -> Int -> ();
let atg_batch_norm = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Double -> Double -> Int -> ();
let atg_batch_norm_backward_elemt = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> ();
let atg_batch_norm_backward_elemt_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> ();
let atg_batch_norm_backward_reduce = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Int -> Int -> ();
let atg_batch_norm_backward_reduce_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Int -> Int -> ();
let atg_batch_norm_elemt = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Double -> ();
let atg_batch_norm_elemt_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Double -> ();
let atg_batch_norm_gather_stats = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Double -> Double -> Int -> ();
let atg_batch_norm_gather_stats_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Double -> Double -> Int -> ();
let atg_batch_norm_gather_stats_with_counts = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Double -> Double -> Tensor -> ();
let atg_batch_norm_gather_stats_with_counts_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Double -> Double -> Tensor -> ();
let atg_batch_norm_stats = extern fn Ptr -> Tensor -> Double -> ();
let atg_batch_norm_stats_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Double -> ();
let atg_batch_norm_update_stats = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Double -> ();
let atg_batch_norm_update_stats_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Double -> ();
let atg_bernoulli = extern fn Ptr -> Tensor -> ();
let atg_bernoulli_ = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_bernoulli_float_ = extern fn Ptr -> Tensor -> Double -> ();
let atg_bernoulli_p = extern fn Ptr -> Tensor -> Double -> ();
let atg_bernoulli_tensor = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_bilinear = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> ();
let atg_binary_cross_entropy = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg_binary_cross_entropy_backward = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg_binary_cross_entropy_backward_grad_input = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg_binary_cross_entropy_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg_binary_cross_entropy_with_logits = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg_binary_cross_entropy_with_logits_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg_bincount = extern fn Ptr -> Tensor -> Tensor -> Int -> ();
let atg_bincount_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg_binomial = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_binomial_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_bitwise_and = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_bitwise_and_ = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_bitwise_and_scalar_out = extern fn Ptr -> Tensor -> Tensor -> Scalar -> ();
let atg_bitwise_and_scalar_tensor = extern fn Ptr -> Scalar -> Tensor -> ();
let atg_bitwise_and_scalar_tensor_out = extern fn Ptr -> Tensor -> Scalar -> Tensor -> ();
let atg_bitwise_and_tensor = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_bitwise_and_tensor_ = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_bitwise_and_tensor_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_bitwise_left_shift = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_bitwise_left_shift_ = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_bitwise_left_shift_scalar_tensor = extern fn Ptr -> Scalar -> Tensor -> ();
let atg_bitwise_left_shift_scalar_tensor_out = extern fn Ptr -> Tensor -> Scalar -> Tensor -> ();
let atg_bitwise_left_shift_tensor_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_bitwise_left_shift_tensor_scalar = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_bitwise_left_shift_tensor_scalar_ = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_bitwise_left_shift_tensor_scalar_out = extern fn Ptr -> Tensor -> Tensor -> Scalar -> ();
let atg_bitwise_not = extern fn Ptr -> Tensor -> ();
let atg_bitwise_not_ = extern fn Ptr -> Tensor -> ();
let atg_bitwise_not_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_bitwise_or = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_bitwise_or_ = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_bitwise_or_scalar_out = extern fn Ptr -> Tensor -> Tensor -> Scalar -> ();
let atg_bitwise_or_scalar_tensor = extern fn Ptr -> Scalar -> Tensor -> ();
let atg_bitwise_or_scalar_tensor_out = extern fn Ptr -> Tensor -> Scalar -> Tensor -> ();
let atg_bitwise_or_tensor = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_bitwise_or_tensor_ = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_bitwise_or_tensor_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_bitwise_right_shift = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_bitwise_right_shift_ = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_bitwise_right_shift_scalar_tensor = extern fn Ptr -> Scalar -> Tensor -> ();
let atg_bitwise_right_shift_scalar_tensor_out = extern fn Ptr -> Tensor -> Scalar -> Tensor -> ();
let atg_bitwise_right_shift_tensor_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_bitwise_right_shift_tensor_scalar = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_bitwise_right_shift_tensor_scalar_ = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_bitwise_right_shift_tensor_scalar_out = extern fn Ptr -> Tensor -> Tensor -> Scalar -> ();
let atg_bitwise_xor = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_bitwise_xor_ = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_bitwise_xor_scalar_out = extern fn Ptr -> Tensor -> Tensor -> Scalar -> ();
let atg_bitwise_xor_scalar_tensor = extern fn Ptr -> Scalar -> Tensor -> ();
let atg_bitwise_xor_scalar_tensor_out = extern fn Ptr -> Tensor -> Scalar -> Tensor -> ();
let atg_bitwise_xor_tensor = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_bitwise_xor_tensor_ = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_bitwise_xor_tensor_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_blackman_window = extern fn Ptr -> Int -> Int -> Int -> ();
let atg_blackman_window_out = extern fn Ptr -> Tensor -> Int -> ();
let atg_blackman_window_periodic = extern fn Ptr -> Int -> Int -> Int -> Int -> ();
let atg_blackman_window_periodic_out = extern fn Ptr -> Tensor -> Int -> Int -> ();
let atg_block_diag = extern fn Ptr -> Ptr -> Int -> ();
let atg_block_diag_out = extern fn Ptr -> Tensor -> Ptr -> Int -> ();
let atg_bmm = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_bmm_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_broadcast_tensors = extern fn Ptr -> Int -> Ptr;
let atg_broadcast_to = extern fn Ptr -> Tensor -> Ptr -> Int -> ();
let atg_bucketize = extern fn Ptr -> Tensor -> Tensor -> Int -> Int -> ();
let atg_bucketize_scalar = extern fn Ptr -> Scalar -> Tensor -> Int -> Int -> ();
let atg_bucketize_scalar_out = extern fn Ptr -> Tensor -> Scalar -> Tensor -> Int -> Int -> ();
let atg_bucketize_tensor_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> Int -> ();
let atg_can_cast = extern fn Int -> Int -> Int;
let atg_cartesian_prod = extern fn Ptr -> Ptr -> Int -> ();
let atg_cat = extern fn Ptr -> Ptr -> Int -> Int -> ();
let atg_cat_out = extern fn Ptr -> Tensor -> Ptr -> Int -> Int -> ();
let atg_cauchy = extern fn Ptr -> Tensor -> Double -> Double -> ();
let atg_cauchy_ = extern fn Ptr -> Tensor -> Double -> Double -> ();
let atg_cauchy_out = extern fn Ptr -> Tensor -> Tensor -> Double -> Double -> ();
let atg_ccol_indices = extern fn Ptr -> Tensor -> ();
let atg_ccol_indices_copy = extern fn Ptr -> Tensor -> ();
let atg_ccol_indices_copy_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_cdist = extern fn Ptr -> Tensor -> Tensor -> Double -> Int -> Char -> ();
let atg_ceil = extern fn Ptr -> Tensor -> ();
let atg_ceil_ = extern fn Ptr -> Tensor -> ();
let atg_ceil_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_celu = extern fn Ptr -> Tensor -> ();
let atg_celu_ = extern fn Ptr -> Tensor -> ();
let atg_celu_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_chain_matmul = extern fn Ptr -> Ptr -> Int -> ();
let atg_chain_matmul_out = extern fn Ptr -> Tensor -> Ptr -> Int -> ();
let atg_chalf = extern fn Ptr -> Tensor -> ();
let atg_channel_shuffle = extern fn Ptr -> Tensor -> Int -> ();
let atg_channel_shuffle_out = extern fn Ptr -> Tensor -> Tensor -> Int -> ();
let atg_cholesky = extern fn Ptr -> Tensor -> Int -> ();
let atg_cholesky_inverse = extern fn Ptr -> Tensor -> Int -> ();
let atg_cholesky_inverse_out = extern fn Ptr -> Tensor -> Tensor -> Int -> ();
let atg_cholesky_out = extern fn Ptr -> Tensor -> Tensor -> Int -> ();
let atg_cholesky_solve = extern fn Ptr -> Tensor -> Tensor -> Int -> ();
let atg_cholesky_solve_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg_choose_qparams_optimized = extern fn Ptr -> Tensor -> Int -> Int -> Double -> Int -> ();
let atg_chunk = extern fn Tensor -> Int -> Int -> Ptr;
let atg_clamp = extern fn Ptr -> Tensor -> Scalar -> Scalar -> ();
let atg_clamp_ = extern fn Ptr -> Tensor -> Scalar -> Scalar -> ();
let atg_clamp_max = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_clamp_max_ = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_clamp_max_out = extern fn Ptr -> Tensor -> Tensor -> Scalar -> ();
let atg_clamp_max_tensor = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_clamp_max_tensor_ = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_clamp_max_tensor_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_clamp_min = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_clamp_min_ = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_clamp_min_out = extern fn Ptr -> Tensor -> Tensor -> Scalar -> ();
let atg_clamp_min_tensor = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_clamp_min_tensor_ = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_clamp_min_tensor_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_clamp_out = extern fn Ptr -> Tensor -> Tensor -> Scalar -> Scalar -> ();
let atg_clamp_tensor = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_clamp_tensor_ = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_clamp_tensor_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> ();
let atg_clip = extern fn Ptr -> Tensor -> Scalar -> Scalar -> ();
let atg_clip_ = extern fn Ptr -> Tensor -> Scalar -> Scalar -> ();
let atg_clip_out = extern fn Ptr -> Tensor -> Tensor -> Scalar -> Scalar -> ();
let atg_clip_tensor = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_clip_tensor_ = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_clip_tensor_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> ();
let atg_clone = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_coalesce = extern fn Ptr -> Tensor -> ();
let atg_col2im = extern fn Ptr -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> ();
let atg_col2im_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> ();
let atg_col_indices = extern fn Ptr -> Tensor -> ();
let atg_col_indices_copy = extern fn Ptr -> Tensor -> ();
let atg_col_indices_copy_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_column_stack = extern fn Ptr -> Ptr -> Int -> ();
let atg_column_stack_out = extern fn Ptr -> Tensor -> Ptr -> Int -> ();
let atg_combinations = extern fn Ptr -> Tensor -> Int -> Int -> ();
let atg_complex = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_complex_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_concat = extern fn Ptr -> Ptr -> Int -> Int -> ();
let atg_concat_out = extern fn Ptr -> Tensor -> Ptr -> Int -> Int -> ();
let atg_concatenate = extern fn Ptr -> Ptr -> Int -> Int -> ();
let atg_concatenate_out = extern fn Ptr -> Tensor -> Ptr -> Int -> Int -> ();
let atg_conj = extern fn Ptr -> Tensor -> ();
let atg_conj_physical = extern fn Ptr -> Tensor -> ();
let atg_conj_physical_ = extern fn Ptr -> Tensor -> ();
let atg_conj_physical_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_constant_pad_nd = extern fn Ptr -> Tensor -> Ptr -> Int -> ();
let atg_constant_pad_nd_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg_contiguous = extern fn Ptr -> Tensor -> ();
let atg_conv1d = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> ();
let atg_conv1d_padding = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> ();
let atg_conv2d = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> ();
let atg_conv2d_padding = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> ();
let atg_conv3d = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> ();
let atg_conv3d_padding = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> ();
let atg_conv_depthwise3d = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> ();
let atg_conv_depthwise3d_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> ();
let atg_conv_tbc = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg_conv_tbc_backward = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg_conv_tbc_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg_conv_transpose1d = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> Ptr -> Int -> ();
let atg_conv_transpose2d = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> Ptr -> Int -> ();
let atg_conv_transpose3d = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> Ptr -> Int -> ();
let atg_convolution = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> Ptr -> Int -> Int -> ();
let atg_convolution_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> Ptr -> Int -> Int -> ();
let atg_convolution_overrideable = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> Ptr -> Int -> Int -> ();
let atg_convolution_overrideable_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> Ptr -> Int -> Int -> ();
let atg_copy_sparse_to_sparse = extern fn Ptr -> Tensor -> Tensor -> Int -> ();
let atg_copy_sparse_to_sparse_ = extern fn Ptr -> Tensor -> Tensor -> Int -> ();
let atg_copy_sparse_to_sparse_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg_copysign = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_copysign_ = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_copysign_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_copysign_scalar = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_copysign_scalar_ = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_copysign_scalar_out = extern fn Ptr -> Tensor -> Tensor -> Scalar -> ();
let atg_corrcoef = extern fn Ptr -> Tensor -> ();
let atg_cos = extern fn Ptr -> Tensor -> ();
let atg_cos_ = extern fn Ptr -> Tensor -> ();
let atg_cos_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_cosh = extern fn Ptr -> Tensor -> ();
let atg_cosh_ = extern fn Ptr -> Tensor -> ();
let atg_cosh_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_cosine_embedding_loss = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Double -> Int -> ();
let atg_cosine_similarity = extern fn Ptr -> Tensor -> Tensor -> Int -> Double -> ();
let atg_count_nonzero = extern fn Ptr -> Tensor -> Int -> Char -> ();
let atg_count_nonzero_dim_intlist = extern fn Ptr -> Tensor -> Ptr -> Int -> ();
let atg_count_nonzero_dim_intlist_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg_count_nonzero_out = extern fn Ptr -> Tensor -> Tensor -> Int -> Char -> ();
let atg_cov = extern fn Ptr -> Tensor -> Int -> Tensor -> Tensor -> ();
let atg_cross = extern fn Ptr -> Tensor -> Tensor -> Int -> Char -> ();
let atg_cross_entropy_loss = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> Int -> Double -> ();
let atg_cross_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> Char -> ();
let atg_crow_indices = extern fn Ptr -> Tensor -> ();
let atg_crow_indices_copy = extern fn Ptr -> Tensor -> ();
let atg_crow_indices_copy_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_ctc_loss = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Int -> Int -> Int -> ();
let atg_ctc_loss_tensor = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Int -> Int -> ();
let atg_cudnn_affine_grid_generator = extern fn Ptr -> Tensor -> Int -> Int -> Int -> Int -> ();
let atg_cudnn_affine_grid_generator_backward = extern fn Ptr -> Tensor -> Int -> Int -> Int -> Int -> ();
let atg_cudnn_affine_grid_generator_backward_out = extern fn Ptr -> Tensor -> Tensor -> Int -> Int -> Int -> Int -> ();
let atg_cudnn_affine_grid_generator_out = extern fn Ptr -> Tensor -> Tensor -> Int -> Int -> Int -> Int -> ();
let atg_cudnn_batch_norm = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Double -> Double -> ();
let atg_cudnn_batch_norm_backward = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Double -> Tensor -> ();
let atg_cudnn_batch_norm_backward_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Double -> Tensor -> ();
let atg_cudnn_batch_norm_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Double -> Double -> ();
let atg_cudnn_convolution = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> Int -> Int -> Int -> ();
let atg_cudnn_convolution_add_relu = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Scalar -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> ();
let atg_cudnn_convolution_add_relu_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Scalar -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> ();
let atg_cudnn_convolution_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> Int -> Int -> Int -> ();
let atg_cudnn_convolution_relu = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> ();
let atg_cudnn_convolution_relu_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> ();
let atg_cudnn_convolution_transpose = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> Int -> Int -> Int -> ();
let atg_cudnn_convolution_transpose_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> Int -> Int -> Int -> ();
let atg_cudnn_grid_sampler = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_cudnn_grid_sampler_backward = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_cudnn_grid_sampler_backward_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> ();
let atg_cudnn_grid_sampler_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_cudnn_is_acceptable = extern fn Tensor -> Int;
let atg_cummax = extern fn Ptr -> Tensor -> Int -> ();
let atg_cummax_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg_cummaxmin_backward = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg_cummin = extern fn Ptr -> Tensor -> Int -> ();
let atg_cummin_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg_cumprod = extern fn Ptr -> Tensor -> Int -> Int -> ();
let atg_cumprod_ = extern fn Ptr -> Tensor -> Int -> Int -> ();
let atg_cumprod_backward = extern fn Ptr -> Tensor -> Tensor -> Int -> Tensor -> ();
let atg_cumprod_out = extern fn Ptr -> Tensor -> Tensor -> Int -> Int -> ();
let atg_cumsum = extern fn Ptr -> Tensor -> Int -> Int -> ();
let atg_cumsum_ = extern fn Ptr -> Tensor -> Int -> Int -> ();
let atg_cumsum_out = extern fn Ptr -> Tensor -> Tensor -> Int -> Int -> ();
let atg_cumulative_trapezoid = extern fn Ptr -> Tensor -> Int -> ();
let atg_cumulative_trapezoid_x = extern fn Ptr -> Tensor -> Tensor -> Int -> ();
let atg_data = extern fn Ptr -> Tensor -> ();
let atg_deg2rad = extern fn Ptr -> Tensor -> ();
let atg_deg2rad_ = extern fn Ptr -> Tensor -> ();
let atg_deg2rad_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_dense_dim = extern fn Tensor -> Int;
let atg_dequantize = extern fn Ptr -> Tensor -> ();
let atg_dequantize_self_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_dequantize_tensors = extern fn Ptr -> Int -> Ptr;
let atg_dequantize_tensors_out = extern fn Ptr -> Int -> Ptr -> Int -> ();
let atg_det = extern fn Ptr -> Tensor -> ();
let atg_detach = extern fn Ptr -> Tensor -> ();
let atg_detach_ = extern fn Ptr -> Tensor -> ();
let atg_detach_copy = extern fn Ptr -> Tensor -> ();
let atg_detach_copy_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_diag = extern fn Ptr -> Tensor -> Int -> ();
let atg_diag_embed = extern fn Ptr -> Tensor -> Int -> Int -> Int -> ();
let atg_diag_embed_out = extern fn Ptr -> Tensor -> Tensor -> Int -> Int -> Int -> ();
let atg_diag_out = extern fn Ptr -> Tensor -> Tensor -> Int -> ();
let atg_diagflat = extern fn Ptr -> Tensor -> Int -> ();
let atg_diagonal = extern fn Ptr -> Tensor -> Int -> Int -> Int -> ();
let atg_diagonal_backward = extern fn Ptr -> Tensor -> Ptr -> Int -> Int -> Int -> Int -> ();
let atg_diagonal_backward_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Int -> Int -> Int -> ();
let atg_diagonal_copy = extern fn Ptr -> Tensor -> Int -> Int -> Int -> ();
let atg_diagonal_copy_out = extern fn Ptr -> Tensor -> Tensor -> Int -> Int -> Int -> ();
let atg_diagonal_scatter = extern fn Ptr -> Tensor -> Tensor -> Int -> Int -> Int -> ();
let atg_diagonal_scatter_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> Int -> Int -> ();
let atg_diff = extern fn Ptr -> Tensor -> Int -> Int -> Tensor -> Tensor -> ();
let atg_diff_out = extern fn Ptr -> Tensor -> Tensor -> Int -> Int -> Tensor -> Tensor -> ();
let atg_digamma = extern fn Ptr -> Tensor -> ();
let atg_digamma_ = extern fn Ptr -> Tensor -> ();
let atg_digamma_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_dist = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_dist_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_div = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_div_ = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_div_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_div_out_mode = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg_div_scalar = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_div_scalar_ = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_div_scalar_mode = extern fn Ptr -> Tensor -> Scalar -> Ptr -> Int -> ();
let atg_div_scalar_mode_ = extern fn Ptr -> Tensor -> Scalar -> Ptr -> Int -> ();
let atg_div_scalar_mode_out = extern fn Ptr -> Tensor -> Tensor -> Scalar -> Ptr -> Int -> ();
let atg_div_scalar_out = extern fn Ptr -> Tensor -> Tensor -> Scalar -> ();
let atg_div_tensor_mode = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg_div_tensor_mode_ = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg_divide = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_divide_ = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_divide_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_divide_out_mode = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg_divide_scalar = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_divide_scalar_ = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_divide_scalar_mode = extern fn Ptr -> Tensor -> Scalar -> Ptr -> Int -> ();
let atg_divide_scalar_mode_ = extern fn Ptr -> Tensor -> Scalar -> Ptr -> Int -> ();
let atg_divide_tensor_mode = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg_divide_tensor_mode_ = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg_dot = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_dot_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_dropout = extern fn Ptr -> Tensor -> Double -> Int -> ();
let atg_dropout_ = extern fn Ptr -> Tensor -> Double -> Int -> ();
let atg_dsplit = extern fn Tensor -> Int -> Ptr;
let atg_dsplit_array = extern fn Tensor -> Ptr -> Int -> Ptr;
let atg_dstack = extern fn Ptr -> Ptr -> Int -> ();
let atg_dstack_out = extern fn Ptr -> Tensor -> Ptr -> Int -> ();
let atg_einsum = extern fn Ptr -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> ();
let atg_elu = extern fn Ptr -> Tensor -> ();
let atg_elu_ = extern fn Ptr -> Tensor -> ();
let atg_elu_backward = extern fn Ptr -> Tensor -> Scalar -> Scalar -> Scalar -> Int -> Tensor -> ();
let atg_elu_backward_grad_input = extern fn Ptr -> Tensor -> Tensor -> Scalar -> Scalar -> Scalar -> Int -> Tensor -> ();
let atg_elu_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_embedding = extern fn Ptr -> Tensor -> Tensor -> Int -> Int -> Int -> ();
let atg_embedding_backward = extern fn Ptr -> Tensor -> Tensor -> Int -> Int -> Int -> Int -> ();
let atg_embedding_bag = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> Int -> Int -> Tensor -> Int -> ();
let atg_embedding_bag_padding_idx = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> Int -> Int -> Tensor -> Int -> Int -> Char -> ();
let atg_embedding_dense_backward = extern fn Ptr -> Tensor -> Tensor -> Int -> Int -> Int -> ();
let atg_embedding_dense_backward_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> Int -> Int -> ();
let atg_embedding_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> Int -> Int -> ();
let atg_embedding_renorm = extern fn Ptr -> Tensor -> Tensor -> Double -> Double -> ();
let atg_embedding_renorm_ = extern fn Ptr -> Tensor -> Tensor -> Double -> Double -> ();
let atg_embedding_renorm_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Double -> Double -> ();
let atg_embedding_sparse_backward = extern fn Ptr -> Tensor -> Tensor -> Int -> Int -> Int -> ();
let atg_empty = extern fn Ptr -> Ptr -> Int -> Int -> Int -> ();
let atg_empty_like = extern fn Ptr -> Tensor -> ();
let atg_empty_like_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_empty_out = extern fn Ptr -> Tensor -> Ptr -> Int -> ();
let atg_empty_permuted = extern fn Ptr -> Ptr -> Int -> Ptr -> Int -> Int -> Int -> ();
let atg_empty_permuted_out = extern fn Ptr -> Tensor -> Ptr -> Int -> Ptr -> Int -> ();
let atg_empty_quantized = extern fn Ptr -> Ptr -> Int -> Tensor -> Int -> Int -> ();
let atg_empty_quantized_out = extern fn Ptr -> Tensor -> Ptr -> Int -> Tensor -> ();
let atg_empty_strided = extern fn Ptr -> Ptr -> Int -> Ptr -> Int -> Int -> Int -> ();
let atg_empty_strided_out = extern fn Ptr -> Tensor -> Ptr -> Int -> Ptr -> Int -> ();
let atg_eq = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_eq_ = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_eq_scalar_out = extern fn Ptr -> Tensor -> Tensor -> Scalar -> ();
let atg_eq_tensor = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_eq_tensor_ = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_eq_tensor_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_equal = extern fn Tensor -> Tensor -> Int;
let atg_erf = extern fn Ptr -> Tensor -> ();
let atg_erf_ = extern fn Ptr -> Tensor -> ();
let atg_erf_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_erfc = extern fn Ptr -> Tensor -> ();
let atg_erfc_ = extern fn Ptr -> Tensor -> ();
let atg_erfc_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_erfinv = extern fn Ptr -> Tensor -> ();
let atg_erfinv_ = extern fn Ptr -> Tensor -> ();
let atg_erfinv_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_exp = extern fn Ptr -> Tensor -> ();
let atg_exp2 = extern fn Ptr -> Tensor -> ();
let atg_exp2_ = extern fn Ptr -> Tensor -> ();
let atg_exp2_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_exp_ = extern fn Ptr -> Tensor -> ();
let atg_exp_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_expand = extern fn Ptr -> Tensor -> Ptr -> Int -> Int -> ();
let atg_expand_as = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_expand_copy = extern fn Ptr -> Tensor -> Ptr -> Int -> Int -> ();
let atg_expand_copy_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Int -> ();
let atg_expm1 = extern fn Ptr -> Tensor -> ();
let atg_expm1_ = extern fn Ptr -> Tensor -> ();
let atg_expm1_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_exponential = extern fn Ptr -> Tensor -> Double -> ();
let atg_exponential_ = extern fn Ptr -> Tensor -> Double -> ();
let atg_exponential_out = extern fn Ptr -> Tensor -> Tensor -> Double -> ();
let atg_eye = extern fn Ptr -> Int -> Int -> Int -> ();
let atg_eye_m = extern fn Ptr -> Int -> Int -> Int -> Int -> ();
let atg_eye_m_out = extern fn Ptr -> Tensor -> Int -> Int -> ();
let atg_eye_out = extern fn Ptr -> Tensor -> Int -> ();
let atg_fake_quantize_per_channel_affine = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> Int -> Int -> ();
let atg_fake_quantize_per_channel_affine_cachemask = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> Int -> Int -> ();
let atg_fake_quantize_per_channel_affine_cachemask_backward = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_fake_quantize_per_channel_affine_cachemask_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Int -> Int -> ();
let atg_fake_quantize_per_tensor_affine = extern fn Ptr -> Tensor -> Double -> Int -> Int -> Int -> ();
let atg_fake_quantize_per_tensor_affine_cachemask = extern fn Ptr -> Tensor -> Double -> Int -> Int -> Int -> ();
let atg_fake_quantize_per_tensor_affine_cachemask_backward = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_fake_quantize_per_tensor_affine_cachemask_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Double -> Int -> Int -> Int -> ();
let atg_fake_quantize_per_tensor_affine_tensor_qparams = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> Int -> ();
let atg_fbgemm_linear_fp16_weight = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_fbgemm_linear_fp16_weight_fp32_activation = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_fbgemm_linear_int8_weight = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Scalar -> Scalar -> Tensor -> ();
let atg_fbgemm_linear_int8_weight_fp32_activation = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Scalar -> Scalar -> Tensor -> ();
let atg_fbgemm_pack_gemm_matrix_fp16 = extern fn Ptr -> Tensor -> ();
let atg_fbgemm_pack_quantized_matrix = extern fn Ptr -> Tensor -> ();
let atg_fbgemm_pack_quantized_matrix_kn = extern fn Ptr -> Tensor -> Int -> Int -> ();
let atg_feature_alpha_dropout = extern fn Ptr -> Tensor -> Double -> Int -> ();
let atg_feature_alpha_dropout_ = extern fn Ptr -> Tensor -> Double -> Int -> ();
let atg_feature_dropout = extern fn Ptr -> Tensor -> Double -> Int -> ();
let atg_feature_dropout_ = extern fn Ptr -> Tensor -> Double -> Int -> ();
let atg_fft_fft = extern fn Ptr -> Tensor -> Int -> Char -> Int -> Ptr -> Int -> ();
let atg_fft_fft2 = extern fn Ptr -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> ();
let atg_fft_fft2_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> ();
let atg_fft_fft_out = extern fn Ptr -> Tensor -> Tensor -> Int -> Char -> Int -> Ptr -> Int -> ();
let atg_fft_fftfreq = extern fn Ptr -> Int -> Double -> Int -> Int -> ();
let atg_fft_fftfreq_out = extern fn Ptr -> Tensor -> Int -> Double -> ();
let atg_fft_fftn = extern fn Ptr -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> ();
let atg_fft_fftn_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> ();
let atg_fft_fftshift = extern fn Ptr -> Tensor -> Ptr -> Int -> ();
let atg_fft_hfft = extern fn Ptr -> Tensor -> Int -> Char -> Int -> Ptr -> Int -> ();
let atg_fft_hfft2 = extern fn Ptr -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> ();
let atg_fft_hfft2_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> ();
let atg_fft_hfft_out = extern fn Ptr -> Tensor -> Tensor -> Int -> Char -> Int -> Ptr -> Int -> ();
let atg_fft_hfftn = extern fn Ptr -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> ();
let atg_fft_hfftn_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> ();
let atg_fft_ifft = extern fn Ptr -> Tensor -> Int -> Char -> Int -> Ptr -> Int -> ();
let atg_fft_ifft2 = extern fn Ptr -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> ();
let atg_fft_ifft2_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> ();
let atg_fft_ifft_out = extern fn Ptr -> Tensor -> Tensor -> Int -> Char -> Int -> Ptr -> Int -> ();
let atg_fft_ifftn = extern fn Ptr -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> ();
let atg_fft_ifftn_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> ();
let atg_fft_ifftshift = extern fn Ptr -> Tensor -> Ptr -> Int -> ();
let atg_fft_ihfft = extern fn Ptr -> Tensor -> Int -> Char -> Int -> Ptr -> Int -> ();
let atg_fft_ihfft2 = extern fn Ptr -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> ();
let atg_fft_ihfft2_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> ();
let atg_fft_ihfft_out = extern fn Ptr -> Tensor -> Tensor -> Int -> Char -> Int -> Ptr -> Int -> ();
let atg_fft_ihfftn = extern fn Ptr -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> ();
let atg_fft_ihfftn_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> ();
let atg_fft_irfft = extern fn Ptr -> Tensor -> Int -> Char -> Int -> Ptr -> Int -> ();
let atg_fft_irfft2 = extern fn Ptr -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> ();
let atg_fft_irfft2_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> ();
let atg_fft_irfft_out = extern fn Ptr -> Tensor -> Tensor -> Int -> Char -> Int -> Ptr -> Int -> ();
let atg_fft_irfftn = extern fn Ptr -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> ();
let atg_fft_irfftn_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> ();
let atg_fft_rfft = extern fn Ptr -> Tensor -> Int -> Char -> Int -> Ptr -> Int -> ();
let atg_fft_rfft2 = extern fn Ptr -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> ();
let atg_fft_rfft2_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> ();
let atg_fft_rfft_out = extern fn Ptr -> Tensor -> Tensor -> Int -> Char -> Int -> Ptr -> Int -> ();
let atg_fft_rfftfreq = extern fn Ptr -> Int -> Double -> Int -> Int -> ();
let atg_fft_rfftfreq_out = extern fn Ptr -> Tensor -> Int -> Double -> ();
let atg_fft_rfftn = extern fn Ptr -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> ();
let atg_fft_rfftn_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> ();
let atg_fill = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_fill_ = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_fill_diagonal_ = extern fn Ptr -> Tensor -> Scalar -> Int -> ();
let atg_fill_scalar_out = extern fn Ptr -> Tensor -> Tensor -> Scalar -> ();
let atg_fill_tensor = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_fill_tensor_ = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_fill_tensor_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_fix = extern fn Ptr -> Tensor -> ();
let atg_fix_ = extern fn Ptr -> Tensor -> ();
let atg_fix_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_flatten = extern fn Ptr -> Tensor -> Int -> Int -> ();
let atg_flatten_dense_tensors = extern fn Ptr -> Ptr -> Int -> ();
let atg_flip = extern fn Ptr -> Tensor -> Ptr -> Int -> ();
let atg_flip_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg_fliplr = extern fn Ptr -> Tensor -> ();
let atg_flipud = extern fn Ptr -> Tensor -> ();
let atg_float_power = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_float_power_ = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_float_power_scalar = extern fn Ptr -> Scalar -> Tensor -> ();
let atg_float_power_scalar_out = extern fn Ptr -> Tensor -> Scalar -> Tensor -> ();
let atg_float_power_tensor_ = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_float_power_tensor_scalar = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_float_power_tensor_scalar_out = extern fn Ptr -> Tensor -> Tensor -> Scalar -> ();
let atg_float_power_tensor_tensor_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_floor = extern fn Ptr -> Tensor -> ();
let atg_floor_ = extern fn Ptr -> Tensor -> ();
let atg_floor_divide = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_floor_divide_ = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_floor_divide_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_floor_divide_scalar = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_floor_divide_scalar_ = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_floor_divide_scalar_out = extern fn Ptr -> Tensor -> Tensor -> Scalar -> ();
let atg_floor_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_fmax = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_fmax_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_fmin = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_fmin_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_fmod = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_fmod_ = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_fmod_scalar_out = extern fn Ptr -> Tensor -> Tensor -> Scalar -> ();
let atg_fmod_tensor = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_fmod_tensor_ = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_fmod_tensor_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_frac = extern fn Ptr -> Tensor -> ();
let atg_frac_ = extern fn Ptr -> Tensor -> ();
let atg_frac_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_fractional_max_pool2d = extern fn Ptr -> Tensor -> Ptr -> Int -> Ptr -> Int -> Tensor -> ();
let atg_fractional_max_pool2d_backward = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Tensor -> ();
let atg_fractional_max_pool2d_backward_grad_input = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Tensor -> ();
let atg_fractional_max_pool2d_output = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Tensor -> ();
let atg_fractional_max_pool3d = extern fn Ptr -> Tensor -> Ptr -> Int -> Ptr -> Int -> Tensor -> ();
let atg_fractional_max_pool3d_backward = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Tensor -> ();
let atg_fractional_max_pool3d_backward_grad_input = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Tensor -> ();
let atg_fractional_max_pool3d_output = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Tensor -> ();
let atg_frexp = extern fn Ptr -> Tensor -> ();
let atg_frexp_tensor_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_frobenius_norm = extern fn Ptr -> Tensor -> Ptr -> Int -> Int -> ();
let atg_frobenius_norm_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Int -> ();
let atg_from_file = extern fn Ptr -> Ptr -> Int -> Int -> Int -> Char -> Int -> Int -> ();
let atg_from_file_out = extern fn Ptr -> Tensor -> Ptr -> Int -> Int -> Int -> Char -> ();
let atg_full = extern fn Ptr -> Ptr -> Int -> Scalar -> Int -> Int -> ();
let atg_full_like = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_full_like_out = extern fn Ptr -> Tensor -> Tensor -> Scalar -> ();
let atg_full_out = extern fn Ptr -> Tensor -> Ptr -> Int -> Scalar -> ();
let atg_fused_moving_avg_obs_fake_quant = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Double -> Int -> Int -> Int -> Int -> Int -> ();
let atg_gather = extern fn Ptr -> Tensor -> Int -> Tensor -> Int -> ();
let atg_gather_backward = extern fn Ptr -> Tensor -> Tensor -> Int -> Tensor -> Int -> ();
let atg_gather_out = extern fn Ptr -> Tensor -> Tensor -> Int -> Tensor -> Int -> ();
let atg_gcd = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_gcd_ = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_gcd_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_ge = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_ge_ = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_ge_scalar_out = extern fn Ptr -> Tensor -> Tensor -> Scalar -> ();
let atg_ge_tensor = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_ge_tensor_ = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_ge_tensor_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_gelu = extern fn Ptr -> Tensor -> Ptr -> Int -> ();
let atg_gelu_ = extern fn Ptr -> Tensor -> Ptr -> Int -> ();
let atg_gelu_backward = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg_gelu_backward_grad_input = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg_gelu_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg_geometric = extern fn Ptr -> Tensor -> Double -> ();
let atg_geometric_ = extern fn Ptr -> Tensor -> Double -> ();
let atg_geometric_out = extern fn Ptr -> Tensor -> Tensor -> Double -> ();
let atg_geqrf = extern fn Ptr -> Tensor -> ();
let atg_geqrf_a = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_ger = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_ger_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_glu = extern fn Ptr -> Tensor -> Int -> ();
let atg_glu_backward = extern fn Ptr -> Tensor -> Tensor -> Int -> ();
let atg_glu_backward_grad_input = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg_glu_backward_jvp = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg_glu_backward_jvp_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg_glu_jvp = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg_glu_jvp_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg_glu_out = extern fn Ptr -> Tensor -> Tensor -> Int -> ();
let atg_grad = extern fn Ptr -> Tensor -> ();
let atg_greater = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_greater_ = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_greater_equal = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_greater_equal_ = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_greater_equal_scalar_out = extern fn Ptr -> Tensor -> Tensor -> Scalar -> ();
let atg_greater_equal_tensor = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_greater_equal_tensor_ = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_greater_equal_tensor_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_greater_scalar_out = extern fn Ptr -> Tensor -> Tensor -> Scalar -> ();
let atg_greater_tensor = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_greater_tensor_ = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_greater_tensor_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_grid_sampler = extern fn Ptr -> Tensor -> Tensor -> Int -> Int -> Int -> ();
let atg_grid_sampler_2d = extern fn Ptr -> Tensor -> Tensor -> Int -> Int -> Int -> ();
let atg_grid_sampler_2d_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> Int -> Int -> ();
let atg_grid_sampler_3d = extern fn Ptr -> Tensor -> Tensor -> Int -> Int -> Int -> ();
let atg_grid_sampler_3d_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> Int -> Int -> ();
let atg_group_norm = extern fn Ptr -> Tensor -> Int -> Tensor -> Tensor -> Double -> Int -> ();
let atg_gru = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Int -> Int -> Double -> Int -> Int -> Int -> ();
let atg_gru_cell = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> ();
let atg_gru_data = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Int -> Int -> Double -> Int -> Int -> ();
let atg_gt = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_gt_ = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_gt_scalar_out = extern fn Ptr -> Tensor -> Tensor -> Scalar -> ();
let atg_gt_tensor = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_gt_tensor_ = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_gt_tensor_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_hamming_window = extern fn Ptr -> Int -> Int -> Int -> ();
let atg_hamming_window_out = extern fn Ptr -> Tensor -> Int -> ();
let atg_hamming_window_periodic = extern fn Ptr -> Int -> Int -> Int -> Int -> ();
let atg_hamming_window_periodic_alpha = extern fn Ptr -> Int -> Int -> Double -> Int -> Int -> ();
let atg_hamming_window_periodic_alpha_beta = extern fn Ptr -> Int -> Int -> Double -> Double -> Int -> Int -> ();
let atg_hamming_window_periodic_alpha_beta_out = extern fn Ptr -> Tensor -> Int -> Int -> Double -> Double -> ();
let atg_hamming_window_periodic_alpha_out = extern fn Ptr -> Tensor -> Int -> Int -> Double -> ();
let atg_hamming_window_periodic_out = extern fn Ptr -> Tensor -> Int -> Int -> ();
let atg_hann_window = extern fn Ptr -> Int -> Int -> Int -> ();
let atg_hann_window_out = extern fn Ptr -> Tensor -> Int -> ();
let atg_hann_window_periodic = extern fn Ptr -> Int -> Int -> Int -> Int -> ();
let atg_hann_window_periodic_out = extern fn Ptr -> Tensor -> Int -> Int -> ();
let atg_hardshrink = extern fn Ptr -> Tensor -> ();
let atg_hardshrink_backward = extern fn Ptr -> Tensor -> Tensor -> Scalar -> ();
let atg_hardshrink_backward_grad_input = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Scalar -> ();
let atg_hardshrink_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_hardsigmoid = extern fn Ptr -> Tensor -> ();
let atg_hardsigmoid_ = extern fn Ptr -> Tensor -> ();
let atg_hardsigmoid_backward = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_hardsigmoid_backward_grad_input = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_hardsigmoid_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_hardswish = extern fn Ptr -> Tensor -> ();
let atg_hardswish_ = extern fn Ptr -> Tensor -> ();
let atg_hardswish_backward = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_hardswish_backward_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_hardswish_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_hardtanh = extern fn Ptr -> Tensor -> ();
let atg_hardtanh_ = extern fn Ptr -> Tensor -> ();
let atg_hardtanh_backward = extern fn Ptr -> Tensor -> Tensor -> Scalar -> Scalar -> ();
let atg_hardtanh_backward_grad_input = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Scalar -> Scalar -> ();
let atg_hardtanh_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_heaviside = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_heaviside_ = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_heaviside_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_hinge_embedding_loss = extern fn Ptr -> Tensor -> Tensor -> Double -> Int -> ();
let atg_histc = extern fn Ptr -> Tensor -> Int -> ();
let atg_histc_out = extern fn Ptr -> Tensor -> Tensor -> Int -> ();
let atg_histogram = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg_histogram_bin_ct = extern fn Ptr -> Tensor -> Int -> Ptr -> Int -> Tensor -> Int -> ();
let atg_histogram_bin_ct_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> Ptr -> Int -> Tensor -> Int -> ();
let atg_histogram_bins_tensor_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg_hsplit = extern fn Tensor -> Int -> Ptr;
let atg_hsplit_array = extern fn Tensor -> Ptr -> Int -> Ptr;
let atg_hspmm = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_hspmm_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_hstack = extern fn Ptr -> Ptr -> Int -> ();
let atg_hstack_out = extern fn Ptr -> Tensor -> Ptr -> Int -> ();
let atg_huber_loss = extern fn Ptr -> Tensor -> Tensor -> Int -> Double -> ();
let atg_huber_loss_backward = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> Double -> ();
let atg_huber_loss_backward_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Double -> ();
let atg_huber_loss_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> Double -> ();
let atg_hypot = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_hypot_ = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_hypot_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_i0 = extern fn Ptr -> Tensor -> ();
let atg_i0_ = extern fn Ptr -> Tensor -> ();
let atg_i0_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_igamma = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_igamma_ = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_igamma_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_igammac = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_igammac_ = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_igammac_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_im2col = extern fn Ptr -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> ();
let atg_im2col_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> ();
let atg_imag = extern fn Ptr -> Tensor -> ();
let atg_index = extern fn Ptr -> Tensor -> Ptr -> Int -> ();
let atg_index_add = extern fn Ptr -> Tensor -> Int -> Tensor -> Tensor -> ();
let atg_index_add_ = extern fn Ptr -> Tensor -> Int -> Tensor -> Tensor -> ();
let atg_index_add_out = extern fn Ptr -> Tensor -> Tensor -> Int -> Tensor -> Tensor -> ();
let atg_index_copy = extern fn Ptr -> Tensor -> Int -> Tensor -> Tensor -> ();
let atg_index_copy_ = extern fn Ptr -> Tensor -> Int -> Tensor -> Tensor -> ();
let atg_index_copy_out = extern fn Ptr -> Tensor -> Tensor -> Int -> Tensor -> Tensor -> ();
let atg_index_fill = extern fn Ptr -> Tensor -> Int -> Tensor -> Scalar -> ();
let atg_index_fill_ = extern fn Ptr -> Tensor -> Int -> Tensor -> Scalar -> ();
let atg_index_fill_int_scalar_out = extern fn Ptr -> Tensor -> Tensor -> Int -> Tensor -> Scalar -> ();
let atg_index_fill_int_tensor = extern fn Ptr -> Tensor -> Int -> Tensor -> Tensor -> ();
let atg_index_fill_int_tensor_ = extern fn Ptr -> Tensor -> Int -> Tensor -> Tensor -> ();
let atg_index_fill_int_tensor_out = extern fn Ptr -> Tensor -> Tensor -> Int -> Tensor -> Tensor -> ();
let atg_index_put = extern fn Ptr -> Tensor -> Ptr -> Int -> Tensor -> Int -> ();
let atg_index_put_ = extern fn Ptr -> Tensor -> Ptr -> Int -> Tensor -> Int -> ();
let atg_index_put_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Tensor -> Int -> ();
let atg_index_reduce = extern fn Ptr -> Tensor -> Int -> Tensor -> Tensor -> Ptr -> Int -> Int -> ();
let atg_index_reduce_ = extern fn Ptr -> Tensor -> Int -> Tensor -> Tensor -> Ptr -> Int -> Int -> ();
let atg_index_reduce_out = extern fn Ptr -> Tensor -> Tensor -> Int -> Tensor -> Tensor -> Ptr -> Int -> Int -> ();
let atg_index_select = extern fn Ptr -> Tensor -> Int -> Tensor -> ();
let atg_index_select_backward = extern fn Ptr -> Tensor -> Ptr -> Int -> Int -> Tensor -> ();
let atg_index_select_out = extern fn Ptr -> Tensor -> Tensor -> Int -> Tensor -> ();
let atg_index_tensor_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg_indices = extern fn Ptr -> Tensor -> ();
let atg_indices_copy = extern fn Ptr -> Tensor -> ();
let atg_indices_copy_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_infinitely_differentiable_gelu_backward = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_inner = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_inner_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_instance_norm = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Double -> Double -> Int -> ();
let atg_int_repr = extern fn Ptr -> Tensor -> ();
let atg_int_repr_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_inverse = extern fn Ptr -> Tensor -> ();
let atg_inverse_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_is_coalesced = extern fn Tensor -> Int;
let atg_is_complex = extern fn Tensor -> Int;
let atg_is_conj = extern fn Tensor -> Int;
let atg_is_distributed = extern fn Tensor -> Int;
let atg_is_floating_point = extern fn Tensor -> Int;
let atg_is_inference = extern fn Tensor -> Int;
let atg_is_leaf = extern fn Tensor -> Int;
let atg_is_neg = extern fn Tensor -> Int;
let atg_is_nonzero = extern fn Tensor -> Int;
let atg_is_pinned = extern fn Tensor -> Int -> Int;
let atg_is_same_size = extern fn Tensor -> Tensor -> Int;
let atg_is_set_to = extern fn Tensor -> Tensor -> Int;
let atg_is_signed = extern fn Tensor -> Int;
let atg_is_vulkan_available = extern fn () -> Int;
let atg_isclose = extern fn Ptr -> Tensor -> Tensor -> Double -> Double -> Int -> ();
let atg_isfinite = extern fn Ptr -> Tensor -> ();
let atg_isin = extern fn Ptr -> Tensor -> Tensor -> Int -> Int -> ();
let atg_isin_scalar_tensor = extern fn Ptr -> Scalar -> Tensor -> Int -> Int -> ();
let atg_isin_scalar_tensor_out = extern fn Ptr -> Tensor -> Scalar -> Tensor -> Int -> Int -> ();
let atg_isin_tensor_scalar = extern fn Ptr -> Tensor -> Scalar -> Int -> Int -> ();
let atg_isin_tensor_scalar_out = extern fn Ptr -> Tensor -> Tensor -> Scalar -> Int -> Int -> ();
let atg_isin_tensor_tensor_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> Int -> ();
let atg_isinf = extern fn Ptr -> Tensor -> ();
let atg_isinf_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_isnan = extern fn Ptr -> Tensor -> ();
let atg_isnan_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_isneginf = extern fn Ptr -> Tensor -> ();
let atg_isneginf_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_isposinf = extern fn Ptr -> Tensor -> ();
let atg_isposinf_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_isreal = extern fn Ptr -> Tensor -> ();
let atg_istft = extern fn Ptr -> Tensor -> Int -> Int -> Char -> Int -> Char -> Tensor -> Int -> Int -> Int -> Int -> Char -> Int -> ();
let atg_kaiser_window = extern fn Ptr -> Int -> Int -> Int -> ();
let atg_kaiser_window_beta = extern fn Ptr -> Int -> Int -> Double -> Int -> Int -> ();
let atg_kaiser_window_beta_out = extern fn Ptr -> Tensor -> Int -> Int -> Double -> ();
let atg_kaiser_window_out = extern fn Ptr -> Tensor -> Int -> ();
let atg_kaiser_window_periodic = extern fn Ptr -> Int -> Int -> Int -> Int -> ();
let atg_kaiser_window_periodic_out = extern fn Ptr -> Tensor -> Int -> Int -> ();
let atg_kl_div = extern fn Ptr -> Tensor -> Tensor -> Int -> Int -> ();
let atg_kron = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_kron_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_kthvalue = extern fn Ptr -> Tensor -> Int -> Int -> Int -> ();
let atg_kthvalue_values = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> Int -> Int -> ();
let atg_l1_loss = extern fn Ptr -> Tensor -> Tensor -> Int -> ();
let atg_layer_norm = extern fn Ptr -> Tensor -> Ptr -> Int -> Tensor -> Tensor -> Double -> Int -> ();
let atg_lcm = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_lcm_ = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_lcm_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_ldexp = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_ldexp_ = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_ldexp_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_le = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_le_ = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_le_scalar_out = extern fn Ptr -> Tensor -> Tensor -> Scalar -> ();
let atg_le_tensor = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_le_tensor_ = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_le_tensor_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_leaky_relu = extern fn Ptr -> Tensor -> ();
let atg_leaky_relu_ = extern fn Ptr -> Tensor -> ();
let atg_leaky_relu_backward = extern fn Ptr -> Tensor -> Tensor -> Scalar -> Int -> ();
let atg_leaky_relu_backward_grad_input = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Scalar -> Int -> ();
let atg_leaky_relu_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_lerp = extern fn Ptr -> Tensor -> Tensor -> Scalar -> ();
let atg_lerp_ = extern fn Ptr -> Tensor -> Tensor -> Scalar -> ();
let atg_lerp_scalar_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Scalar -> ();
let atg_lerp_tensor = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_lerp_tensor_ = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_lerp_tensor_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> ();
let atg_less = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_less_ = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_less_equal = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_less_equal_ = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_less_equal_scalar_out = extern fn Ptr -> Tensor -> Tensor -> Scalar -> ();
let atg_less_equal_tensor = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_less_equal_tensor_ = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_less_equal_tensor_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_less_scalar_out = extern fn Ptr -> Tensor -> Tensor -> Scalar -> ();
let atg_less_tensor = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_less_tensor_ = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_less_tensor_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_lgamma = extern fn Ptr -> Tensor -> ();
let atg_lgamma_ = extern fn Ptr -> Tensor -> ();
let atg_lgamma_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_lift = extern fn Ptr -> Tensor -> ();
let atg_lift_fresh = extern fn Ptr -> Tensor -> ();
let atg_lift_fresh_copy = extern fn Ptr -> Tensor -> ();
let atg_lift_fresh_copy_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_lift_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_linalg_cholesky = extern fn Ptr -> Tensor -> Int -> ();
let atg_linalg_cholesky_ex = extern fn Ptr -> Tensor -> Int -> Int -> ();
let atg_linalg_cholesky_ex_l = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> Int -> ();
let atg_linalg_cholesky_out = extern fn Ptr -> Tensor -> Tensor -> Int -> ();
let atg_linalg_cond = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_linalg_cond_out = extern fn Ptr -> Tensor -> Tensor -> Scalar -> ();
let atg_linalg_cond_p_str = extern fn Ptr -> Tensor -> Ptr -> Int -> ();
let atg_linalg_cond_p_str_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg_linalg_cross = extern fn Ptr -> Tensor -> Tensor -> Int -> ();
let atg_linalg_cross_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg_linalg_det = extern fn Ptr -> Tensor -> ();
let atg_linalg_det_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_linalg_diagonal = extern fn Ptr -> Tensor -> Int -> Int -> Int -> ();
let atg_linalg_eig = extern fn Ptr -> Tensor -> ();
let atg_linalg_eig_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_linalg_eigh = extern fn Ptr -> Tensor -> Ptr -> Int -> ();
let atg_linalg_eigh_eigvals = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg_linalg_eigvals = extern fn Ptr -> Tensor -> ();
let atg_linalg_eigvals_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_linalg_eigvalsh = extern fn Ptr -> Tensor -> Ptr -> Int -> ();
let atg_linalg_eigvalsh_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg_linalg_householder_product = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_linalg_householder_product_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_linalg_inv = extern fn Ptr -> Tensor -> ();
let atg_linalg_inv_ex = extern fn Ptr -> Tensor -> Int -> ();
let atg_linalg_inv_ex_inverse = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg_linalg_inv_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_linalg_ldl_factor = extern fn Ptr -> Tensor -> Int -> ();
let atg_linalg_ldl_factor_ex = extern fn Ptr -> Tensor -> Int -> Int -> ();
let atg_linalg_ldl_factor_ex_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Int -> ();
let atg_linalg_ldl_factor_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg_linalg_ldl_solve = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg_linalg_ldl_solve_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg_linalg_lstsq = extern fn Ptr -> Tensor -> Tensor -> Double -> Char -> Ptr -> Int -> ();
let atg_linalg_lstsq_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Double -> Char -> Ptr -> Int -> ();
let atg_linalg_lu = extern fn Ptr -> Tensor -> Int -> ();
let atg_linalg_lu_factor = extern fn Ptr -> Tensor -> Int -> ();
let atg_linalg_lu_factor_ex = extern fn Ptr -> Tensor -> Int -> Int -> ();
let atg_linalg_lu_factor_ex_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Int -> ();
let atg_linalg_lu_factor_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg_linalg_lu_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg_linalg_lu_solve = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> Int -> ();
let atg_linalg_lu_solve_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Int -> ();
let atg_linalg_matmul = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_linalg_matmul_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_linalg_matrix_exp = extern fn Ptr -> Tensor -> ();
let atg_linalg_matrix_exp_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_linalg_matrix_power = extern fn Ptr -> Tensor -> Int -> ();
let atg_linalg_matrix_power_out = extern fn Ptr -> Tensor -> Tensor -> Int -> ();
let atg_linalg_matrix_rank = extern fn Ptr -> Tensor -> Double -> Int -> ();
let atg_linalg_matrix_rank_atol_rtol_float = extern fn Ptr -> Tensor -> Double -> Char -> Double -> Char -> Int -> ();
let atg_linalg_matrix_rank_atol_rtol_float_out = extern fn Ptr -> Tensor -> Tensor -> Double -> Char -> Double -> Char -> Int -> ();
let atg_linalg_matrix_rank_atol_rtol_tensor = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg_linalg_matrix_rank_atol_rtol_tensor_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg_linalg_matrix_rank_out = extern fn Ptr -> Tensor -> Tensor -> Double -> Int -> ();
let atg_linalg_matrix_rank_out_tol_tensor = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg_linalg_matrix_rank_tol_tensor = extern fn Ptr -> Tensor -> Tensor -> Int -> ();
let atg_linalg_multi_dot = extern fn Ptr -> Ptr -> Int -> ();
let atg_linalg_multi_dot_out = extern fn Ptr -> Tensor -> Ptr -> Int -> ();
let atg_linalg_norm = extern fn Ptr -> Tensor -> Scalar -> Ptr -> Int -> Int -> Int -> ();
let atg_linalg_norm_ord_str = extern fn Ptr -> Tensor -> Ptr -> Int -> Ptr -> Int -> Int -> Int -> ();
let atg_linalg_norm_ord_str_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Int -> Int -> ();
let atg_linalg_norm_out = extern fn Ptr -> Tensor -> Tensor -> Scalar -> Ptr -> Int -> Int -> Int -> ();
let atg_linalg_pinv = extern fn Ptr -> Tensor -> Double -> Int -> ();
let atg_linalg_pinv_atol_rtol_float = extern fn Ptr -> Tensor -> Double -> Char -> Double -> Char -> Int -> ();
let atg_linalg_pinv_atol_rtol_float_out = extern fn Ptr -> Tensor -> Tensor -> Double -> Char -> Double -> Char -> Int -> ();
let atg_linalg_pinv_atol_rtol_tensor = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg_linalg_pinv_atol_rtol_tensor_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg_linalg_pinv_out = extern fn Ptr -> Tensor -> Tensor -> Double -> Int -> ();
let atg_linalg_pinv_out_rcond_tensor = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg_linalg_pinv_rcond_tensor = extern fn Ptr -> Tensor -> Tensor -> Int -> ();
let atg_linalg_qr = extern fn Ptr -> Tensor -> Ptr -> Int -> ();
let atg_linalg_qr_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg_linalg_slogdet = extern fn Ptr -> Tensor -> ();
let atg_linalg_slogdet_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_linalg_solve = extern fn Ptr -> Tensor -> Tensor -> Int -> ();
let atg_linalg_solve_ex = extern fn Ptr -> Tensor -> Tensor -> Int -> Int -> ();
let atg_linalg_solve_ex_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Int -> ();
let atg_linalg_solve_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg_linalg_solve_triangular = extern fn Ptr -> Tensor -> Tensor -> Int -> Int -> Int -> ();
let atg_linalg_solve_triangular_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> Int -> Int -> ();
let atg_linalg_svd = extern fn Ptr -> Tensor -> Int -> Ptr -> Int -> ();
let atg_linalg_svd_u = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Ptr -> Int -> ();
let atg_linalg_svdvals = extern fn Ptr -> Tensor -> Ptr -> Int -> ();
let atg_linalg_svdvals_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg_linalg_tensorinv = extern fn Ptr -> Tensor -> Int -> ();
let atg_linalg_tensorinv_out = extern fn Ptr -> Tensor -> Tensor -> Int -> ();
let atg_linalg_tensorsolve = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg_linalg_tensorsolve_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg_linalg_vander = extern fn Ptr -> Tensor -> Int -> Char -> ();
let atg_linalg_vecdot = extern fn Ptr -> Tensor -> Tensor -> Int -> ();
let atg_linalg_vecdot_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg_linear = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_linear_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> ();
let atg_linspace = extern fn Ptr -> Scalar -> Scalar -> Int -> Int -> Int -> ();
let atg_linspace_out = extern fn Ptr -> Tensor -> Scalar -> Scalar -> Int -> ();
let atg_linspace_scalar_tensor = extern fn Ptr -> Scalar -> Tensor -> Int -> Int -> Int -> ();
let atg_linspace_scalar_tensor_out = extern fn Ptr -> Tensor -> Scalar -> Tensor -> Int -> ();
let atg_linspace_tensor_scalar = extern fn Ptr -> Tensor -> Scalar -> Int -> Int -> Int -> ();
let atg_linspace_tensor_scalar_out = extern fn Ptr -> Tensor -> Tensor -> Scalar -> Int -> ();
let atg_linspace_tensor_tensor = extern fn Ptr -> Tensor -> Tensor -> Int -> Int -> Int -> ();
let atg_linspace_tensor_tensor_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg_log = extern fn Ptr -> Tensor -> ();
let atg_log10 = extern fn Ptr -> Tensor -> ();
let atg_log10_ = extern fn Ptr -> Tensor -> ();
let atg_log10_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_log1p = extern fn Ptr -> Tensor -> ();
let atg_log1p_ = extern fn Ptr -> Tensor -> ();
let atg_log1p_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_log2 = extern fn Ptr -> Tensor -> ();
let atg_log2_ = extern fn Ptr -> Tensor -> ();
let atg_log2_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_log_ = extern fn Ptr -> Tensor -> ();
let atg_log_normal = extern fn Ptr -> Tensor -> Double -> Double -> ();
let atg_log_normal_ = extern fn Ptr -> Tensor -> Double -> Double -> ();
let atg_log_normal_out = extern fn Ptr -> Tensor -> Tensor -> Double -> Double -> ();
let atg_log_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_log_sigmoid = extern fn Ptr -> Tensor -> ();
let atg_log_sigmoid_backward = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_log_sigmoid_backward_grad_input = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> ();
let atg_log_sigmoid_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_log_softmax = extern fn Ptr -> Tensor -> Int -> Int -> ();
let atg_log_softmax_int_out = extern fn Ptr -> Tensor -> Tensor -> Int -> Int -> ();
let atg_logaddexp = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_logaddexp2 = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_logaddexp2_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_logaddexp_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_logcumsumexp = extern fn Ptr -> Tensor -> Int -> ();
let atg_logcumsumexp_out = extern fn Ptr -> Tensor -> Tensor -> Int -> ();
let atg_logdet = extern fn Ptr -> Tensor -> ();
let atg_logical_and = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_logical_and_ = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_logical_and_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_logical_not = extern fn Ptr -> Tensor -> ();
let atg_logical_not_ = extern fn Ptr -> Tensor -> ();
let atg_logical_not_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_logical_or = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_logical_or_ = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_logical_or_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_logical_xor = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_logical_xor_ = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_logical_xor_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_logit = extern fn Ptr -> Tensor -> Double -> Char -> ();
let atg_logit_ = extern fn Ptr -> Tensor -> Double -> Char -> ();
let atg_logit_backward = extern fn Ptr -> Tensor -> Tensor -> Double -> Char -> ();
let atg_logit_backward_grad_input = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Double -> Char -> ();
let atg_logit_out = extern fn Ptr -> Tensor -> Tensor -> Double -> Char -> ();
let atg_logspace = extern fn Ptr -> Scalar -> Scalar -> Int -> Double -> Int -> Int -> ();
let atg_logspace_out = extern fn Ptr -> Tensor -> Scalar -> Scalar -> Int -> Double -> ();
let atg_logspace_scalar_tensor = extern fn Ptr -> Scalar -> Tensor -> Int -> Double -> Int -> Int -> ();
let atg_logspace_scalar_tensor_out = extern fn Ptr -> Tensor -> Scalar -> Tensor -> Int -> Double -> ();
let atg_logspace_tensor_scalar = extern fn Ptr -> Tensor -> Scalar -> Int -> Double -> Int -> Int -> ();
let atg_logspace_tensor_scalar_out = extern fn Ptr -> Tensor -> Tensor -> Scalar -> Int -> Double -> ();
let atg_logspace_tensor_tensor = extern fn Ptr -> Tensor -> Tensor -> Int -> Double -> Int -> Int -> ();
let atg_logspace_tensor_tensor_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> Double -> ();
let atg_logsumexp = extern fn Ptr -> Tensor -> Ptr -> Int -> Int -> ();
let atg_logsumexp_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Int -> ();
let atg_lstm = extern fn Ptr -> Tensor -> Ptr -> Int -> Ptr -> Int -> Int -> Int -> Double -> Int -> Int -> Int -> ();
let atg_lstm_cell = extern fn Ptr -> Tensor -> Ptr -> Int -> Tensor -> Tensor -> Tensor -> Tensor -> ();
let atg_lstm_data = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Int -> Int -> Double -> Int -> Int -> ();
let atg_lstm_mps_backward = extern fn Tensor -> Ptr -> Int -> Ptr -> Int -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Int -> Int -> Double -> Int -> Int -> Int -> ();
let atg_lt = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_lt_ = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_lt_scalar_out = extern fn Ptr -> Tensor -> Tensor -> Scalar -> ();
let atg_lt_tensor = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_lt_tensor_ = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_lt_tensor_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_lu_solve = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_lu_solve_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> ();
let atg_lu_unpack = extern fn Ptr -> Tensor -> Tensor -> Int -> Int -> ();
let atg_lu_unpack_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Int -> ();
let atg_margin_ranking_loss = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Double -> Int -> ();
let atg_masked_fill = extern fn Ptr -> Tensor -> Tensor -> Scalar -> ();
let atg_masked_fill_ = extern fn Ptr -> Tensor -> Tensor -> Scalar -> ();
let atg_masked_fill_scalar_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Scalar -> ();
let atg_masked_fill_tensor = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_masked_fill_tensor_ = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_masked_fill_tensor_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> ();
let atg_masked_scatter = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_masked_scatter_ = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_masked_scatter_backward = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg_masked_scatter_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> ();
let atg_masked_select = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_masked_select_backward = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_masked_select_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_matmul = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_matmul_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_matrix_exp = extern fn Ptr -> Tensor -> ();
let atg_matrix_exp_backward = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_matrix_h = extern fn Ptr -> Tensor -> ();
let atg_matrix_power = extern fn Ptr -> Tensor -> Int -> ();
let atg_matrix_power_out = extern fn Ptr -> Tensor -> Tensor -> Int -> ();
let atg_max = extern fn Ptr -> Tensor -> ();
let atg_max_dim = extern fn Ptr -> Tensor -> Int -> Int -> ();
let atg_max_dim_max = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> Int -> ();
let atg_max_other = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_max_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_max_pool1d = extern fn Ptr -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> ();
let atg_max_pool1d_with_indices = extern fn Ptr -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> ();
let atg_max_pool2d = extern fn Ptr -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> ();
let atg_max_pool2d_backward = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> ();
let atg_max_pool2d_backward_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> ();
let atg_max_pool2d_with_indices = extern fn Ptr -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> ();
let atg_max_pool2d_with_indices_backward = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> Tensor -> ();
let atg_max_pool2d_with_indices_backward_grad_input = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> Tensor -> ();
let atg_max_pool2d_with_indices_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> ();
let atg_max_pool3d = extern fn Ptr -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> ();
let atg_max_pool3d_with_indices = extern fn Ptr -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> ();
let atg_max_pool3d_with_indices_backward = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> Tensor -> ();
let atg_max_pool3d_with_indices_backward_grad_input = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> Tensor -> ();
let atg_max_pool3d_with_indices_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> ();
let atg_max_unary_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_max_unpool2d = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg_max_unpool2d_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg_max_unpool3d = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> ();
let atg_max_unpool3d_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> ();
let atg_maximum = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_maximum_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_mean = extern fn Ptr -> Tensor -> Int -> ();
let atg_mean_dim = extern fn Ptr -> Tensor -> Ptr -> Int -> Int -> Int -> ();
let atg_mean_dtype_out = extern fn Ptr -> Tensor -> Tensor -> Int -> ();
let atg_mean_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Int -> Int -> ();
let atg_median = extern fn Ptr -> Tensor -> ();
let atg_median_dim = extern fn Ptr -> Tensor -> Int -> Int -> ();
let atg_median_dim_values = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> Int -> ();
let atg_median_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_meshgrid = extern fn Ptr -> Int -> Ptr;
let atg_meshgrid_indexing = extern fn Ptr -> Int -> Ptr -> Int -> Ptr;
let atg_mh = extern fn Ptr -> Tensor -> ();
let atg_min = extern fn Ptr -> Tensor -> ();
let atg_min_dim = extern fn Ptr -> Tensor -> Int -> Int -> ();
let atg_min_dim_min = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> Int -> ();
let atg_min_other = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_min_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_min_unary_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_minimum = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_minimum_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_miopen_batch_norm = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Double -> Double -> ();
let atg_miopen_batch_norm_backward = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Double -> ();
let atg_miopen_batch_norm_backward_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Double -> ();
let atg_miopen_batch_norm_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Double -> Double -> ();
let atg_miopen_convolution = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> Int -> Int -> ();
let atg_miopen_convolution_add_relu = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Scalar -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> ();
let atg_miopen_convolution_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> Int -> Int -> ();
let atg_miopen_convolution_relu = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> ();
let atg_miopen_convolution_transpose = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> Int -> Int -> ();
let atg_miopen_convolution_transpose_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> Int -> Int -> ();
let atg_miopen_depthwise_convolution = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> Int -> Int -> ();
let atg_miopen_depthwise_convolution_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> Int -> Int -> ();
let atg_miopen_rnn = extern fn Ptr -> Tensor -> Ptr -> Int -> Int -> Tensor -> Tensor -> Int -> Int -> Int -> Int -> Double -> Int -> Int -> Ptr -> Int -> Tensor -> ();
let atg_miopen_rnn_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Int -> Tensor -> Tensor -> Int -> Int -> Int -> Int -> Double -> Int -> Int -> Ptr -> Int -> Tensor -> ();
let atg_mish = extern fn Ptr -> Tensor -> ();
let atg_mish_ = extern fn Ptr -> Tensor -> ();
let atg_mish_backward = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_mish_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_mkldnn_adaptive_avg_pool2d = extern fn Ptr -> Tensor -> Ptr -> Int -> ();
let atg_mkldnn_adaptive_avg_pool2d_backward = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_mkldnn_adaptive_avg_pool2d_backward_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_mkldnn_adaptive_avg_pool2d_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg_mkldnn_convolution = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> ();
let atg_mkldnn_convolution_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> ();
let atg_mkldnn_linear = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_mkldnn_linear_backward_input = extern fn Ptr -> Ptr -> Int -> Tensor -> Tensor -> ();
let atg_mkldnn_linear_backward_input_out = extern fn Ptr -> Tensor -> Ptr -> Int -> Tensor -> Tensor -> ();
let atg_mkldnn_linear_backward_weights = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg_mkldnn_linear_backward_weights_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg_mkldnn_linear_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> ();
let atg_mkldnn_max_pool2d = extern fn Ptr -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> ();
let atg_mkldnn_max_pool2d_backward = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> ();
let atg_mkldnn_max_pool2d_backward_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> ();
let atg_mkldnn_max_pool2d_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> ();
let atg_mkldnn_max_pool3d = extern fn Ptr -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> ();
let atg_mkldnn_max_pool3d_backward = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> ();
let atg_mkldnn_max_pool3d_backward_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> ();
let atg_mkldnn_max_pool3d_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> ();
let atg_mkldnn_reorder_conv2d_weight = extern fn Ptr -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> Ptr -> Int -> ();
let atg_mkldnn_reorder_conv2d_weight_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> Ptr -> Int -> ();
let atg_mkldnn_reorder_conv3d_weight = extern fn Ptr -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> Ptr -> Int -> ();
let atg_mkldnn_reorder_conv3d_weight_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> Ptr -> Int -> ();
let atg_mkldnn_rnn_layer = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Ptr -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> ();
let atg_mkldnn_rnn_layer_backward = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Ptr -> Int -> Int -> Tensor -> ();
let atg_mkldnn_rnn_layer_backward_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Ptr -> Int -> Int -> Tensor -> ();
let atg_mkldnn_rnn_layer_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Ptr -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> ();
let atg_mm = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_mm_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_mode = extern fn Ptr -> Tensor -> Int -> Int -> ();
let atg_mode_values = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> Int -> ();
let atg_moveaxis = extern fn Ptr -> Tensor -> Ptr -> Int -> Ptr -> Int -> ();
let atg_moveaxis_int = extern fn Ptr -> Tensor -> Int -> Int -> ();
let atg_movedim = extern fn Ptr -> Tensor -> Ptr -> Int -> Ptr -> Int -> ();
let atg_movedim_int = extern fn Ptr -> Tensor -> Int -> Int -> ();
let atg_mse_loss = extern fn Ptr -> Tensor -> Tensor -> Int -> ();
let atg_mse_loss_backward = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg_mse_loss_backward_grad_input = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg_mse_loss_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg_msort = extern fn Ptr -> Tensor -> ();
let atg_msort_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_mt = extern fn Ptr -> Tensor -> ();
let atg_mul = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_mul_ = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_mul_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_mul_scalar = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_mul_scalar_ = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_mul_scalar_out = extern fn Ptr -> Tensor -> Tensor -> Scalar -> ();
let atg_multi_margin_loss_backward = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Scalar -> Scalar -> Tensor -> Int -> ();
let atg_multi_margin_loss_backward_grad_input = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Scalar -> Scalar -> Tensor -> Int -> ();
let atg_multilabel_margin_loss = extern fn Ptr -> Tensor -> Tensor -> Int -> ();
let atg_multilabel_margin_loss_backward = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> Tensor -> ();
let atg_multilabel_margin_loss_backward_grad_input = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Tensor -> ();
let atg_multilabel_margin_loss_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg_multinomial = extern fn Ptr -> Tensor -> Int -> Int -> ();
let atg_multinomial_out = extern fn Ptr -> Tensor -> Tensor -> Int -> Int -> ();
let atg_multiply = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_multiply_ = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_multiply_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_multiply_scalar = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_multiply_scalar_ = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_mv = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_mv_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_mvlgamma = extern fn Ptr -> Tensor -> Int -> ();
let atg_mvlgamma_ = extern fn Ptr -> Tensor -> Int -> ();
let atg_mvlgamma_out = extern fn Ptr -> Tensor -> Tensor -> Int -> ();
let atg_nan_to_num = extern fn Ptr -> Tensor -> Double -> Char -> Double -> Char -> Double -> Char -> ();
let atg_nan_to_num_ = extern fn Ptr -> Tensor -> Double -> Char -> Double -> Char -> Double -> Char -> ();
let atg_nan_to_num_out = extern fn Ptr -> Tensor -> Tensor -> Double -> Char -> Double -> Char -> Double -> Char -> ();
let atg_nanmean = extern fn Ptr -> Tensor -> Ptr -> Int -> Int -> Int -> ();
let atg_nanmean_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Int -> Int -> ();
let atg_nanmedian = extern fn Ptr -> Tensor -> ();
let atg_nanmedian_dim = extern fn Ptr -> Tensor -> Int -> Int -> ();
let atg_nanmedian_dim_values = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> Int -> ();
let atg_nanmedian_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_nanquantile = extern fn Ptr -> Tensor -> Tensor -> Int -> Char -> Int -> Ptr -> Int -> ();
let atg_nanquantile_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> Char -> Int -> Ptr -> Int -> ();
let atg_nanquantile_scalar = extern fn Ptr -> Tensor -> Double -> Int -> Char -> Int -> Ptr -> Int -> ();
let atg_nanquantile_scalar_out = extern fn Ptr -> Tensor -> Tensor -> Double -> Int -> Char -> Int -> Ptr -> Int -> ();
let atg_nansum = extern fn Ptr -> Tensor -> Ptr -> Int -> Int -> Int -> ();
let atg_nansum_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Int -> Int -> ();
let atg_narrow = extern fn Ptr -> Tensor -> Int -> Int -> Int -> ();
let atg_narrow_copy = extern fn Ptr -> Tensor -> Int -> Int -> Int -> ();
let atg_narrow_copy_out = extern fn Ptr -> Tensor -> Tensor -> Int -> Int -> Int -> ();
let atg_narrow_tensor = extern fn Ptr -> Tensor -> Int -> Tensor -> Int -> ();
let atg_native_batch_norm = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Double -> Double -> ();
let atg_native_batch_norm_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Double -> Double -> ();
let atg_native_channel_shuffle = extern fn Ptr -> Tensor -> Int -> ();
let atg_native_dropout = extern fn Ptr -> Tensor -> Double -> Int -> ();
let atg_native_dropout_backward = extern fn Ptr -> Tensor -> Tensor -> Double -> ();
let atg_native_dropout_backward_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Double -> ();
let atg_native_dropout_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Double -> Int -> ();
let atg_native_group_norm = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> Int -> Int -> Int -> Double -> ();
let atg_native_group_norm_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Int -> Int -> Int -> Double -> ();
let atg_native_layer_norm = extern fn Ptr -> Tensor -> Ptr -> Int -> Tensor -> Tensor -> Double -> ();
let atg_native_layer_norm_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Tensor -> Tensor -> Double -> ();
let atg_native_norm = extern fn Ptr -> Tensor -> ();
let atg_native_norm_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_native_norm_scalaropt_dim_dtype = extern fn Ptr -> Tensor -> Scalar -> Ptr -> Int -> Int -> Int -> ();
let atg_native_norm_scalaropt_dim_dtype_out = extern fn Ptr -> Tensor -> Tensor -> Scalar -> Ptr -> Int -> Int -> Int -> ();
let atg_ne = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_ne_ = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_ne_scalar_out = extern fn Ptr -> Tensor -> Tensor -> Scalar -> ();
let atg_ne_tensor = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_ne_tensor_ = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_ne_tensor_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_neg = extern fn Ptr -> Tensor -> ();
let atg_neg_ = extern fn Ptr -> Tensor -> ();
let atg_neg_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_negative = extern fn Ptr -> Tensor -> ();
let atg_negative_ = extern fn Ptr -> Tensor -> ();
let atg_negative_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_nested_to_padded_tensor = extern fn Ptr -> Tensor -> Double -> Ptr -> Int -> ();
let atg_new_empty = extern fn Ptr -> Tensor -> Ptr -> Int -> Int -> Int -> ();
let atg_new_empty_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg_new_empty_strided = extern fn Ptr -> Tensor -> Ptr -> Int -> Ptr -> Int -> Int -> Int -> ();
let atg_new_empty_strided_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> ();
let atg_new_full = extern fn Ptr -> Tensor -> Ptr -> Int -> Scalar -> Int -> Int -> ();
let atg_new_full_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Scalar -> ();
let atg_new_ones = extern fn Ptr -> Tensor -> Ptr -> Int -> Int -> Int -> ();
let atg_new_ones_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg_new_zeros = extern fn Ptr -> Tensor -> Ptr -> Int -> Int -> Int -> ();
let atg_new_zeros_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg_nextafter = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_nextafter_ = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_nextafter_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_nll_loss = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> Int -> ();
let atg_nll_loss2d = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> Int -> ();
let atg_nll_loss2d_backward = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Int -> Tensor -> ();
let atg_nll_loss2d_backward_grad_input = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Int -> Tensor -> ();
let atg_nll_loss2d_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Int -> ();
let atg_nll_loss_backward = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Int -> Tensor -> ();
let atg_nll_loss_backward_grad_input = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Int -> Tensor -> ();
let atg_nll_loss_nd = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> Int -> ();
let atg_nll_loss_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Int -> ();
let atg_nonzero = extern fn Ptr -> Tensor -> ();
let atg_nonzero_numpy = extern fn Tensor -> Ptr;
let atg_nonzero_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_nonzero_static = extern fn Ptr -> Tensor -> Int -> Int -> ();
let atg_nonzero_static_out = extern fn Ptr -> Tensor -> Tensor -> Int -> Int -> ();
let atg_norm = extern fn Ptr -> Tensor -> ();
let atg_norm_dtype_out = extern fn Ptr -> Tensor -> Tensor -> Scalar -> Ptr -> Int -> Int -> Int -> ();
let atg_norm_except_dim = extern fn Ptr -> Tensor -> Int -> Int -> ();
let atg_norm_out = extern fn Ptr -> Tensor -> Tensor -> Scalar -> Ptr -> Int -> Int -> ();
let atg_norm_scalar_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_norm_scalaropt_dim = extern fn Ptr -> Tensor -> Scalar -> Ptr -> Int -> Int -> ();
let atg_norm_scalaropt_dim_dtype = extern fn Ptr -> Tensor -> Scalar -> Ptr -> Int -> Int -> Int -> ();
let atg_norm_scalaropt_dtype = extern fn Ptr -> Tensor -> Scalar -> Int -> ();
let atg_norm_scalaropt_dtype_out = extern fn Ptr -> Tensor -> Tensor -> Scalar -> Int -> ();
let atg_normal_ = extern fn Ptr -> Tensor -> Double -> Double -> ();
let atg_normal_functional = extern fn Ptr -> Tensor -> Double -> Double -> ();
let atg_not_equal = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_not_equal_ = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_not_equal_scalar_out = extern fn Ptr -> Tensor -> Tensor -> Scalar -> ();
let atg_not_equal_tensor = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_not_equal_tensor_ = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_not_equal_tensor_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_nuclear_norm = extern fn Ptr -> Tensor -> Int -> ();
let atg_nuclear_norm_dim = extern fn Ptr -> Tensor -> Ptr -> Int -> Int -> ();
let atg_nuclear_norm_dim_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Int -> ();
let atg_nuclear_norm_out = extern fn Ptr -> Tensor -> Tensor -> Int -> ();
let atg_numpy_t = extern fn Ptr -> Tensor -> ();
let atg_one_hot = extern fn Ptr -> Tensor -> Int -> ();
let atg_ones = extern fn Ptr -> Ptr -> Int -> Int -> Int -> ();
let atg_ones_like = extern fn Ptr -> Tensor -> ();
let atg_ones_like_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_ones_out = extern fn Ptr -> Tensor -> Ptr -> Int -> ();
let atg_orgqr = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_orgqr_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_ormqr = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> Int -> ();
let atg_ormqr_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Int -> ();
let atg_outer = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_outer_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_output_nr = extern fn Tensor -> Int;
let atg_pad = extern fn Ptr -> Tensor -> Ptr -> Int -> Ptr -> Int -> Double -> Char -> ();
let atg_pad_sequence = extern fn Ptr -> Ptr -> Int -> Int -> Double -> Ptr -> Int -> ();
let atg_pairwise_distance = extern fn Ptr -> Tensor -> Tensor -> Double -> Double -> Int -> ();
let atg_pdist = extern fn Ptr -> Tensor -> Double -> ();
let atg_permute = extern fn Ptr -> Tensor -> Ptr -> Int -> ();
let atg_permute_copy = extern fn Ptr -> Tensor -> Ptr -> Int -> ();
let atg_permute_copy_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg_pin_memory = extern fn Ptr -> Tensor -> Int -> ();
let atg_pinverse = extern fn Ptr -> Tensor -> Double -> ();
let atg_pixel_shuffle = extern fn Ptr -> Tensor -> Int -> ();
let atg_pixel_shuffle_out = extern fn Ptr -> Tensor -> Tensor -> Int -> ();
let atg_pixel_unshuffle = extern fn Ptr -> Tensor -> Int -> ();
let atg_pixel_unshuffle_out = extern fn Ptr -> Tensor -> Tensor -> Int -> ();
let atg_poisson = extern fn Ptr -> Tensor -> ();
let atg_poisson_nll_loss = extern fn Ptr -> Tensor -> Tensor -> Int -> Int -> Double -> Int -> ();
let atg_poisson_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_polar = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_polar_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_polygamma = extern fn Ptr -> Int -> Tensor -> ();
let atg_polygamma_ = extern fn Ptr -> Tensor -> Int -> ();
let atg_polygamma_out = extern fn Ptr -> Tensor -> Int -> Tensor -> ();
let atg_positive = extern fn Ptr -> Tensor -> ();
let atg_pow = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_pow_ = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_pow_scalar = extern fn Ptr -> Scalar -> Tensor -> ();
let atg_pow_scalar_out = extern fn Ptr -> Tensor -> Scalar -> Tensor -> ();
let atg_pow_tensor_ = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_pow_tensor_scalar = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_pow_tensor_scalar_out = extern fn Ptr -> Tensor -> Tensor -> Scalar -> ();
let atg_pow_tensor_tensor_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_prelu = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_prod = extern fn Ptr -> Tensor -> Int -> ();
let atg_prod_dim_int = extern fn Ptr -> Tensor -> Int -> Int -> Int -> ();
let atg_prod_int_out = extern fn Ptr -> Tensor -> Tensor -> Int -> Int -> Int -> ();
let atg_prod_out = extern fn Ptr -> Tensor -> Tensor -> Int -> ();
let atg_put = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg_put_ = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg_put_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg_q_per_channel_axis = extern fn Tensor -> Int;
let atg_q_per_channel_scales = extern fn Ptr -> Tensor -> ();
let atg_q_per_channel_scales_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_q_per_channel_zero_points = extern fn Ptr -> Tensor -> ();
let atg_q_per_channel_zero_points_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_q_scale = extern fn Tensor -> Double;
let atg_q_zero_point = extern fn Tensor -> Int;
let atg_qr = extern fn Ptr -> Tensor -> Int -> ();
let atg_qr_q = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg_quantile = extern fn Ptr -> Tensor -> Tensor -> Int -> Char -> Int -> Ptr -> Int -> ();
let atg_quantile_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> Char -> Int -> Ptr -> Int -> ();
let atg_quantile_scalar = extern fn Ptr -> Tensor -> Double -> Int -> Char -> Int -> Ptr -> Int -> ();
let atg_quantile_scalar_out = extern fn Ptr -> Tensor -> Tensor -> Double -> Int -> Char -> Int -> Ptr -> Int -> ();
let atg_quantize_per_channel = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> Int -> ();
let atg_quantize_per_channel_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Int -> ();
let atg_quantize_per_tensor = extern fn Ptr -> Tensor -> Double -> Int -> Int -> ();
let atg_quantize_per_tensor_dynamic = extern fn Ptr -> Tensor -> Int -> Int -> ();
let atg_quantize_per_tensor_dynamic_out = extern fn Ptr -> Tensor -> Tensor -> Int -> Int -> ();
let atg_quantize_per_tensor_out = extern fn Ptr -> Tensor -> Tensor -> Double -> Int -> Int -> ();
let atg_quantize_per_tensor_tensor_qparams = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg_quantize_per_tensor_tensor_qparams_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg_quantize_per_tensor_tensors = extern fn Ptr -> Int -> Tensor -> Tensor -> Int -> Ptr;
let atg_quantize_per_tensor_tensors_out = extern fn Ptr -> Int -> Ptr -> Int -> Tensor -> Tensor -> Int -> ();
let atg_quantized_batch_norm = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Double -> Double -> Int -> ();
let atg_quantized_batch_norm_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Double -> Double -> Int -> ();
let atg_quantized_gru_cell = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Scalar -> Scalar -> Scalar -> Scalar -> ();
let atg_quantized_lstm_cell = extern fn Ptr -> Tensor -> Ptr -> Int -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Scalar -> Scalar -> Scalar -> Scalar -> ();
let atg_quantized_max_pool1d = extern fn Ptr -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> ();
let atg_quantized_max_pool1d_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> ();
let atg_quantized_max_pool2d = extern fn Ptr -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> ();
let atg_quantized_max_pool2d_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> ();
let atg_quantized_max_pool3d = extern fn Ptr -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> ();
let atg_quantized_max_pool3d_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Int -> ();
let atg_quantized_rnn_relu_cell = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Scalar -> Scalar -> Scalar -> Scalar -> ();
let atg_quantized_rnn_tanh_cell = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Scalar -> Scalar -> Scalar -> Scalar -> ();
let atg_rad2deg = extern fn Ptr -> Tensor -> ();
let atg_rad2deg_ = extern fn Ptr -> Tensor -> ();
let atg_rad2deg_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_rand = extern fn Ptr -> Ptr -> Int -> Int -> Int -> ();
let atg_rand_like = extern fn Ptr -> Tensor -> ();
let atg_rand_like_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_rand_out = extern fn Ptr -> Tensor -> Ptr -> Int -> ();
let atg_randint = extern fn Ptr -> Int -> Ptr -> Int -> Int -> Int -> ();
let atg_randint_like = extern fn Ptr -> Tensor -> Int -> ();
let atg_randint_like_low_dtype = extern fn Ptr -> Tensor -> Int -> Int -> ();
let atg_randint_like_low_dtype_out = extern fn Ptr -> Tensor -> Tensor -> Int -> Int -> ();
let atg_randint_like_out = extern fn Ptr -> Tensor -> Tensor -> Int -> ();
let atg_randint_low = extern fn Ptr -> Int -> Int -> Ptr -> Int -> Int -> Int -> ();
let atg_randint_low_out = extern fn Ptr -> Tensor -> Int -> Int -> Ptr -> Int -> ();
let atg_randint_out = extern fn Ptr -> Tensor -> Int -> Ptr -> Int -> ();
let atg_randn = extern fn Ptr -> Ptr -> Int -> Int -> Int -> ();
let atg_randn_like = extern fn Ptr -> Tensor -> ();
let atg_randn_like_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_randn_out = extern fn Ptr -> Tensor -> Ptr -> Int -> ();
let atg_random = extern fn Ptr -> Tensor -> ();
let atg_random_ = extern fn Ptr -> Tensor -> ();
let atg_random_from = extern fn Ptr -> Tensor -> Int -> Int -> Char -> ();
let atg_random_from_ = extern fn Ptr -> Tensor -> Int -> Int -> Char -> ();
let atg_random_from_out = extern fn Ptr -> Tensor -> Tensor -> Int -> Int -> Char -> ();
let atg_random_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_random_to = extern fn Ptr -> Tensor -> Int -> ();
let atg_random_to_ = extern fn Ptr -> Tensor -> Int -> ();
let atg_random_to_out = extern fn Ptr -> Tensor -> Tensor -> Int -> ();
let atg_randperm = extern fn Ptr -> Int -> Int -> Int -> ();
let atg_randperm_out = extern fn Ptr -> Tensor -> Int -> ();
let atg_range = extern fn Ptr -> Scalar -> Scalar -> Int -> Int -> ();
let atg_range_out = extern fn Ptr -> Tensor -> Scalar -> Scalar -> ();
let atg_range_out_ = extern fn Ptr -> Tensor -> Scalar -> Scalar -> ();
let atg_range_step = extern fn Ptr -> Scalar -> Scalar -> Int -> Int -> ();
let atg_ravel = extern fn Ptr -> Tensor -> ();
let atg_real = extern fn Ptr -> Tensor -> ();
let atg_reciprocal = extern fn Ptr -> Tensor -> ();
let atg_reciprocal_ = extern fn Ptr -> Tensor -> ();
let atg_reciprocal_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_reflection_pad1d = extern fn Ptr -> Tensor -> Ptr -> Int -> ();
let atg_reflection_pad1d_backward = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg_reflection_pad1d_backward_grad_input = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg_reflection_pad1d_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg_reflection_pad2d = extern fn Ptr -> Tensor -> Ptr -> Int -> ();
let atg_reflection_pad2d_backward = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg_reflection_pad2d_backward_grad_input = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg_reflection_pad2d_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg_reflection_pad3d = extern fn Ptr -> Tensor -> Ptr -> Int -> ();
let atg_reflection_pad3d_backward = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg_reflection_pad3d_backward_grad_input = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg_reflection_pad3d_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg_relu = extern fn Ptr -> Tensor -> ();
let atg_relu6 = extern fn Ptr -> Tensor -> ();
let atg_relu6_ = extern fn Ptr -> Tensor -> ();
let atg_relu_ = extern fn Ptr -> Tensor -> ();
let atg_relu_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_remainder = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_remainder_ = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_remainder_scalar_out = extern fn Ptr -> Tensor -> Tensor -> Scalar -> ();
let atg_remainder_scalar_tensor = extern fn Ptr -> Scalar -> Tensor -> ();
let atg_remainder_scalar_tensor_out = extern fn Ptr -> Tensor -> Scalar -> Tensor -> ();
let atg_remainder_tensor = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_remainder_tensor_ = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_remainder_tensor_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_renorm = extern fn Ptr -> Tensor -> Scalar -> Int -> Scalar -> ();
let atg_renorm_ = extern fn Ptr -> Tensor -> Scalar -> Int -> Scalar -> ();
let atg_renorm_out = extern fn Ptr -> Tensor -> Tensor -> Scalar -> Int -> Scalar -> ();
let atg_repeat = extern fn Ptr -> Tensor -> Ptr -> Int -> ();
let atg_repeat_interleave = extern fn Ptr -> Tensor -> Int -> Char -> ();
let atg_repeat_interleave_self_int = extern fn Ptr -> Tensor -> Int -> Int -> Char -> Int -> Char -> ();
let atg_repeat_interleave_self_tensor = extern fn Ptr -> Tensor -> Tensor -> Int -> Char -> Int -> Char -> ();
let atg_repeat_interleave_tensor_out = extern fn Ptr -> Tensor -> Tensor -> Int -> Char -> ();
let atg_repeat_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg_replication_pad1d = extern fn Ptr -> Tensor -> Ptr -> Int -> ();
let atg_replication_pad1d_backward = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg_replication_pad1d_backward_grad_input = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg_replication_pad1d_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg_replication_pad2d = extern fn Ptr -> Tensor -> Ptr -> Int -> ();
let atg_replication_pad2d_backward = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg_replication_pad2d_backward_grad_input = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg_replication_pad2d_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg_replication_pad3d = extern fn Ptr -> Tensor -> Ptr -> Int -> ();
let atg_replication_pad3d_backward = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg_replication_pad3d_backward_grad_input = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg_replication_pad3d_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg_requires_grad_ = extern fn Ptr -> Tensor -> Int -> ();
let atg_reshape = extern fn Ptr -> Tensor -> Ptr -> Int -> ();
let atg_reshape_as = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_resize = extern fn Ptr -> Tensor -> Ptr -> Int -> ();
let atg_resize_ = extern fn Ptr -> Tensor -> Ptr -> Int -> ();
let atg_resize_as = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_resize_as_ = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_resize_as_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_resize_as_sparse = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_resize_as_sparse_ = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_resize_as_sparse_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_resize_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg_resolve_conj = extern fn Ptr -> Tensor -> ();
let atg_resolve_neg = extern fn Ptr -> Tensor -> ();
let atg_retains_grad = extern fn Tensor -> Int;
let atg_rms_norm = extern fn Ptr -> Tensor -> Ptr -> Int -> Tensor -> Double -> Char -> ();
let atg_rnn_relu = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Int -> Int -> Double -> Int -> Int -> Int -> ();
let atg_rnn_relu_cell = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> ();
let atg_rnn_relu_data = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Int -> Int -> Double -> Int -> Int -> ();
let atg_rnn_tanh = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Int -> Int -> Double -> Int -> Int -> Int -> ();
let atg_rnn_tanh_cell = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> Tensor -> ();
let atg_rnn_tanh_data = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Int -> Int -> Double -> Int -> Int -> ();
let atg_roll = extern fn Ptr -> Tensor -> Ptr -> Int -> Ptr -> Int -> ();
let atg_roll_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> ();
let atg_rot90 = extern fn Ptr -> Tensor -> Int -> Ptr -> Int -> ();
let atg_rot90_out = extern fn Ptr -> Tensor -> Tensor -> Int -> Ptr -> Int -> ();
let atg_round = extern fn Ptr -> Tensor -> ();
let atg_round_ = extern fn Ptr -> Tensor -> ();
let atg_round_decimals = extern fn Ptr -> Tensor -> Int -> ();
let atg_round_decimals_ = extern fn Ptr -> Tensor -> Int -> ();
let atg_round_decimals_out = extern fn Ptr -> Tensor -> Tensor -> Int -> ();
let atg_round_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_row_indices = extern fn Ptr -> Tensor -> ();
let atg_row_indices_copy = extern fn Ptr -> Tensor -> ();
let atg_row_indices_copy_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_row_stack = extern fn Ptr -> Ptr -> Int -> ();
let atg_row_stack_out = extern fn Ptr -> Tensor -> Ptr -> Int -> ();
let atg_rrelu = extern fn Ptr -> Tensor -> Int -> ();
let atg_rrelu_ = extern fn Ptr -> Tensor -> Int -> ();
let atg_rrelu_with_noise = extern fn Ptr -> Tensor -> Tensor -> Int -> ();
let atg_rrelu_with_noise_ = extern fn Ptr -> Tensor -> Tensor -> Int -> ();
let atg_rrelu_with_noise_backward = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Scalar -> Scalar -> Int -> Int -> ();
let atg_rrelu_with_noise_backward_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Scalar -> Scalar -> Int -> Int -> ();
let atg_rrelu_with_noise_functional = extern fn Ptr -> Tensor -> Tensor -> Int -> ();
let atg_rrelu_with_noise_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg_rsqrt = extern fn Ptr -> Tensor -> ();
let atg_rsqrt_ = extern fn Ptr -> Tensor -> ();
let atg_rsqrt_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_rsub = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_rsub_scalar = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_rsub_scalar_out = extern fn Ptr -> Tensor -> Tensor -> Scalar -> ();
let atg_rsub_tensor_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_scalar_tensor = extern fn Ptr -> Scalar -> Int -> Int -> ();
let atg_scalar_tensor_out = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_scaled_dot_product_attention = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Double -> Int -> Double -> Char -> Int -> ();
let atg_scatter = extern fn Ptr -> Tensor -> Int -> Tensor -> Tensor -> ();
let atg_scatter_ = extern fn Ptr -> Tensor -> Int -> Tensor -> Tensor -> ();
let atg_scatter_add = extern fn Ptr -> Tensor -> Int -> Tensor -> Tensor -> ();
let atg_scatter_add_ = extern fn Ptr -> Tensor -> Int -> Tensor -> Tensor -> ();
let atg_scatter_add_out = extern fn Ptr -> Tensor -> Tensor -> Int -> Tensor -> Tensor -> ();
let atg_scatter_reduce = extern fn Ptr -> Tensor -> Int -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg_scatter_reduce_ = extern fn Ptr -> Tensor -> Int -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg_scatter_reduce_out = extern fn Ptr -> Tensor -> Tensor -> Int -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg_scatter_src_out = extern fn Ptr -> Tensor -> Tensor -> Int -> Tensor -> Tensor -> ();
let atg_scatter_value = extern fn Ptr -> Tensor -> Int -> Tensor -> Scalar -> ();
let atg_scatter_value_ = extern fn Ptr -> Tensor -> Int -> Tensor -> Scalar -> ();
let atg_scatter_value_out = extern fn Ptr -> Tensor -> Tensor -> Int -> Tensor -> Scalar -> ();
let atg_scatter_value_reduce = extern fn Ptr -> Tensor -> Int -> Tensor -> Scalar -> Ptr -> Int -> ();
let atg_scatter_value_reduce_ = extern fn Ptr -> Tensor -> Int -> Tensor -> Scalar -> Ptr -> Int -> ();
let atg_scatter_value_reduce_out = extern fn Ptr -> Tensor -> Tensor -> Int -> Tensor -> Scalar -> Ptr -> Int -> ();
let atg_searchsorted = extern fn Ptr -> Tensor -> Tensor -> Int -> Int -> Ptr -> Int -> Tensor -> ();
let atg_searchsorted_scalar = extern fn Ptr -> Tensor -> Scalar -> Int -> Int -> Ptr -> Int -> Tensor -> ();
let atg_searchsorted_scalar_out = extern fn Ptr -> Tensor -> Tensor -> Scalar -> Int -> Int -> Ptr -> Int -> Tensor -> ();
let atg_searchsorted_tensor_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> Int -> Ptr -> Int -> Tensor -> ();
let atg_segment_reduce = extern fn Ptr -> Tensor -> Ptr -> Int -> Tensor -> Tensor -> Tensor -> Int -> Int -> Scalar -> ();
let atg_segment_reduce_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Tensor -> Tensor -> Tensor -> Int -> Int -> Scalar -> ();
let atg_select = extern fn Ptr -> Tensor -> Int -> Int -> ();
let atg_select_backward = extern fn Ptr -> Tensor -> Ptr -> Int -> Int -> Int -> ();
let atg_select_backward_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Int -> Int -> ();
let atg_select_copy = extern fn Ptr -> Tensor -> Int -> Int -> ();
let atg_select_copy_int_out = extern fn Ptr -> Tensor -> Tensor -> Int -> Int -> ();
let atg_select_scatter = extern fn Ptr -> Tensor -> Tensor -> Int -> Int -> ();
let atg_select_scatter_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> Int -> ();
let atg_selu = extern fn Ptr -> Tensor -> ();
let atg_selu_ = extern fn Ptr -> Tensor -> ();
let atg_set = extern fn Ptr -> Tensor -> ();
let atg_set_ = extern fn Ptr -> Tensor -> ();
let atg_set_data = extern fn Tensor -> Tensor -> ();
let atg_set_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_set_requires_grad = extern fn Ptr -> Tensor -> Int -> ();
let atg_set_source_tensor = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_set_source_tensor_ = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_set_source_tensor_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_set_source_tensor_storage_offset_ = extern fn Ptr -> Tensor -> Tensor -> Int -> Ptr -> Int -> Ptr -> Int -> ();
let atg_sgn = extern fn Ptr -> Tensor -> ();
let atg_sgn_ = extern fn Ptr -> Tensor -> ();
let atg_sgn_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_sigmoid = extern fn Ptr -> Tensor -> ();
let atg_sigmoid_ = extern fn Ptr -> Tensor -> ();
let atg_sigmoid_backward = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_sigmoid_backward_grad_input = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_sigmoid_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_sign = extern fn Ptr -> Tensor -> ();
let atg_sign_ = extern fn Ptr -> Tensor -> ();
let atg_sign_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_signbit = extern fn Ptr -> Tensor -> ();
let atg_signbit_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_silu = extern fn Ptr -> Tensor -> ();
let atg_silu_ = extern fn Ptr -> Tensor -> ();
let atg_silu_backward = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_silu_backward_grad_input = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_silu_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_sin = extern fn Ptr -> Tensor -> ();
let atg_sin_ = extern fn Ptr -> Tensor -> ();
let atg_sin_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_sinc = extern fn Ptr -> Tensor -> ();
let atg_sinc_ = extern fn Ptr -> Tensor -> ();
let atg_sinc_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_sinh = extern fn Ptr -> Tensor -> ();
let atg_sinh_ = extern fn Ptr -> Tensor -> ();
let atg_sinh_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_slice = extern fn Ptr -> Tensor -> Int -> Int -> Char -> Int -> Char -> Int -> ();
let atg_slice_backward = extern fn Ptr -> Tensor -> Ptr -> Int -> Int -> Int -> Int -> Int -> ();
let atg_slice_backward_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Int -> Int -> Int -> Int -> ();
let atg_slice_copy = extern fn Ptr -> Tensor -> Int -> Int -> Char -> Int -> Char -> Int -> ();
let atg_slice_copy_tensor_out = extern fn Ptr -> Tensor -> Tensor -> Int -> Int -> Char -> Int -> Char -> Int -> ();
let atg_slice_inverse = extern fn Ptr -> Tensor -> Tensor -> Int -> Int -> Char -> Int -> Char -> Int -> ();
let atg_slice_scatter = extern fn Ptr -> Tensor -> Tensor -> Int -> Int -> Char -> Int -> Char -> Int -> ();
let atg_slice_scatter_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> Int -> Char -> Int -> Char -> Int -> ();
let atg_slogdet = extern fn Ptr -> Tensor -> ();
let atg_slogdet_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_slow_conv3d = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Tensor -> Ptr -> Int -> Ptr -> Int -> ();
let atg_slow_conv3d_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Tensor -> Ptr -> Int -> Ptr -> Int -> ();
let atg_slow_conv_dilated2d = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> ();
let atg_slow_conv_dilated2d_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> ();
let atg_slow_conv_dilated3d = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> ();
let atg_slow_conv_dilated3d_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> ();
let atg_slow_conv_transpose2d = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> ();
let atg_slow_conv_transpose2d_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> ();
let atg_slow_conv_transpose3d = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> ();
let atg_slow_conv_transpose3d_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Tensor -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> Ptr -> Int -> ();
let atg_smm = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_smooth_l1_loss = extern fn Ptr -> Tensor -> Tensor -> Int -> Double -> ();
let atg_smooth_l1_loss_backward = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> Double -> ();
let atg_smooth_l1_loss_backward_grad_input = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Double -> ();
let atg_smooth_l1_loss_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> Double -> ();
let atg_soft_margin_loss = extern fn Ptr -> Tensor -> Tensor -> Int -> ();
let atg_soft_margin_loss_backward = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg_soft_margin_loss_backward_grad_input = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg_soft_margin_loss_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> ();
let atg_softmax = extern fn Ptr -> Tensor -> Int -> Int -> ();
let atg_softmax_int_out = extern fn Ptr -> Tensor -> Tensor -> Int -> Int -> ();
let atg_softplus = extern fn Ptr -> Tensor -> ();
let atg_softplus_backward = extern fn Ptr -> Tensor -> Tensor -> Scalar -> Scalar -> ();
let atg_softplus_backward_grad_input = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Scalar -> Scalar -> ();
let atg_softplus_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_softshrink = extern fn Ptr -> Tensor -> ();
let atg_softshrink_backward = extern fn Ptr -> Tensor -> Tensor -> Scalar -> ();
let atg_softshrink_backward_grad_input = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Scalar -> ();
let atg_softshrink_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_sort = extern fn Ptr -> Tensor -> Int -> Int -> ();
let atg_sort_stable = extern fn Ptr -> Tensor -> Int -> Int -> Int -> ();
let atg_sort_values = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> Int -> ();
let atg_sort_values_stable = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> Int -> Int -> ();
let atg_sparse_bsc_tensor = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> Int -> ();
let atg_sparse_bsc_tensor_ccol_row_value_size = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Int -> Int -> ();
let atg_sparse_bsr_tensor = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> Int -> ();
let atg_sparse_bsr_tensor_crow_col_value_size = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Int -> Int -> ();
let atg_sparse_compressed_tensor = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> Int -> ();
let atg_sparse_compressed_tensor_comp_plain_value_size = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Int -> Int -> ();
let atg_sparse_coo_tensor = extern fn Ptr -> Ptr -> Int -> Int -> Int -> ();
let atg_sparse_coo_tensor_indices = extern fn Ptr -> Tensor -> Tensor -> Int -> Int -> Int -> ();
let atg_sparse_coo_tensor_indices_size = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Int -> Int -> Int -> ();
let atg_sparse_coo_tensor_size_out = extern fn Ptr -> Tensor -> Ptr -> Int -> ();
let atg_sparse_csc_tensor = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> Int -> ();
let atg_sparse_csc_tensor_ccol_row_value_size = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Int -> Int -> ();
let atg_sparse_csr_tensor = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> Int -> ();
let atg_sparse_csr_tensor_crow_col_value_size = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Int -> Int -> ();
let atg_sparse_dim = extern fn Tensor -> Int;
let atg_sparse_mask = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_sparse_mask_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_sparse_resize = extern fn Ptr -> Tensor -> Ptr -> Int -> Int -> Int -> ();
let atg_sparse_resize_ = extern fn Ptr -> Tensor -> Ptr -> Int -> Int -> Int -> ();
let atg_sparse_resize_and_clear = extern fn Ptr -> Tensor -> Ptr -> Int -> Int -> Int -> ();
let atg_sparse_resize_and_clear_ = extern fn Ptr -> Tensor -> Ptr -> Int -> Int -> Int -> ();
let atg_sparse_resize_and_clear_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Int -> Int -> ();
let atg_sparse_resize_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Int -> Int -> ();
let atg_sparse_sampled_addmm = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_sparse_sampled_addmm_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> ();
let atg_special_airy_ai = extern fn Ptr -> Tensor -> ();
let atg_special_airy_ai_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_special_bessel_j0 = extern fn Ptr -> Tensor -> ();
let atg_special_bessel_j0_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_special_bessel_j1 = extern fn Ptr -> Tensor -> ();
let atg_special_bessel_j1_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_special_bessel_y0 = extern fn Ptr -> Tensor -> ();
let atg_special_bessel_y0_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_special_bessel_y1 = extern fn Ptr -> Tensor -> ();
let atg_special_bessel_y1_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_special_chebyshev_polynomial_t = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_special_chebyshev_polynomial_t_n_scalar = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_special_chebyshev_polynomial_t_n_scalar_out = extern fn Ptr -> Tensor -> Tensor -> Scalar -> ();
let atg_special_chebyshev_polynomial_t_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_special_chebyshev_polynomial_t_x_scalar = extern fn Ptr -> Scalar -> Tensor -> ();
let atg_special_chebyshev_polynomial_t_x_scalar_out = extern fn Ptr -> Tensor -> Scalar -> Tensor -> ();
let atg_special_chebyshev_polynomial_u = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_special_chebyshev_polynomial_u_n_scalar = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_special_chebyshev_polynomial_u_n_scalar_out = extern fn Ptr -> Tensor -> Tensor -> Scalar -> ();
let atg_special_chebyshev_polynomial_u_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_special_chebyshev_polynomial_u_x_scalar = extern fn Ptr -> Scalar -> Tensor -> ();
let atg_special_chebyshev_polynomial_u_x_scalar_out = extern fn Ptr -> Tensor -> Scalar -> Tensor -> ();
let atg_special_chebyshev_polynomial_v = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_special_chebyshev_polynomial_v_n_scalar = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_special_chebyshev_polynomial_v_n_scalar_out = extern fn Ptr -> Tensor -> Tensor -> Scalar -> ();
let atg_special_chebyshev_polynomial_v_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_special_chebyshev_polynomial_v_x_scalar = extern fn Ptr -> Scalar -> Tensor -> ();
let atg_special_chebyshev_polynomial_v_x_scalar_out = extern fn Ptr -> Tensor -> Scalar -> Tensor -> ();
let atg_special_chebyshev_polynomial_w = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_special_chebyshev_polynomial_w_n_scalar = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_special_chebyshev_polynomial_w_n_scalar_out = extern fn Ptr -> Tensor -> Tensor -> Scalar -> ();
let atg_special_chebyshev_polynomial_w_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_special_chebyshev_polynomial_w_x_scalar = extern fn Ptr -> Scalar -> Tensor -> ();
let atg_special_chebyshev_polynomial_w_x_scalar_out = extern fn Ptr -> Tensor -> Scalar -> Tensor -> ();
let atg_special_digamma = extern fn Ptr -> Tensor -> ();
let atg_special_digamma_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_special_entr = extern fn Ptr -> Tensor -> ();
let atg_special_entr_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_special_erf = extern fn Ptr -> Tensor -> ();
let atg_special_erf_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_special_erfc = extern fn Ptr -> Tensor -> ();
let atg_special_erfc_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_special_erfcx = extern fn Ptr -> Tensor -> ();
let atg_special_erfcx_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_special_erfinv = extern fn Ptr -> Tensor -> ();
let atg_special_erfinv_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_special_exp2 = extern fn Ptr -> Tensor -> ();
let atg_special_exp2_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_special_expit = extern fn Ptr -> Tensor -> ();
let atg_special_expit_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_special_expm1 = extern fn Ptr -> Tensor -> ();
let atg_special_expm1_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_special_gammainc = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_special_gammainc_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_special_gammaincc = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_special_gammaincc_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_special_gammaln = extern fn Ptr -> Tensor -> ();
let atg_special_gammaln_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_special_hermite_polynomial_h = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_special_hermite_polynomial_h_n_scalar = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_special_hermite_polynomial_h_n_scalar_out = extern fn Ptr -> Tensor -> Tensor -> Scalar -> ();
let atg_special_hermite_polynomial_h_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_special_hermite_polynomial_h_x_scalar = extern fn Ptr -> Scalar -> Tensor -> ();
let atg_special_hermite_polynomial_h_x_scalar_out = extern fn Ptr -> Tensor -> Scalar -> Tensor -> ();
let atg_special_hermite_polynomial_he = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_special_hermite_polynomial_he_n_scalar = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_special_hermite_polynomial_he_n_scalar_out = extern fn Ptr -> Tensor -> Tensor -> Scalar -> ();
let atg_special_hermite_polynomial_he_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_special_hermite_polynomial_he_x_scalar = extern fn Ptr -> Scalar -> Tensor -> ();
let atg_special_hermite_polynomial_he_x_scalar_out = extern fn Ptr -> Tensor -> Scalar -> Tensor -> ();
let atg_special_i0 = extern fn Ptr -> Tensor -> ();
let atg_special_i0_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_special_i0e = extern fn Ptr -> Tensor -> ();
let atg_special_i0e_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_special_i1 = extern fn Ptr -> Tensor -> ();
let atg_special_i1_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_special_i1e = extern fn Ptr -> Tensor -> ();
let atg_special_i1e_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_special_laguerre_polynomial_l = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_special_laguerre_polynomial_l_n_scalar = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_special_laguerre_polynomial_l_n_scalar_out = extern fn Ptr -> Tensor -> Tensor -> Scalar -> ();
let atg_special_laguerre_polynomial_l_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_special_laguerre_polynomial_l_x_scalar = extern fn Ptr -> Scalar -> Tensor -> ();
let atg_special_laguerre_polynomial_l_x_scalar_out = extern fn Ptr -> Tensor -> Scalar -> Tensor -> ();
let atg_special_legendre_polynomial_p = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_special_legendre_polynomial_p_n_scalar = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_special_legendre_polynomial_p_n_scalar_out = extern fn Ptr -> Tensor -> Tensor -> Scalar -> ();
let atg_special_legendre_polynomial_p_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_special_legendre_polynomial_p_x_scalar = extern fn Ptr -> Scalar -> Tensor -> ();
let atg_special_legendre_polynomial_p_x_scalar_out = extern fn Ptr -> Tensor -> Scalar -> Tensor -> ();
let atg_special_log1p = extern fn Ptr -> Tensor -> ();
let atg_special_log1p_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_special_log_ndtr = extern fn Ptr -> Tensor -> ();
let atg_special_log_ndtr_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_special_log_softmax = extern fn Ptr -> Tensor -> Int -> Int -> ();
let atg_special_logit = extern fn Ptr -> Tensor -> Double -> Char -> ();
let atg_special_logit_out = extern fn Ptr -> Tensor -> Tensor -> Double -> Char -> ();
let atg_special_logsumexp = extern fn Ptr -> Tensor -> Ptr -> Int -> Int -> ();
let atg_special_logsumexp_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Int -> ();
let atg_special_modified_bessel_i0 = extern fn Ptr -> Tensor -> ();
let atg_special_modified_bessel_i0_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_special_modified_bessel_i1 = extern fn Ptr -> Tensor -> ();
let atg_special_modified_bessel_i1_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_special_modified_bessel_k0 = extern fn Ptr -> Tensor -> ();
let atg_special_modified_bessel_k0_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_special_modified_bessel_k1 = extern fn Ptr -> Tensor -> ();
let atg_special_modified_bessel_k1_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_special_multigammaln = extern fn Ptr -> Tensor -> Int -> ();
let atg_special_multigammaln_out = extern fn Ptr -> Tensor -> Tensor -> Int -> ();
let atg_special_ndtr = extern fn Ptr -> Tensor -> ();
let atg_special_ndtr_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_special_ndtri = extern fn Ptr -> Tensor -> ();
let atg_special_ndtri_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_special_polygamma = extern fn Ptr -> Int -> Tensor -> ();
let atg_special_polygamma_out = extern fn Ptr -> Tensor -> Int -> Tensor -> ();
let atg_special_psi = extern fn Ptr -> Tensor -> ();
let atg_special_psi_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_special_round = extern fn Ptr -> Tensor -> Int -> ();
let atg_special_round_out = extern fn Ptr -> Tensor -> Tensor -> Int -> ();
let atg_special_scaled_modified_bessel_k0 = extern fn Ptr -> Tensor -> ();
let atg_special_scaled_modified_bessel_k0_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_special_scaled_modified_bessel_k1 = extern fn Ptr -> Tensor -> ();
let atg_special_scaled_modified_bessel_k1_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_special_shifted_chebyshev_polynomial_t = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_special_shifted_chebyshev_polynomial_t_n_scalar = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_special_shifted_chebyshev_polynomial_t_n_scalar_out = extern fn Ptr -> Tensor -> Tensor -> Scalar -> ();
let atg_special_shifted_chebyshev_polynomial_t_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_special_shifted_chebyshev_polynomial_t_x_scalar = extern fn Ptr -> Scalar -> Tensor -> ();
let atg_special_shifted_chebyshev_polynomial_t_x_scalar_out = extern fn Ptr -> Tensor -> Scalar -> Tensor -> ();
let atg_special_shifted_chebyshev_polynomial_u = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_special_shifted_chebyshev_polynomial_u_n_scalar = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_special_shifted_chebyshev_polynomial_u_n_scalar_out = extern fn Ptr -> Tensor -> Tensor -> Scalar -> ();
let atg_special_shifted_chebyshev_polynomial_u_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_special_shifted_chebyshev_polynomial_u_x_scalar = extern fn Ptr -> Scalar -> Tensor -> ();
let atg_special_shifted_chebyshev_polynomial_u_x_scalar_out = extern fn Ptr -> Tensor -> Scalar -> Tensor -> ();
let atg_special_shifted_chebyshev_polynomial_v = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_special_shifted_chebyshev_polynomial_v_n_scalar = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_special_shifted_chebyshev_polynomial_v_n_scalar_out = extern fn Ptr -> Tensor -> Tensor -> Scalar -> ();
let atg_special_shifted_chebyshev_polynomial_v_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_special_shifted_chebyshev_polynomial_v_x_scalar = extern fn Ptr -> Scalar -> Tensor -> ();
let atg_special_shifted_chebyshev_polynomial_v_x_scalar_out = extern fn Ptr -> Tensor -> Scalar -> Tensor -> ();
let atg_special_shifted_chebyshev_polynomial_w = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_special_shifted_chebyshev_polynomial_w_n_scalar = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_special_shifted_chebyshev_polynomial_w_n_scalar_out = extern fn Ptr -> Tensor -> Tensor -> Scalar -> ();
let atg_special_shifted_chebyshev_polynomial_w_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_special_shifted_chebyshev_polynomial_w_x_scalar = extern fn Ptr -> Scalar -> Tensor -> ();
let atg_special_shifted_chebyshev_polynomial_w_x_scalar_out = extern fn Ptr -> Tensor -> Scalar -> Tensor -> ();
let atg_special_sinc = extern fn Ptr -> Tensor -> ();
let atg_special_sinc_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_special_softmax = extern fn Ptr -> Tensor -> Int -> Int -> ();
let atg_special_spherical_bessel_j0 = extern fn Ptr -> Tensor -> ();
let atg_special_spherical_bessel_j0_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_special_xlog1py = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_special_xlog1py_other_scalar = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_special_xlog1py_other_scalar_out = extern fn Ptr -> Tensor -> Tensor -> Scalar -> ();
let atg_special_xlog1py_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_special_xlog1py_self_scalar = extern fn Ptr -> Scalar -> Tensor -> ();
let atg_special_xlog1py_self_scalar_out = extern fn Ptr -> Tensor -> Scalar -> Tensor -> ();
let atg_special_xlogy = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_special_xlogy_other_scalar = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_special_xlogy_other_scalar_out = extern fn Ptr -> Tensor -> Tensor -> Scalar -> ();
let atg_special_xlogy_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_special_xlogy_self_scalar = extern fn Ptr -> Scalar -> Tensor -> ();
let atg_special_xlogy_self_scalar_out = extern fn Ptr -> Tensor -> Scalar -> Tensor -> ();
let atg_special_zeta = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_special_zeta_other_scalar = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_special_zeta_other_scalar_out = extern fn Ptr -> Tensor -> Tensor -> Scalar -> ();
let atg_special_zeta_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_special_zeta_self_scalar = extern fn Ptr -> Scalar -> Tensor -> ();
let atg_special_zeta_self_scalar_out = extern fn Ptr -> Tensor -> Scalar -> Tensor -> ();
let atg_split = extern fn Tensor -> Int -> Int -> Ptr;
let atg_split_copy = extern fn Tensor -> Int -> Int -> Ptr;
let atg_split_copy_tensor_out = extern fn Ptr -> Int -> Tensor -> Int -> Int -> ();
let atg_split_sizes = extern fn Tensor -> Ptr -> Int -> Int -> Ptr;
let atg_split_with_sizes = extern fn Tensor -> Ptr -> Int -> Int -> Ptr;
let atg_split_with_sizes_copy = extern fn Tensor -> Ptr -> Int -> Int -> Ptr;
let atg_split_with_sizes_copy_out = extern fn Ptr -> Int -> Tensor -> Ptr -> Int -> Int -> ();
let atg_sqrt = extern fn Ptr -> Tensor -> ();
let atg_sqrt_ = extern fn Ptr -> Tensor -> ();
let atg_sqrt_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_square = extern fn Ptr -> Tensor -> ();
let atg_square_ = extern fn Ptr -> Tensor -> ();
let atg_square_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_squeeze = extern fn Ptr -> Tensor -> ();
let atg_squeeze_ = extern fn Ptr -> Tensor -> ();
let atg_squeeze_copy = extern fn Ptr -> Tensor -> ();
let atg_squeeze_copy_dim = extern fn Ptr -> Tensor -> Int -> ();
let atg_squeeze_copy_dim_out = extern fn Ptr -> Tensor -> Tensor -> Int -> ();
let atg_squeeze_copy_dims = extern fn Ptr -> Tensor -> Ptr -> Int -> ();
let atg_squeeze_copy_dims_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg_squeeze_copy_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_squeeze_dim = extern fn Ptr -> Tensor -> Int -> ();
let atg_squeeze_dim_ = extern fn Ptr -> Tensor -> Int -> ();
let atg_squeeze_dims = extern fn Ptr -> Tensor -> Ptr -> Int -> ();
let atg_squeeze_dims_ = extern fn Ptr -> Tensor -> Ptr -> Int -> ();
let atg_sspaddmm = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_sspaddmm_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> ();
let atg_stack = extern fn Ptr -> Ptr -> Int -> Int -> ();
let atg_stack_out = extern fn Ptr -> Tensor -> Ptr -> Int -> Int -> ();
let atg_std = extern fn Ptr -> Tensor -> Int -> ();
let atg_std_correction = extern fn Ptr -> Tensor -> Ptr -> Int -> Scalar -> Int -> ();
let atg_std_correction_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Scalar -> Int -> ();
let atg_std_dim = extern fn Ptr -> Tensor -> Ptr -> Int -> Int -> Int -> ();
let atg_std_mean = extern fn Ptr -> Tensor -> Int -> ();
let atg_std_mean_correction = extern fn Ptr -> Tensor -> Ptr -> Int -> Scalar -> Int -> ();
let atg_std_mean_correction_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Scalar -> Int -> ();
let atg_std_mean_dim = extern fn Ptr -> Tensor -> Ptr -> Int -> Int -> Int -> ();
let atg_std_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Int -> Int -> ();
let atg_stft = extern fn Ptr -> Tensor -> Int -> Int -> Char -> Int -> Char -> Tensor -> Int -> Int -> Int -> Int -> ();
let atg_stft_center = extern fn Ptr -> Tensor -> Int -> Int -> Char -> Int -> Char -> Tensor -> Int -> Ptr -> Int -> Int -> Int -> Int -> Int -> ();
let atg_sub = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_sub_ = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_sub_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_sub_scalar = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_sub_scalar_ = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_sub_scalar_out = extern fn Ptr -> Tensor -> Tensor -> Scalar -> ();
let atg_subtract = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_subtract_ = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_subtract_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_subtract_scalar = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_subtract_scalar_ = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_sum = extern fn Ptr -> Tensor -> Int -> ();
let atg_sum_dim_intlist = extern fn Ptr -> Tensor -> Ptr -> Int -> Int -> Int -> ();
let atg_sum_intlist_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Int -> Int -> ();
let atg_sum_out = extern fn Ptr -> Tensor -> Tensor -> Int -> ();
let atg_sum_to_size = extern fn Ptr -> Tensor -> Ptr -> Int -> ();
let atg_svd = extern fn Ptr -> Tensor -> Int -> Int -> ();
let atg_svd_u = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Int -> ();
let atg_swapaxes = extern fn Ptr -> Tensor -> Int -> Int -> ();
let atg_swapaxes_ = extern fn Ptr -> Tensor -> Int -> Int -> ();
let atg_swapdims = extern fn Ptr -> Tensor -> Int -> Int -> ();
let atg_swapdims_ = extern fn Ptr -> Tensor -> Int -> Int -> ();
let atg_t = extern fn Ptr -> Tensor -> ();
let atg_t_ = extern fn Ptr -> Tensor -> ();
let atg_t_copy = extern fn Ptr -> Tensor -> ();
let atg_t_copy_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_take = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_take_along_dim = extern fn Ptr -> Tensor -> Tensor -> Int -> Char -> ();
let atg_take_along_dim_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> Char -> ();
let atg_take_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_tan = extern fn Ptr -> Tensor -> ();
let atg_tan_ = extern fn Ptr -> Tensor -> ();
let atg_tan_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_tanh = extern fn Ptr -> Tensor -> ();
let atg_tanh_ = extern fn Ptr -> Tensor -> ();
let atg_tanh_backward = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_tanh_backward_grad_input = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_tanh_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_tensor_split = extern fn Tensor -> Int -> Int -> Ptr;
let atg_tensor_split_indices = extern fn Tensor -> Ptr -> Int -> Int -> Ptr;
let atg_tensor_split_tensor_indices_or_sections = extern fn Tensor -> Tensor -> Int -> Ptr;
let atg_tensordot = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> ();
let atg_tensordot_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> ();
let atg_threshold = extern fn Ptr -> Tensor -> Scalar -> Scalar -> ();
let atg_threshold_ = extern fn Ptr -> Tensor -> Scalar -> Scalar -> ();
let atg_threshold_backward = extern fn Ptr -> Tensor -> Tensor -> Scalar -> ();
let atg_threshold_backward_grad_input = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Scalar -> ();
let atg_threshold_out = extern fn Ptr -> Tensor -> Tensor -> Scalar -> Scalar -> ();
let atg_tile = extern fn Ptr -> Tensor -> Ptr -> Int -> ();
let atg_to = extern fn Ptr -> Tensor -> Int -> ();
let atg_to_dense = extern fn Ptr -> Tensor -> Int -> Int -> ();
let atg_to_dense_backward = extern fn Ptr -> Tensor -> Tensor -> Int -> ();
let atg_to_device = extern fn Ptr -> Tensor -> Int -> Int -> Int -> Int -> ();
let atg_to_dtype = extern fn Ptr -> Tensor -> Int -> Int -> Int -> ();
let atg_to_dtype_layout = extern fn Ptr -> Tensor -> Int -> Int -> Int -> Int -> ();
let atg_to_mkldnn = extern fn Ptr -> Tensor -> Int -> ();
let atg_to_mkldnn_backward = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_to_mkldnn_out = extern fn Ptr -> Tensor -> Tensor -> Int -> ();
let atg_to_other = extern fn Ptr -> Tensor -> Tensor -> Int -> Int -> ();
let atg_to_padded_tensor = extern fn Ptr -> Tensor -> Double -> Ptr -> Int -> ();
let atg_to_padded_tensor_out = extern fn Ptr -> Tensor -> Tensor -> Double -> Ptr -> Int -> ();
let atg_to_sparse = extern fn Ptr -> Tensor -> int8_t -> Ptr -> Int -> Int -> Char -> ();
let atg_to_sparse_bsc = extern fn Ptr -> Tensor -> Ptr -> Int -> Int -> Char -> ();
let atg_to_sparse_bsr = extern fn Ptr -> Tensor -> Ptr -> Int -> Int -> Char -> ();
let atg_to_sparse_csc = extern fn Ptr -> Tensor -> Int -> Char -> ();
let atg_to_sparse_csr = extern fn Ptr -> Tensor -> Int -> Char -> ();
let atg_to_sparse_sparse_dim = extern fn Ptr -> Tensor -> Int -> ();
let atg_topk = extern fn Ptr -> Tensor -> Int -> Int -> Int -> Int -> ();
let atg_topk_values = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Int -> Int -> Int -> Int -> ();
let atg_totype = extern fn Ptr -> Tensor -> Int -> ();
let atg_trace = extern fn Ptr -> Tensor -> ();
let atg_trace_backward = extern fn Ptr -> Tensor -> Ptr -> Int -> ();
let atg_trace_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_transpose = extern fn Ptr -> Tensor -> Int -> Int -> ();
let atg_transpose_ = extern fn Ptr -> Tensor -> Int -> Int -> ();
let atg_transpose_copy = extern fn Ptr -> Tensor -> Int -> Int -> ();
let atg_transpose_copy_int_out = extern fn Ptr -> Tensor -> Tensor -> Int -> Int -> ();
let atg_trapezoid = extern fn Ptr -> Tensor -> Int -> ();
let atg_trapezoid_x = extern fn Ptr -> Tensor -> Tensor -> Int -> ();
let atg_trapz = extern fn Ptr -> Tensor -> Tensor -> Int -> ();
let atg_trapz_dx = extern fn Ptr -> Tensor -> Double -> Int -> ();
let atg_triangular_solve = extern fn Ptr -> Tensor -> Tensor -> Int -> Int -> Int -> ();
let atg_triangular_solve_x = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Int -> Int -> ();
let atg_tril = extern fn Ptr -> Tensor -> Int -> ();
let atg_tril_ = extern fn Ptr -> Tensor -> Int -> ();
let atg_tril_indices = extern fn Ptr -> Int -> Int -> Int -> Int -> Int -> ();
let atg_tril_indices_out = extern fn Ptr -> Tensor -> Int -> Int -> Int -> ();
let atg_tril_out = extern fn Ptr -> Tensor -> Tensor -> Int -> ();
let atg_triplet_margin_loss = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Double -> Double -> Double -> Int -> Int -> ();
let atg_triu = extern fn Ptr -> Tensor -> Int -> ();
let atg_triu_ = extern fn Ptr -> Tensor -> Int -> ();
let atg_triu_indices = extern fn Ptr -> Int -> Int -> Int -> Int -> Int -> ();
let atg_triu_indices_out = extern fn Ptr -> Tensor -> Int -> Int -> Int -> ();
let atg_triu_out = extern fn Ptr -> Tensor -> Tensor -> Int -> ();
let atg_true_divide = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_true_divide_ = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_true_divide_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_true_divide_scalar = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_true_divide_scalar_ = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_trunc = extern fn Ptr -> Tensor -> ();
let atg_trunc_ = extern fn Ptr -> Tensor -> ();
let atg_trunc_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_type_as = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_unbind = extern fn Tensor -> Int -> Ptr;
let atg_unbind_copy = extern fn Tensor -> Int -> Ptr;
let atg_unbind_copy_int_out = extern fn Ptr -> Int -> Tensor -> Int -> ();
let atg_unflatten = extern fn Ptr -> Tensor -> Int -> Ptr -> Int -> ();
let atg_unflatten_dense_tensors = extern fn Tensor -> Ptr -> Int -> Ptr;
let atg_unfold = extern fn Ptr -> Tensor -> Int -> Int -> Int -> ();
let atg_unfold_backward = extern fn Ptr -> Tensor -> Ptr -> Int -> Int -> Int -> Int -> ();
let atg_unfold_backward_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Int -> Int -> Int -> ();
let atg_unfold_copy = extern fn Ptr -> Tensor -> Int -> Int -> Int -> ();
let atg_unfold_copy_out = extern fn Ptr -> Tensor -> Tensor -> Int -> Int -> Int -> ();
let atg_uniform = extern fn Ptr -> Tensor -> Double -> Double -> ();
let atg_uniform_ = extern fn Ptr -> Tensor -> Double -> Double -> ();
let atg_uniform_out = extern fn Ptr -> Tensor -> Tensor -> Double -> Double -> ();
let atg_unique_consecutive = extern fn Ptr -> Tensor -> Int -> Int -> Int -> Char -> ();
let atg_unique_consecutive_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Int -> Int -> Char -> ();
let atg_unique_dim = extern fn Ptr -> Tensor -> Int -> Int -> Int -> Int -> ();
let atg_unique_dim_consecutive = extern fn Ptr -> Tensor -> Int -> Int -> Int -> ();
let atg_unique_dim_consecutive_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Int -> Int -> ();
let atg_unique_dim_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> Int -> Int -> Int -> Int -> ();
let atg_unsafe_chunk = extern fn Tensor -> Int -> Int -> Ptr;
let atg_unsafe_split = extern fn Tensor -> Int -> Int -> Ptr;
let atg_unsafe_split_tensor_out = extern fn Ptr -> Int -> Tensor -> Int -> Int -> ();
let atg_unsafe_split_with_sizes = extern fn Tensor -> Ptr -> Int -> Int -> Ptr;
let atg_unsafe_split_with_sizes_out = extern fn Ptr -> Int -> Tensor -> Ptr -> Int -> Int -> ();
let atg_unsqueeze = extern fn Ptr -> Tensor -> Int -> ();
let atg_unsqueeze_ = extern fn Ptr -> Tensor -> Int -> ();
let atg_unsqueeze_copy = extern fn Ptr -> Tensor -> Int -> ();
let atg_unsqueeze_copy_out = extern fn Ptr -> Tensor -> Tensor -> Int -> ();
let atg_upsample_bicubic2d = extern fn Ptr -> Tensor -> Ptr -> Int -> Int -> Double -> Char -> Double -> Char -> ();
let atg_upsample_bicubic2d_backward = extern fn Ptr -> Tensor -> Ptr -> Int -> Ptr -> Int -> Int -> Double -> Char -> Double -> Char -> ();
let atg_upsample_bicubic2d_backward_grad_input = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Int -> Double -> Char -> Double -> Char -> ();
let atg_upsample_bicubic2d_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Int -> Double -> Char -> Double -> Char -> ();
let atg_upsample_bicubic2d_vec = extern fn Ptr -> Tensor -> Ptr -> Int -> Int -> Ptr -> Int -> ();
let atg_upsample_bilinear2d = extern fn Ptr -> Tensor -> Ptr -> Int -> Int -> Double -> Char -> Double -> Char -> ();
let atg_upsample_bilinear2d_backward = extern fn Ptr -> Tensor -> Ptr -> Int -> Ptr -> Int -> Int -> Double -> Char -> Double -> Char -> ();
let atg_upsample_bilinear2d_backward_grad_input = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Int -> Double -> Char -> Double -> Char -> ();
let atg_upsample_bilinear2d_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Int -> Double -> Char -> Double -> Char -> ();
let atg_upsample_bilinear2d_vec = extern fn Ptr -> Tensor -> Ptr -> Int -> Int -> Ptr -> Int -> ();
let atg_upsample_bilinear2d_vec_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Int -> Ptr -> Int -> ();
let atg_upsample_linear1d = extern fn Ptr -> Tensor -> Ptr -> Int -> Int -> Double -> Char -> ();
let atg_upsample_linear1d_backward = extern fn Ptr -> Tensor -> Ptr -> Int -> Ptr -> Int -> Int -> Double -> Char -> ();
let atg_upsample_linear1d_backward_grad_input = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Int -> Double -> Char -> ();
let atg_upsample_linear1d_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Int -> Double -> Char -> ();
let atg_upsample_linear1d_vec = extern fn Ptr -> Tensor -> Ptr -> Int -> Int -> Ptr -> Int -> ();
let atg_upsample_nearest1d = extern fn Ptr -> Tensor -> Ptr -> Int -> Double -> Char -> ();
let atg_upsample_nearest1d_backward = extern fn Ptr -> Tensor -> Ptr -> Int -> Ptr -> Int -> Double -> Char -> ();
let atg_upsample_nearest1d_backward_grad_input = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Double -> Char -> ();
let atg_upsample_nearest1d_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Double -> Char -> ();
let atg_upsample_nearest1d_vec = extern fn Ptr -> Tensor -> Ptr -> Int -> Ptr -> Int -> ();
let atg_upsample_nearest2d = extern fn Ptr -> Tensor -> Ptr -> Int -> Double -> Char -> Double -> Char -> ();
let atg_upsample_nearest2d_backward = extern fn Ptr -> Tensor -> Ptr -> Int -> Ptr -> Int -> Double -> Char -> Double -> Char -> ();
let atg_upsample_nearest2d_backward_grad_input = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Double -> Char -> Double -> Char -> ();
let atg_upsample_nearest2d_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Double -> Char -> Double -> Char -> ();
let atg_upsample_nearest2d_vec = extern fn Ptr -> Tensor -> Ptr -> Int -> Ptr -> Int -> ();
let atg_upsample_nearest2d_vec_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> ();
let atg_upsample_nearest3d = extern fn Ptr -> Tensor -> Ptr -> Int -> Double -> Char -> Double -> Char -> Double -> Char -> ();
let atg_upsample_nearest3d_backward = extern fn Ptr -> Tensor -> Ptr -> Int -> Ptr -> Int -> Double -> Char -> Double -> Char -> Double -> Char -> ();
let atg_upsample_nearest3d_backward_grad_input = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Double -> Char -> Double -> Char -> Double -> Char -> ();
let atg_upsample_nearest3d_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Double -> Char -> Double -> Char -> Double -> Char -> ();
let atg_upsample_nearest3d_vec = extern fn Ptr -> Tensor -> Ptr -> Int -> Ptr -> Int -> ();
let atg_upsample_trilinear3d = extern fn Ptr -> Tensor -> Ptr -> Int -> Int -> Double -> Char -> Double -> Char -> Double -> Char -> ();
let atg_upsample_trilinear3d_backward = extern fn Ptr -> Tensor -> Ptr -> Int -> Ptr -> Int -> Int -> Double -> Char -> Double -> Char -> Double -> Char -> ();
let atg_upsample_trilinear3d_backward_grad_input = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Ptr -> Int -> Int -> Double -> Char -> Double -> Char -> Double -> Char -> ();
let atg_upsample_trilinear3d_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Int -> Double -> Char -> Double -> Char -> Double -> Char -> ();
let atg_upsample_trilinear3d_vec = extern fn Ptr -> Tensor -> Ptr -> Int -> Int -> Ptr -> Int -> ();
let atg_value_selecting_reduction_backward = extern fn Ptr -> Tensor -> Int -> Tensor -> Ptr -> Int -> Int -> ();
let atg_values = extern fn Ptr -> Tensor -> ();
let atg_values_copy = extern fn Ptr -> Tensor -> ();
let atg_values_copy_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_vander = extern fn Ptr -> Tensor -> Int -> Char -> Int -> ();
let atg_var = extern fn Ptr -> Tensor -> Int -> ();
let atg_var_correction = extern fn Ptr -> Tensor -> Ptr -> Int -> Scalar -> Int -> ();
let atg_var_correction_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Scalar -> Int -> ();
let atg_var_dim = extern fn Ptr -> Tensor -> Ptr -> Int -> Int -> Int -> ();
let atg_var_mean = extern fn Ptr -> Tensor -> Int -> ();
let atg_var_mean_correction = extern fn Ptr -> Tensor -> Ptr -> Int -> Scalar -> Int -> ();
let atg_var_mean_correction_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Ptr -> Int -> Scalar -> Int -> ();
let atg_var_mean_dim = extern fn Ptr -> Tensor -> Ptr -> Int -> Int -> Int -> ();
let atg_var_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> Int -> Int -> ();
let atg_vdot = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_vdot_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_view = extern fn Ptr -> Tensor -> Ptr -> Int -> ();
let atg_view_as = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_view_as_complex = extern fn Ptr -> Tensor -> ();
let atg_view_as_complex_copy = extern fn Ptr -> Tensor -> ();
let atg_view_as_complex_copy_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_view_as_real = extern fn Ptr -> Tensor -> ();
let atg_view_as_real_copy = extern fn Ptr -> Tensor -> ();
let atg_view_as_real_copy_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_view_copy = extern fn Ptr -> Tensor -> Ptr -> Int -> ();
let atg_view_copy_dtype = extern fn Ptr -> Tensor -> Int -> ();
let atg_view_copy_dtype_out = extern fn Ptr -> Tensor -> Tensor -> Int -> ();
let atg_view_copy_out = extern fn Ptr -> Tensor -> Tensor -> Ptr -> Int -> ();
let atg_view_dtype = extern fn Ptr -> Tensor -> Int -> ();
let atg_vsplit = extern fn Tensor -> Int -> Ptr;
let atg_vsplit_array = extern fn Tensor -> Ptr -> Int -> Ptr;
let atg_vstack = extern fn Ptr -> Ptr -> Int -> ();
let atg_vstack_out = extern fn Ptr -> Tensor -> Ptr -> Int -> ();
let atg_where = extern fn Tensor -> Ptr;
let atg_where_scalar = extern fn Ptr -> Tensor -> Scalar -> Scalar -> ();
let atg_where_scalarother = extern fn Ptr -> Tensor -> Tensor -> Scalar -> ();
let atg_where_scalarself = extern fn Ptr -> Tensor -> Scalar -> Tensor -> ();
let atg_where_self = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_where_self_out = extern fn Ptr -> Tensor -> Tensor -> Tensor -> Tensor -> ();
let atg_xlogy = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_xlogy_ = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_xlogy_outscalar_other = extern fn Ptr -> Tensor -> Tensor -> Scalar -> ();
let atg_xlogy_outscalar_self = extern fn Ptr -> Tensor -> Scalar -> Tensor -> ();
let atg_xlogy_outtensor = extern fn Ptr -> Tensor -> Tensor -> Tensor -> ();
let atg_xlogy_scalar_other = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_xlogy_scalar_other_ = extern fn Ptr -> Tensor -> Scalar -> ();
let atg_xlogy_scalar_self = extern fn Ptr -> Scalar -> Tensor -> ();
let atg_zero = extern fn Ptr -> Tensor -> ();
let atg_zero_ = extern fn Ptr -> Tensor -> ();
let atg_zero_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_zeros = extern fn Ptr -> Ptr -> Int -> Int -> Int -> ();
let atg_zeros_like = extern fn Ptr -> Tensor -> ();
let atg_zeros_like_out = extern fn Ptr -> Tensor -> Tensor -> ();
let atg_zeros_out = extern fn Ptr -> Tensor -> Ptr -> Int -> ();

