open engine/bindings/Synth;
open engine/bindings/Sched;
open engine/bindings/MIDI;
import lib/Math;

let Snare = module
  let synth = (fn () -> 
    let trig = inlet 0. in
    sin_node 220. + sin_node 357.
      |> (*) (aslr_node 0. 1. 0.08 0.1 trig)
      |> (+) (white_noise_node ())
      |> tanh_node 5. |> (*) (aslr_node 0. 1. 0.05 0.1 trig)

    ;) |> play_tpl
  ;

  let trig = fn () ->
    let fo = get_tl_tick () in
    set_input_trig_offset synth 0 fo
  ;;
;

let Hihat = module
  let synth = (fn () -> 
    let trig = inlet 0. in
    let env = perc_env_node (trig_range_node 0.2 2. trig) trig in
    env
      |> math_node (Math.unipolar_scale 100. 5000.)
      |> sin_node
      |> (+) (white_noise_node ())
      |> biquad_hp_node (trig_range_node 1000. 8000. trig) 4.
      |> comb_node 0.02 0.1 0.7
      |> (*) env

    ;) |> play_tpl
  ;

  let trig = fn () ->
    let fo = get_tl_tick () in
    set_input_trig_offset synth 0 fo
  ;;

  let input = fn q t cor ->
    print "hihat input\n";
    cor 
    |> cor_map (fn d -> trig (); d * q;)
    |> play_routine t schedule_event
  ;;
;

let Kick = module
  #Envs:
  let penv = [|
    0.000000, 0.000000, 2.400000,
    1., 0.185902, -2.300000,
    0.011111, 2.814099, 1.300000,
    0.000000
  |]
  |> array_to_buf;


  let ampenv = [|
    0.000000, 0.000000, 2.400000,
    1.000000, 2.210165, -2.000000,
    1.000000, 0.789836, 1.300000,
    0.000000
  |]
  |> array_to_buf;

  let synth = (fn () -> 
    let trig = inlet 0.;
    let noise = (perc_env_node 0.2 trig) * (white_noise_node ()) ;

    let sig = buf_env_node 1. (buf_ref penv) trig
    |> math_node (Math.unipolar_scale 55. 200.)
    |> sin_node 
    |> (+) noise
    ;

    let sig = (sig + (dyn_tanh_node (5 * buf_env_node 0.03 (buf_ref ampenv) trig) sig));

    sig + (
      sig
      |> biquad_hp_node 100 1
      |> reverb_node 0.2 1. 0. 1.
    )
    |> (*) (buf_env_node 0.12 (buf_ref ampenv) trig)

    ;)
    |> play_tpl
  ;

  let trig = fn () -> 
    let fo = get_tl_tick () in
    set_input_trig_offset synth 0 fo
  ;;
;

let Acid = module

  let filtenv = [|
    0.000000, 0.000000, 2.400000,
    1., 0.185902, -2.300000,
    0.011111, 2.814099, 1.300000,
    0.000000
  |]
  |> array_to_buf;

  let ampenv =
  [|
    0.000000, 0.000000, 2.400000,
    1.000000, 0.1, -2.300000,
    0.971429, 0.2, -1.200000,
    0.000000
  |]
  |> array_to_buf;

  let synth = (fn () -> 
    let f = inlet 50. |> lag_node 0.05;
    let trig = inlet 0.0; 
    let chirp_decay = inlet 1.;
    let ff = buf_env_node chirp_decay (buf_ref filtenv) trig  
    |> math_node (Math.unipolar_scale 200. 3000.);
    let res = inlet 8.;
    sq_node f
    |> (+) (sq_node @@ f * 1.01)
    |> (+) (sq_node @@ f * 1.02)
    |> (+) (sq_node @@ f * 2.)
    |> (*) 0.2
    |> biquad_lp_node ff res 
    # |> dyn_tanh_node res 
    |> (*) @@ gated_buf_env_node (buf_ref ampenv) trig
  ;)
  |> play_tpl
  ;

  let trig = fn f dur pw ->
    let fo = get_tl_tick () in (
      trigger_gate fo (pw * dur) 1 synth;
      set_input_scalar_offset synth 0 fo f
    );
    dur
  ;;


  let handlers = fn () ->
    register_cc_handler (fn x ->
    set_input_scalar synth 2 (Math.unipolar_scale 0.1 2. x) 
    ;) 0 22;

    register_cc_handler (fn x ->
    set_input_scalar synth 3 (Math.unipolar_scale 1. 10. x) 
    ;) 0 21

  ;;


  let _proto_cor = fn () -> yield 0.;;
  let input_ref = _proto_cor ();

  let input = fn t cor ->
    cor_stop input_ref;
    let new_cor = cor
    |> cor_map (fn (p, d, leg, note): (Int, Double, Double, Int) -> 
      match p with
      | 0 -> ()
      | 1 -> (trig (midi_to_freq note) d leg; ())
      ;
      d
    ;);

    cor_stop input_ref;
    cor_replace input_ref new_cor;

    input_ref |> play_routine t schedule_event
  ;;

  let stop = fn () ->
    cor_stop input_ref
  ;;
;

# let rout = [
#   (1, 0.25, 0.9, 35), 
#   (1, 0.25, 0.9, 35), 
#   (1, 0.25, 0.9, 35), 
#   (1, 0.25, 0.9, 35), 
#   (1, 0.25, 0.9, 19), 
#   (1, 0.25, 0.9, 35), 
#   (0, 0.5, 0., 0),
#
#   (1, 0.25, 0.9, 35), 
#   (1, 0.25, 0.9, 35), 
#   (1, 0.25, 0.9, 50), 
#   (1, 0.25, 0.9, 54), 
#   (1, 0.25, 0.9, 55), 
#   (1, 0.25, 0.9, 55), 
#   (1, 0.25, 0.9, 55), 
#   (0, 0.25, 0., 0),
#
#   (1, 0.25, 0.9, 31), 
#   (1, 0.25, 0.9, 31), 
#   (1, 0.25, 0.1, 31), 
#   (1, 0.25, 1.2, 31), 
#   (1, 0.25, 0.1, 31), 
#   (1, 0.25, 0.9, 31), 
#   (0, 0.5, 0., 0),
#
#   (1, 0.25, 0.9, 31), 
#   (1, 0.25, 0.9, 31), 
#   (1, 0.25, 0.8, 60), 
#   (1, 0.25, 1.2, 60), 
#   (1, 0.25, 1.2, 60), 
#   (1, 0.25, 0.5, 59), 
#   (1, 0.25, 0.1, 59), 
#   (1, 0.25, 0.9, 59), 
# ] |> iter_of_list |> cor_loop;

# Acid.handlers ();

# let q = 60./130. in
#
# defer_quant q (fn t ->
#   iter_of_list [
#   1.5, 1.75, 0.25, 0.5,
#   1.5, 1.,   1.5,
#   1.5, 1.75, 0.25, 0.5,
#   1.5, 1.,   1.5,
#   ]
#   |> cor_loop
#   |> cor_map (fn d ->
#     Kick.trig ();
#     d * q
#   ;)
#   |> play_routine t schedule_event
#   ;
#
#   iter_of_list [
#   (0, 1.), (1, 1.), (0, 1.), (1, 1.),
#   (0, 1.), (1, 1.), (0, 1.), (1, 1.),
#   (0, 1.), (1, 1.), (0, 1.), (1, 1.),
#   (0, 1.), (1, 1.), (0, 1.), (1, 0.25), (1, 0.5), (1, 0.25)
#   ]
#   |> cor_loop
#   |> cor_map (fn (p, d): (Double, Int) ->
#     match p with 
#     | 0 -> ()
#     | 1 -> (Snare.trig (); ())
#     ;
#     d * q
#   ;)
#   |> play_routine t schedule_event
#   ;
#
#   iter_of_list [0.25]
#   |> cor_loop
#   |> cor_map (fn d ->
#     Hihat.trig ();
#     d * q
#   ;)
#   |> play_routine t schedule_event
#   ;
#
#
#   rout |> cor_map (fn (p, d, leg, note): (Int, Double, Double, Int) -> (p, d * q, leg, note);)
#   |> (Acid.input) t
#   ;
#
# );


let q = 60./130. in
defer_quant q (fn t ->
  iter_of_list [0.25]
  |> cor_loop
  |> cor_map (fn d ->
    Hihat.trig ();
    d * q
  ;)
  |> play_routine t schedule_event
  ;

  # iter_of_list [
  # 1.5, 1.75, 0.25, 0.5,
  # 1.5, 1.,   1.5,
  # 1.5, 1.75, 0.25, 0.5,
  # 1.5, 1.,   1.5,
  # ]
  #
  iter_of_list [
    1.5,
    1.5,
    1.5,
    .5,
    1.5,
    .5,
  ]
  |> cor_loop
  |> cor_map (fn d ->
    Kick.trig ();
    d * q
  ;)
  |> play_routine t schedule_event
;)
