# let K = fn z q ->
#   (fn () -> 2 + q + z)
# ;;

let fmul = fn a b ->
  a * b
;;

let fmul_concrete = fn a: (Int) b: (Int) ->
  a * b
;;


# 2nd-order functions
let f = fn c ->
  let a = 1;
  let b = 2;

  fn () ->
    a + b + c;
;;

let f2 = fn () ->
  let a = 1;
  let b = 2;

  fn () ->
    a + b;
;;


let test = module () ->
  # let test_cl_int = (let l = K 3 4 in l () == 9) ;
  # let test_cl_int2 = (let l = K 3 5 in l () == 10) ;
  # let test_cl_num2 = (let l = K 3. 5. in l () == 10.) ;
  let test1 = (let K = fmul 3 in K 3 == 9);
  let test2 = (let K = fmul 3. in K 3 == 9.);
  let test3 = (let K = fmul_concrete 3 in K 3 == 9);
  let test4 = (let K = (+) 1 in K 3 == 4);
  let test5 = (let K = (+) in K 3 1 == 4);
  let test7 = (let K = f 3 in K () == 6);
  let test6 = (let K = f 2 in K () == 5);
  let test8 = (let K = f 4 in K () == 7);
  let test9 = (let K = f2 () in K () == 3);

;
