import engine/bindings/MIDI;
open engine/bindings/Sched; 
open engine/bindings/Synth; 
open lib/Ref;


import Columnar;

let seq = (
  note:  array_fill_const 32 -1,
  dur:   array_fill_const 32 0.1,
  res:   array_fill_const 32 0.5,
  slide: array_fill_const 32 0.1,
  chirp: array_fill_const 32 0.5
);

let cur_tick_ref = Ref 0;


import Launchpad;

let acid_send_to_midi_ctrls = fn () ->
  let grid_press_handler = fn i -> 
    let tick = i % (array_size seq.note);
    array_set 0 cur_tick_ref tick;
    let note = 7 - i / (array_size seq.note);
    let status = array_at seq.note tick in (
    match status with
    | -1 -> array_set tick seq.note note
    | n if n == note -> array_set tick seq.note -1
    | _ -> array_set tick seq.note note
    );
    ()
  ;;

  let grid_is_set = fn i -> 
    let tick = i % (array_size seq.note);
    let note = 7 - i / (array_size seq.note);
    let status = array_at seq.note tick;
    match status with
    | -1 -> false
    | n if n == note -> true
    | _ -> false
  ;;

  Launchpad.setup (array_size seq.note) grid_press_handler grid_is_set;
  MIDI.register_cc_handler 2 0 (fn v: (Double) -> 
    let tick = deref cur_tick_ref; 
    array_set tick seq.dur v;
    ()
  );

  MIDI.register_cc_handler 2 1 (fn v: (Double) -> 
    let tick = deref cur_tick_ref; 
    array_set tick seq.res v;
    ()
  );

  MIDI.register_cc_handler 2 2 (fn v: (Double) -> 
    let tick = deref cur_tick_ref; 
    array_set tick seq.slide v;
    ()
  );

  MIDI.register_cc_handler 2 3 (fn v: (Double) -> 
    let tick = deref cur_tick_ref; 
    array_set tick seq.chirp v;
    ()
  )
;;

array_set 0 Launchpad.slots acid_send_to_midi_ctrls;


let pattern = [|
  (0, 0.), (0, 0.), (0, 0.), (0, 0.), (0, 0.), (0, 0.), (0, 0.), (0, 0.), (0, 0.), (0, 0.), (0, 0.), (0, 0.), (0, 0.), (0, 0.), (0, 0.), (0, 0.), 
  (0, 0.), (0, 0.), (0, 0.), (0, 0.), (0, 0.), (0, 0.), (0, 0.), (0, 0.), (0, 0.), (0, 0.), (0, 0.), (0, 0.), (0, 0.), (0, 0.), (0, 0.), (0, 0.), 
  (0, 0.), (0, 0.), (0, 0.), (0, 0.), (0, 0.), (0, 0.), (0, 0.), (0, 0.), (0, 0.), (0, 0.), (0, 0.), (0, 0.), (0, 0.), (0, 0.), (0, 0.), (0, 0.), 
  (0, 0.), (0, 0.), (0, 0.), (0, 0.), (0, 0.), (0, 0.), (0, 0.), (0, 0.), (0, 0.), (0, 0.), (0, 0.), (0, 0.), (0, 0.), (0, 0.), (0, 0.), (0, 0.), 
  (0, 0.), (0, 0.), (1, 0.), (0, 0.), (0, 0.), (0, 0.), (1, 0.), (0, 0.), (0, 0.), (0, 0.), (1, 0.), (0, 0.), (0, 0.), (0, 0.), (1, 0.), (0, 0.), 
  (1, 0.), (1, 0.), (0, 0.), (1, 0.), (1, 0.), (1, 0.), (0, 0.), (1, 0.), (1, 0.), (1, 0.), (0, 0.), (1, 0.), (1, 0.), (1, 0.), (0, 0.), (1, 0.), 
  (0, 0.), (0, 0.), (0, 0.), (0, 0.), (0, 0.), (0, 0.), (0, 0.), (0, 0.), (0, 0.), (0, 0.), (0, 0.), (0, 0.), (1, 0.), (0, 0.), (0, 0.), (0, 0.), 
  (1, 0.), (0, 0.), (0, 0.), (1, 0.), (0, 0.), (0, 0.), (1, 0.), (0, 0.), (0, 0.), (1, 0.), (0, 0.), (0, 0.), (0, 0.), (1, 0.), (0, 0.), (0, 0.), 
|];

let col = array_fill 8 (fn i: (Int) -> (0, 0.));

let set_col = fn
  i: (Int)
  j: (Int)
  size: (Int)
  arr: (Array of (Int, Double))
  dest: (Array of (Int, Double)) ->

  match i with
  | i if i < size -> (
    array_set i dest (array_at arr ((i * 16) + j)) ;
    
    set_col (i + 1) j size arr dest
  ) 
  | _ -> dest
;;

let drums_send_to_midi_ctrls = fn () ->
  let grid_press_handler = fn i: (Int) -> 
    let (status, val) = array_at pattern i;
    match status with 
    | 1 -> array_set i pattern (0, val)
    | 0 -> array_set i pattern (1, val)
  ;;

  let grid_is_set = fn i: (Int) -> 
    match (array_at pattern i) with
    | (1, _) -> true
    | (0, _) -> false
  ;;

  Launchpad.setup 16 grid_press_handler grid_is_set
;;
array_set 1 Launchpad.slots drums_send_to_midi_ctrls;



let Kick_ = module
  # import synths/Kick;
  let buf = load_soundfile @@ cstr "/Users/adam/Desktop/musicradar-techno-drum-fx-samples/Drum_Hits/Kick11.wav";
  let synth = (fn () ->
    let trig = inlet 0.; # 0
    let imp = lfpulse_node 0. (inlet 0.) trig; # 1
    let gate = inlet 0.; # 2
    bufplayer_trig_node (buf_ref buf) (44100./ 48000.) (inlet 0.) imp # 3 
    |> (*) (aslr_node 0. 4. 0.2 0.1 trig)
  )
  |> play_tpl
  ;

  let trig = fn () -> 
    # Kick.trig ();
    let fo = get_tl_tick ();
    set_input_trig_offset synth 0 fo
  ;;
;

let Snare = module

  let buf = load_soundfile @@ cstr "/Users/adam/Desktop/musicradar-techno-drum-fx-samples/Drum_Hits/Snare03.wav";
  let synth = (fn () ->
    let trig = inlet 0.; # 0
    let imp = lfpulse_node 0. (inlet 0.) trig; # 1
    let gate = inlet 0.; # 2
    bufplayer_trig_node (buf_ref buf) (44100. / 48000.) (inlet 0.) imp # 3 
    |> (*) (aslr_node 0. 4. 0.2 0.1 trig)
  )
  |> play_tpl
  ;

  let trig = fn () -> 
    let fo = get_tl_tick ();
    set_input_trig_offset synth 0 fo
  ;;
;

let Hihat = module

  let buf = load_soundfile @@ cstr "/Users/adam/Desktop/musicradar-techno-drum-fx-samples/Drum_Hits/Closedhat12.wav";
  let synth = (fn () ->
    let trig = inlet 0.; # 0
    let imp = lfpulse_node 0. (inlet 0.) trig; # 1
    let gate = inlet 0.; # 2
    bufplayer_trig_node (buf_ref buf) (44100. / 48000.) (inlet 0.) imp # 3 
    |> (*) (aslr_node 0. 3. 0.2 0.1 trig)
  )
  |> play_tpl
  ;

  let openh = load_soundfile @@ cstr "/Users/adam/Desktop/musicradar-techno-drum-fx-samples/Drum_Hits/Openhat01.wav";
  let openh_synth = (fn () ->
    let trig = inlet 0.; # 0
    let imp = lfpulse_node 0. (inlet 0.) trig; # 1
    let gate = inlet 0.; # 2
    bufplayer_trig_node (buf_ref openh) (44100. / 48000.) (inlet 0.) imp # 3 
    |> (*) (aslr_node 0. 3. 0.2 0.1 trig)
  )
  |> play_tpl
  ;

  let trig = fn () -> 
    let fo = get_tl_tick ();
    set_input_trig_offset synth 0 fo
  ;;

  let trig_open = fn () -> 
    let fo = get_tl_tick ();
    set_input_trig_offset openh_synth 0 fo
  ;;
;




open lib/Arrays;

let q = 60. / 130.;

defer_quant (q * 2.) (fn t ->

  let seqr = fn s ->
    yield s;
    yield seqr ((s + 1) % (array_size seq.note))
  ;;
  seqr 0
  |> cor_map (fn i ->
    let d = 0.25 * q;
    Columnar.trig_from_seq d i seq;
    d
  )
  |> play_routine t schedule_event;

  let seqd = fn s ->
    yield (set_col 0 s 8 pattern col);
    yield seqd ((s + 1) % 16)
  ;;
  seqd 0
    |> cor_map (fn c: (Array of (Int, Double)) ->
      fold (fn i (st, _): (Int, Double) ->
        match (i, st) with
        # | (0, 1) -> () 
        # | (1, 1) -> ()
        # | (2, 1) -> ()
        # | (3, 1) -> ()
        | (4, 1) -> (Hihat.trig_open (); ())
        | (5, 1) -> (Hihat.trig (); ())
        | (6, 1) -> (Snare.trig (); ())
        | (7, 1) -> (Kick_.trig (); ())
        | _ -> ()
        ;
        i + 1
      ) 0 c;  
      0.25 * q
    )
  |> play_routine t schedule_event
); 

# let fx_chain = (fn () ->
#   let input = inlet 0.;
#   reverb_node 0.8 0.8 0.8 1. input
# ) |> play_tpl;
#
# Columnar.synth |> pipe_into fx_chain 0;
#
print `Acid Synth {Columnar.synth}\n`
