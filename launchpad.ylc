import engine/bindings/MIDI;
open lib/Arrays;
import lib/Math;
open lib/Ref;

# MIDI.toggle_midi_debug ();
MIDI.midi_out_setup ();

let LAUNCHPAD_DEST = MIDI.get_destination_by_name (cstr "Launchpad Mini");
let note_ons = [|
  0x0, 0x0, 0x60,
  0x0, 0x1, 0x60,
  0x0, 0x2, 0x60,
  0x0, 0x3, 0x60,
  0x0, 0x4, 0x60,
  0x0, 0x5, 0x60,
  0x0, 0x6, 0x60,
  0x0, 0x7, 0x60,

  0x0, 0x10, 0x60,
  0x0, 0x11, 0x60,
  0x0, 0x12, 0x60,
  0x0, 0x13, 0x60,
  0x0, 0x14, 0x60,
  0x0, 0x15, 0x60,
  0x0, 0x16, 0x60,
  0x0, 0x17, 0x60,

  0x0, 0x20, 0x60,
  0x0, 0x21, 0x60,
  0x0, 0x22, 0x60,
  0x0, 0x23, 0x60,
  0x0, 0x24, 0x60,
  0x0, 0x25, 0x60,
  0x0, 0x26, 0x60,
  0x0, 0x27, 0x60,

  0x0, 0x30, 0x60,
  0x0, 0x31, 0x60,
  0x0, 0x32, 0x60,
  0x0, 0x33, 0x60,
  0x0, 0x34, 0x60,
  0x0, 0x35, 0x60,
  0x0, 0x36, 0x60,
  0x0, 0x37, 0x60,

  0x0, 0x40, 0x60,
  0x0, 0x41, 0x60,
  0x0, 0x42, 0x60,
  0x0, 0x43, 0x60,
  0x0, 0x44, 0x60,
  0x0, 0x45, 0x60,
  0x0, 0x46, 0x60,
  0x0, 0x47, 0x60,

  0x0, 0x50, 0x60,
  0x0, 0x51, 0x60,
  0x0, 0x52, 0x60,
  0x0, 0x53, 0x60,
  0x0, 0x54, 0x60,
  0x0, 0x55, 0x60,
  0x0, 0x56, 0x60,
  0x0, 0x57, 0x60,

  0x0, 0x60, 0x50,
  0x0, 0x61, 0x50,
  0x0, 0x62, 0x50,
  0x0, 0x63, 0x50,
  0x0, 0x64, 0x50,
  0x0, 0x65, 0x50,
  0x0, 0x66, 0x50,
  0x0, 0x67, 0x50,

  0x0, 0x70, 0x50,
  0x0, 0x71, 0x50,
  0x0, 0x72, 0x50,
  0x0, 0x73, 0x50,
  0x0, 0x74, 0x50,
  0x0, 0x75, 0x50,
  0x0, 0x76, 0x50,
  0x0, 0x77, 0x50,
|]; 

MIDI.send_note_offs LAUNCHPAD_DEST (array_size note_ons) (cstr note_ons);

# let pattern = [|
#   0, 0, 0, 0, 0, 0, 0, 0,
#   0, 0, 0, 0, 0, 0, 0, 0,
#   0, 0, 0, 0, 0, 0, 0, 0,
#   0, 0, 0, 0, 0, 0, 0, 0,
#   0, 0, 0, 0, 0, 0, 0, 0,
#   1, 1, 1, 1, 1, 1, 1, 1,
#   0, 0, 0, 0, 1, 0, 0, 0,
#   1, 0, 0, 0, 0, 0, 1, 0,
# |];


let horz_offset = Ref 0;
let max_cols = 16;

let long_pattern = array_fill 128 (fn i: (Int) -> (0, 0.););

let set_grid = fn pattern ->
  let grid_total = 8 * 8;

  let aux = fn i p ->
    match i with
    | i if i < grid_total -> (
      let row = i / 8;
      let col = (deref horz_offset) + i % 8;
      let (is_set, val) = array_at p @@ (row * max_cols) + col;  
      match is_set with
      | 1 -> (
        let n = array_at note_ons @@ i * 3 + 1;
        MIDI.send_note_on LAUNCHPAD_DEST 0x0 n 0x7F;
        ()
        )
      | 0 -> ()
      ;
      aux (i + 1) p
    )
    | _ -> ()
  ;;
  aux 0 pattern
;;


let not = fn i ->
  match i with
  | 0 -> 1 
  | 1 -> 0
;;

let not_pat_val = fn (i, v) ->
  (not (array_at long_pattern i), v)
;;

MIDI.register_note_on_handler 0 (fn midi_note: (Int) vel: (Double) ->
  let col = midi_note % 16; # 16 is grid const
  let row = midi_note / 16; # 16 is grid const
  let pattern_idx = (row * max_cols) + (deref horz_offset) + col;

  array_set (pattern_idx) long_pattern (not_pat_val pattern_idx);
  MIDI.send_note_offs LAUNCHPAD_DEST (array_size note_ons) (cstr note_ons);
  set_grid long_pattern;
  ()
;)
;

# left
MIDI.register_cc_handler 0 106 (fn val ->  
  match val with
  | val if val > 0 -> (
    let off = deref horz_offset;
    array_set 0 horz_offset (Math.max_int (off - 1) 0);

    MIDI.send_note_offs LAUNCHPAD_DEST (array_size note_ons) (cstr note_ons);
    set_grid long_pattern;
    ()
  )
  | _ -> ()
;);

# right 
MIDI.register_cc_handler 0 107 (fn val ->
  match val with 
  | val if val > 0 -> (
    let off = deref horz_offset;
    array_set 0 horz_offset (Math.min_int (off + 1) (max_cols - 8));
    MIDI.send_note_offs LAUNCHPAD_DEST (array_size note_ons) (cstr note_ons);
    set_grid long_pattern;
    ()
  )
  | _ -> ()

;);
